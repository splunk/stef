// Code generated by stefgen. DO NOT EDIT.
// SpanEncoder implements encoding of Span
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class SpanEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private BytesEncoder traceIDEncoder;
    private boolean isTraceIDRecursive = false; // Indicates TraceID field's type is recursive.
    private BytesEncoder spanIDEncoder;
    private boolean isSpanIDRecursive = false; // Indicates SpanID field's type is recursive.
    private StringEncoder traceStateEncoder;
    private boolean isTraceStateRecursive = false; // Indicates TraceState field's type is recursive.
    private BytesEncoder parentSpanIDEncoder;
    private boolean isParentSpanIDRecursive = false; // Indicates ParentSpanID field's type is recursive.
    private Uint64Encoder flagsEncoder;
    private boolean isFlagsRecursive = false; // Indicates Flags field's type is recursive.
    private StringDictEncoder nameEncoder;
    private boolean isNameRecursive = false; // Indicates Name field's type is recursive.
    private Uint64Encoder kindEncoder;
    private boolean isKindRecursive = false; // Indicates Kind field's type is recursive.
    private Uint64Encoder startTimeUnixNanoEncoder;
    private boolean isStartTimeUnixNanoRecursive = false; // Indicates StartTimeUnixNano field's type is recursive.
    private Uint64Encoder endTimeUnixNanoEncoder;
    private boolean isEndTimeUnixNanoRecursive = false; // Indicates EndTimeUnixNano field's type is recursive.
    private AttributesEncoder attributesEncoder;
    private boolean isAttributesRecursive = false; // Indicates Attributes field's type is recursive.
    private Uint64Encoder droppedAttributesCountEncoder;
    private boolean isDroppedAttributesCountRecursive = false; // Indicates DroppedAttributesCount field's type is recursive.
    private EventArrayEncoder eventsEncoder;
    private boolean isEventsRecursive = false; // Indicates Events field's type is recursive.
    private LinkArrayEncoder linksEncoder;
    private boolean isLinksRecursive = false; // Indicates Links field's type is recursive.
    private SpanStatusEncoder statusEncoder;
    private boolean isStatusRecursive = false; // Indicates Status field's type is recursive.
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.SpanEncoder != null) {
            throw new IllegalStateException("cannot initialize SpanEncoder: already initialized");
        }
        state.SpanEncoder = this;

        try {
            this.limiter = state.getLimiter();

            this.fieldCount = state.getStructFieldCounts().getSpanFieldCount();
            this.keepFieldMask = ~((~0L) << this.fieldCount);
            
            // Init encoder for TraceID field.
            if (this.fieldCount <= 0) {
                return; // TraceID and subsequent fields are skipped.
            }
            traceIDEncoder = new BytesEncoder();
            traceIDEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for SpanID field.
            if (this.fieldCount <= 1) {
                return; // SpanID and subsequent fields are skipped.
            }
            spanIDEncoder = new BytesEncoder();
            spanIDEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for TraceState field.
            if (this.fieldCount <= 2) {
                return; // TraceState and subsequent fields are skipped.
            }
            traceStateEncoder = new StringEncoder();
            traceStateEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for ParentSpanID field.
            if (this.fieldCount <= 3) {
                return; // ParentSpanID and subsequent fields are skipped.
            }
            parentSpanIDEncoder = new BytesEncoder();
            parentSpanIDEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Flags field.
            if (this.fieldCount <= 4) {
                return; // Flags and subsequent fields are skipped.
            }
            flagsEncoder = new Uint64Encoder();
            flagsEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Name field.
            if (this.fieldCount <= 5) {
                return; // Name and subsequent fields are skipped.
            }
            nameEncoder = new StringDictEncoder();
            nameEncoder.init(state.SpanName, limiter, columns.addSubColumn());
            // Init encoder for Kind field.
            if (this.fieldCount <= 6) {
                return; // Kind and subsequent fields are skipped.
            }
            kindEncoder = new Uint64Encoder();
            kindEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for StartTimeUnixNano field.
            if (this.fieldCount <= 7) {
                return; // StartTimeUnixNano and subsequent fields are skipped.
            }
            startTimeUnixNanoEncoder = new Uint64Encoder();
            startTimeUnixNanoEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for EndTimeUnixNano field.
            if (this.fieldCount <= 8) {
                return; // EndTimeUnixNano and subsequent fields are skipped.
            }
            endTimeUnixNanoEncoder = new Uint64Encoder();
            endTimeUnixNanoEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Attributes field.
            if (this.fieldCount <= 9) {
                return; // Attributes and subsequent fields are skipped.
            }
            if (state.AttributesEncoder != null) {
                // Recursion detected, use the existing encoder.
                attributesEncoder = state.AttributesEncoder;
                isAttributesRecursive = true;
            } else {
                attributesEncoder = new AttributesEncoder();
                attributesEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for DroppedAttributesCount field.
            if (this.fieldCount <= 10) {
                return; // DroppedAttributesCount and subsequent fields are skipped.
            }
            droppedAttributesCountEncoder = new Uint64Encoder();
            droppedAttributesCountEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Events field.
            if (this.fieldCount <= 11) {
                return; // Events and subsequent fields are skipped.
            }
            if (state.EventArrayEncoder != null) {
                // Recursion detected, use the existing encoder.
                eventsEncoder = state.EventArrayEncoder;
                isEventsRecursive = true;
            } else {
                eventsEncoder = new EventArrayEncoder();
                eventsEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Links field.
            if (this.fieldCount <= 12) {
                return; // Links and subsequent fields are skipped.
            }
            if (state.LinkArrayEncoder != null) {
                // Recursion detected, use the existing encoder.
                linksEncoder = state.LinkArrayEncoder;
                isLinksRecursive = true;
            } else {
                linksEncoder = new LinkArrayEncoder();
                linksEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Status field.
            if (this.fieldCount <= 13) {
                return; // Status and subsequent fields are skipped.
            }
            if (state.SpanStatusEncoder != null) {
                // Recursion detected, use the existing encoder.
                statusEncoder = state.SpanStatusEncoder;
                isStatusRecursive = true;
            } else {
                statusEncoder = new SpanStatusEncoder();
                statusEncoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.SpanEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcefully writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        
        if (fieldCount <= 0) {
            return; // TraceID and all subsequent fields are skipped.
        }
        traceIDEncoder.reset();
        if (fieldCount <= 1) {
            return; // SpanID and all subsequent fields are skipped.
        }
        spanIDEncoder.reset();
        if (fieldCount <= 2) {
            return; // TraceState and all subsequent fields are skipped.
        }
        traceStateEncoder.reset();
        if (fieldCount <= 3) {
            return; // ParentSpanID and all subsequent fields are skipped.
        }
        parentSpanIDEncoder.reset();
        if (fieldCount <= 4) {
            return; // Flags and all subsequent fields are skipped.
        }
        flagsEncoder.reset();
        if (fieldCount <= 5) {
            return; // Name and all subsequent fields are skipped.
        }
        nameEncoder.reset();
        if (fieldCount <= 6) {
            return; // Kind and all subsequent fields are skipped.
        }
        kindEncoder.reset();
        if (fieldCount <= 7) {
            return; // StartTimeUnixNano and all subsequent fields are skipped.
        }
        startTimeUnixNanoEncoder.reset();
        if (fieldCount <= 8) {
            return; // EndTimeUnixNano and all subsequent fields are skipped.
        }
        endTimeUnixNanoEncoder.reset();
        if (fieldCount <= 9) {
            return; // Attributes and all subsequent fields are skipped.
        }
        
        if (!isAttributesRecursive) {
            attributesEncoder.reset();
        }
        
        if (fieldCount <= 10) {
            return; // DroppedAttributesCount and all subsequent fields are skipped.
        }
        droppedAttributesCountEncoder.reset();
        if (fieldCount <= 11) {
            return; // Events and all subsequent fields are skipped.
        }
        
        if (!isEventsRecursive) {
            eventsEncoder.reset();
        }
        
        if (fieldCount <= 12) {
            return; // Links and all subsequent fields are skipped.
        }
        
        if (!isLinksRecursive) {
            linksEncoder.reset();
        }
        
        if (fieldCount <= 13) {
            return; // Status and all subsequent fields are skipped.
        }
        
        if (!isStatusRecursive) {
            statusEncoder.reset();
        }
        
    }

    // encode encodes val into buf
    public void encode(Span val) throws IOException {
        int oldLen = this.buf.bitCount();

        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Span.fieldModifiedTraceID | 
                Span.fieldModifiedSpanID | 
                Span.fieldModifiedTraceState | 
                Span.fieldModifiedParentSpanID | 
                Span.fieldModifiedFlags | 
                Span.fieldModifiedName | 
                Span.fieldModifiedKind | 
                Span.fieldModifiedStartTimeUnixNano | 
                Span.fieldModifiedEndTimeUnixNano | 
                Span.fieldModifiedAttributes | 
                Span.fieldModifiedDroppedAttributesCount | 
                Span.fieldModifiedEvents | 
                Span.fieldModifiedLinks | 
                Span.fieldModifiedStatus | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Span.fieldModifiedTraceID) != 0) {
            // Encode TraceID
            this.traceIDEncoder.encode(val.traceID);
        }
        
        if ((fieldMask & Span.fieldModifiedSpanID) != 0) {
            // Encode SpanID
            this.spanIDEncoder.encode(val.spanID);
        }
        
        if ((fieldMask & Span.fieldModifiedTraceState) != 0) {
            // Encode TraceState
            this.traceStateEncoder.encode(val.traceState);
        }
        
        if ((fieldMask & Span.fieldModifiedParentSpanID) != 0) {
            // Encode ParentSpanID
            this.parentSpanIDEncoder.encode(val.parentSpanID);
        }
        
        if ((fieldMask & Span.fieldModifiedFlags) != 0) {
            // Encode Flags
            this.flagsEncoder.encode(val.flags);
        }
        
        if ((fieldMask & Span.fieldModifiedName) != 0) {
            // Encode Name
            this.nameEncoder.encode(val.name);
        }
        
        if ((fieldMask & Span.fieldModifiedKind) != 0) {
            // Encode Kind
            this.kindEncoder.encode(val.kind);
        }
        
        if ((fieldMask & Span.fieldModifiedStartTimeUnixNano) != 0) {
            // Encode StartTimeUnixNano
            this.startTimeUnixNanoEncoder.encode(val.startTimeUnixNano);
        }
        
        if ((fieldMask & Span.fieldModifiedEndTimeUnixNano) != 0) {
            // Encode EndTimeUnixNano
            this.endTimeUnixNanoEncoder.encode(val.endTimeUnixNano);
        }
        
        if ((fieldMask & Span.fieldModifiedAttributes) != 0) {
            // Encode Attributes
            this.attributesEncoder.encode(val.attributes);
        }
        
        if ((fieldMask & Span.fieldModifiedDroppedAttributesCount) != 0) {
            // Encode DroppedAttributesCount
            this.droppedAttributesCountEncoder.encode(val.droppedAttributesCount);
        }
        
        if ((fieldMask & Span.fieldModifiedEvents) != 0) {
            // Encode Events
            this.eventsEncoder.encode(val.events);
        }
        
        if ((fieldMask & Span.fieldModifiedLinks) != 0) {
            // Encode Links
            this.linksEncoder.encode(val.links);
        }
        
        if ((fieldMask & Span.fieldModifiedStatus) != 0) {
            // Encode Status
            this.statusEncoder.encode(val.status);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect TraceID field.
        if (this.fieldCount <= 0) {
            return; // TraceID and subsequent fields are skipped.
        }
        
        traceIDEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect SpanID field.
        if (this.fieldCount <= 1) {
            return; // SpanID and subsequent fields are skipped.
        }
        
        spanIDEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect TraceState field.
        if (this.fieldCount <= 2) {
            return; // TraceState and subsequent fields are skipped.
        }
        
        traceStateEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect ParentSpanID field.
        if (this.fieldCount <= 3) {
            return; // ParentSpanID and subsequent fields are skipped.
        }
        
        parentSpanIDEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Flags field.
        if (this.fieldCount <= 4) {
            return; // Flags and subsequent fields are skipped.
        }
        
        flagsEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Name field.
        if (this.fieldCount <= 5) {
            return; // Name and subsequent fields are skipped.
        }
        
        nameEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Kind field.
        if (this.fieldCount <= 6) {
            return; // Kind and subsequent fields are skipped.
        }
        
        kindEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect StartTimeUnixNano field.
        if (this.fieldCount <= 7) {
            return; // StartTimeUnixNano and subsequent fields are skipped.
        }
        
        startTimeUnixNanoEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect EndTimeUnixNano field.
        if (this.fieldCount <= 8) {
            return; // EndTimeUnixNano and subsequent fields are skipped.
        }
        
        endTimeUnixNanoEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Attributes field.
        if (this.fieldCount <= 9) {
            return; // Attributes and subsequent fields are skipped.
        }
        if (!isAttributesRecursive) {
            attributesEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect DroppedAttributesCount field.
        if (this.fieldCount <= 10) {
            return; // DroppedAttributesCount and subsequent fields are skipped.
        }
        
        droppedAttributesCountEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Events field.
        if (this.fieldCount <= 11) {
            return; // Events and subsequent fields are skipped.
        }
        if (!isEventsRecursive) {
            eventsEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Links field.
        if (this.fieldCount <= 12) {
            return; // Links and subsequent fields are skipped.
        }
        if (!isLinksRecursive) {
            linksEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Status field.
        if (this.fieldCount <= 13) {
            return; // Status and subsequent fields are skipped.
        }
        if (!isStatusRecursive) {
            statusEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
    }
}

