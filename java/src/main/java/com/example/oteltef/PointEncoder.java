// Code generated by stefc. DO NOT EDIT.
// PointEncoder implements encoding of Point
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class PointEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private Uint64DeltaDeltaEncoder startTimestampEncoder;
    private boolean isStartTimestampRecursive = false; // Indicates StartTimestamp field's type is recursive.
    private Uint64DeltaDeltaEncoder timestampEncoder;
    private boolean isTimestampRecursive = false; // Indicates Timestamp field's type is recursive.
    private PointValueEncoder valueEncoder;
    private boolean isValueRecursive = false; // Indicates Value field's type is recursive.
    private ExemplarArrayEncoder exemplarsEncoder;
    private boolean isExemplarsRecursive = false; // Indicates Exemplars field's type is recursive.
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.PointEncoder != null) {
            throw new IllegalStateException("cannot initialize PointEncoder: already initialized");
        }
        state.PointEncoder = this;

        try {
            this.limiter = state.getLimiter();

            this.fieldCount = state.getStructFieldCounts().getPointFieldCount();
            this.keepFieldMask = ~((~0L) << this.fieldCount);
            
            // Init encoder for StartTimestamp field.
            if (this.fieldCount <= 0) {
                return; // StartTimestamp and subsequent fields are skipped.
            }
            startTimestampEncoder = new Uint64DeltaDeltaEncoder();
            startTimestampEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Timestamp field.
            if (this.fieldCount <= 1) {
                return; // Timestamp and subsequent fields are skipped.
            }
            timestampEncoder = new Uint64DeltaDeltaEncoder();
            timestampEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Value field.
            if (this.fieldCount <= 2) {
                return; // Value and subsequent fields are skipped.
            }
            if (state.PointValueEncoder != null) {
                // Recursion detected, use the existing encoder.
                valueEncoder = state.PointValueEncoder;
                isValueRecursive = true;
            } else {
                valueEncoder = new PointValueEncoder();
                valueEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Exemplars field.
            if (this.fieldCount <= 3) {
                return; // Exemplars and subsequent fields are skipped.
            }
            if (state.ExemplarArrayEncoder != null) {
                // Recursion detected, use the existing encoder.
                exemplarsEncoder = state.ExemplarArrayEncoder;
                isExemplarsRecursive = true;
            } else {
                exemplarsEncoder = new ExemplarArrayEncoder();
                exemplarsEncoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.PointEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcefully writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        
        if (fieldCount <= 0) {
            return; // StartTimestamp and all subsequent fields are skipped.
        }
        startTimestampEncoder.reset();
        if (fieldCount <= 1) {
            return; // Timestamp and all subsequent fields are skipped.
        }
        timestampEncoder.reset();
        if (fieldCount <= 2) {
            return; // Value and all subsequent fields are skipped.
        }
        
        if (!isValueRecursive) {
            valueEncoder.reset();
        }
        
        if (fieldCount <= 3) {
            return; // Exemplars and all subsequent fields are skipped.
        }
        
        if (!isExemplarsRecursive) {
            exemplarsEncoder.reset();
        }
        
    }

    // encode encodes val into buf
    public void encode(Point val) throws IOException {
        int oldLen = this.buf.bitCount();

        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Point.fieldModifiedStartTimestamp | 
                Point.fieldModifiedTimestamp | 
                Point.fieldModifiedValue | 
                Point.fieldModifiedExemplars | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Point.fieldModifiedStartTimestamp) != 0) {
            // Encode StartTimestamp
            this.startTimestampEncoder.encode(val.startTimestamp);
        }
        
        if ((fieldMask & Point.fieldModifiedTimestamp) != 0) {
            // Encode Timestamp
            this.timestampEncoder.encode(val.timestamp);
        }
        
        if ((fieldMask & Point.fieldModifiedValue) != 0) {
            // Encode Value
            this.valueEncoder.encode(val.value);
        }
        
        if ((fieldMask & Point.fieldModifiedExemplars) != 0) {
            // Encode Exemplars
            this.exemplarsEncoder.encode(val.exemplars);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect StartTimestamp field.
        if (this.fieldCount <= 0) {
            return; // StartTimestamp and subsequent fields are skipped.
        }
        
        startTimestampEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Timestamp field.
        if (this.fieldCount <= 1) {
            return; // Timestamp and subsequent fields are skipped.
        }
        
        timestampEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Value field.
        if (this.fieldCount <= 2) {
            return; // Value and subsequent fields are skipped.
        }
        if (!isValueRecursive) {
            valueEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Exemplars field.
        if (this.fieldCount <= 3) {
            return; // Exemplars and subsequent fields are skipped.
        }
        if (!isExemplarsRecursive) {
            exemplarsEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
    }
}

