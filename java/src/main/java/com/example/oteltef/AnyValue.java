// Code generated by stefgen. DO NOT EDIT.
// AnyValue Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import java.util.*;

// AnyValue is a oneof struct.
public class AnyValue {
    // The current type of the oneof.
    Type typ;
    
    StringValue string;
    boolean bool;
    long int64;
    double float64;
    AnyValueArray array;
    KeyValueList kVList;
    byte[] bytes;

    // Pointer to parent's modifiedFields
    private ModifiedFields parentModifiedFields;
    // Bit to set in parent's modifiedFields when this oneof is modified.
    private long parentModifiedBit;

    AnyValue() {
        init(null, 0);
    }

    AnyValue(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        typ = Type.TypeNone;
        this.parentModifiedFields = parentModifiedFields;
        this.parentModifiedBit = parentModifiedBit;
        
        string = StringValue.empty;
        
        
        
        array = new AnyValueArray(parentModifiedFields, parentModifiedBit);
        kVList = new KeyValueList(parentModifiedFields, parentModifiedBit);
        bytes = Types.emptyBytes;
    }

    // Type enum for oneof
    public enum Type {
        TypeNone(0),
        TypeString(0 + 1),
        TypeBool(1 + 1),
        TypeInt64(2 + 1),
        TypeFloat64(3 + 1),
        TypeArray(4 + 1),
        TypeKVList(5 + 1),
        TypeBytes(6 + 1),
        TypeCount(7 + 1);

        private final int value;

        Type(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    }

    // getType returns the type of the value currently contained in AnyValue.
    public Type getType() {
        return typ;
    }

    // setType sets the type of the value currently contained in AnyValue.
    public void setType(Type typ) {
        if (this.typ != typ) {
            this.typ = typ;
            this.markParentModified();
        }
    }

    
    // String returns the value if the contained type is currently TypeString.
    // The caller must check the type via getType() before attempting to call this function.
    public StringValue getString() {
        return this.string;
    }
    
    // SetString sets the value to the specified value and sets the type to TypeString.
    public void setString(StringValue v) {
        if (!Types.StringEqual(this.string, v) || this.typ != Type.TypeString) {
            this.string = v;
            this.typ = Type.TypeString;
            this.markParentModified();
        }
    }
    
    
    // Bool returns the value if the contained type is currently TypeBool.
    // The caller must check the type via getType() before attempting to call this function.
    public boolean getBool() {
        return this.bool;
    }
    
    // SetBool sets the value to the specified value and sets the type to TypeBool.
    public void setBool(boolean v) {
        if (!Types.BoolEqual(this.bool, v) || this.typ != Type.TypeBool) {
            this.bool = v;
            this.typ = Type.TypeBool;
            this.markParentModified();
        }
    }
    
    
    // Int64 returns the value if the contained type is currently TypeInt64.
    // The caller must check the type via getType() before attempting to call this function.
    public long getInt64() {
        return this.int64;
    }
    
    // SetInt64 sets the value to the specified value and sets the type to TypeInt64.
    public void setInt64(long v) {
        if (!Types.Int64Equal(this.int64, v) || this.typ != Type.TypeInt64) {
            this.int64 = v;
            this.typ = Type.TypeInt64;
            this.markParentModified();
        }
    }
    
    
    // Float64 returns the value if the contained type is currently TypeFloat64.
    // The caller must check the type via getType() before attempting to call this function.
    public double getFloat64() {
        return this.float64;
    }
    
    // SetFloat64 sets the value to the specified value and sets the type to TypeFloat64.
    public void setFloat64(double v) {
        if (!Types.Float64Equal(this.float64, v) || this.typ != Type.TypeFloat64) {
            this.float64 = v;
            this.typ = Type.TypeFloat64;
            this.markParentModified();
        }
    }
    
    
    // Array returns the value if the contained type is currently TypeArray.
    // The caller must check the type via getType() before attempting to call this function.
    public AnyValueArray getArray() {
        return this.array;
    }
    
    
    // KVList returns the value if the contained type is currently TypeKVList.
    // The caller must check the type via getType() before attempting to call this function.
    public KeyValueList getKVList() {
        return this.kVList;
    }
    
    
    // Bytes returns the value if the contained type is currently TypeBytes.
    // The caller must check the type via getType() before attempting to call this function.
    public byte[] getBytes() {
        return this.bytes;
    }
    
    // SetBytes sets the value to the specified value and sets the type to TypeBytes.
    public void setBytes(byte[] v) {
        if (!Types.BytesEqual(this.bytes, v) || this.typ != Type.TypeBytes) {
            this.bytes = v;
            this.typ = Type.TypeBytes;
            this.markParentModified();
        }
    }
    
    

    // Clone returns a deep copy of this oneof.
    public AnyValue clone() {
        AnyValue cpy = new AnyValue();
        cpy.typ = this.typ;
        cpy.string = this.string;
        cpy.bool = this.bool;
        cpy.int64 = this.int64;
        cpy.float64 = this.float64;
        cpy.array = this.array.clone();
        cpy.kVList = this.kVList.clone();
        cpy.bytes = this.bytes;
        return cpy;
    }

    // byteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    public int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        
        
        
        size += this.array.byteSize();
        size += this.kVList.byteSize();
        
        return size;
    }

    // copy performs a deep copy from src.
    public void copyFrom(AnyValue src) {
        switch (src.typ) {
        case TypeString:
            setString(src.getString());
            break;
        case TypeBool:
            setBool(src.getBool());
            break;
        case TypeInt64:
            setInt64(src.getInt64());
            break;
        case TypeFloat64:
            setFloat64(src.getFloat64());
            break;
        case TypeArray:
            array.copyFrom(src.array);
            break;
        case TypeKVList:
            kVList.copyFrom(src.kVList);
            break;
        case TypeBytes:
            setBytes(src.getBytes());
            break;
        }
        setType(src.typ);
    }

    private void markParentModified() {
        if (parentModifiedFields != null) {
            parentModifiedFields.markModified(parentModifiedBit);
        }
    }

    void markUnmodified() {
        this.array.markUnmodified();
        this.kVList.markUnmodified();
    }

    void markUnmodifiedRecursively() {
        switch (this.typ) {
        case TypeString:
            break;
        case TypeBool:
            break;
        case TypeInt64:
            break;
        case TypeFloat64:
            break;
        case TypeArray:
            this.array.markUnmodifiedRecursively();
            break;
        case TypeKVList:
            this.kVList.markUnmodifiedRecursively();
            break;
        case TypeBytes:
            break;
        default:
            break;
        }
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(AnyValue val) {
        if (this.typ != val.typ) {
            return false;
        }
        switch (this.typ) {
        case TypeString:
            if (!Types.StringEqual(this.string, val.string)) {
                return false;
            }
            break;
        case TypeBool:
            if (!Types.BoolEqual(this.bool, val.bool)) {
                return false;
            }
            break;
        case TypeInt64:
            if (!Types.Int64Equal(this.int64, val.int64)) {
                return false;
            }
            break;
        case TypeFloat64:
            if (!Types.Float64Equal(this.float64, val.float64)) {
                return false;
            }
            break;
        case TypeArray:
            if (!this.array.equals(val.array)) {
                return false;
            }
            break;
        case TypeKVList:
            if (!this.kVList.equals(val.kVList)) {
                return false;
            }
            break;
        case TypeBytes:
            if (!Types.BytesEqual(this.bytes, val.bytes)) {
                return false;
            }
            break;
        default:
            break;
        }
        return true;
    }

    public static boolean equals(AnyValue left, AnyValue right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns 0 if equal, negative if left < right, positive if left > right.
    public static int compare(AnyValue left, AnyValue right) {
        if (left == null) return right == null ? 0 : -1;
        if (right == null) return 1;
        int c = Integer.compare(left.typ.ordinal(), right.typ.ordinal());
        if (c != 0) return c;
        switch (left.typ) {
        case TypeString:
            c = Types.StringCompare(left.string, right.string);
            if (c != 0) {
                return c;
            }
            break;
        case TypeBool:
            c = Types.BoolCompare(left.bool, right.bool);
            if (c != 0) {
                return c;
            }
            break;
        case TypeInt64:
            c = Types.Int64Compare(left.int64, right.int64);
            if (c != 0) {
                return c;
            }
            break;
        case TypeFloat64:
            c = Types.Float64Compare(left.float64, right.float64);
            if (c != 0) {
                return c;
            }
            break;
        case TypeArray:
            c = AnyValueArray.compare(left.array, right.array);
            if (c != 0) {
                return c;
            }
            break;
        case TypeKVList:
            c = KeyValueList.compare(left.kVList, right.kVList);
            if (c != 0) {
                return c;
            }
            break;
        case TypeBytes:
            c = Types.BytesCompare(left.bytes, right.bytes);
            if (c != 0) {
                return c;
            }
            break;
        default:
            break;
        }
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        int fieldCount = 7;
        boolean typeChanged = false;
        if (random.nextInt(10) == 0) {
            this.setType(Type.values()[random.nextInt(fieldCount + 1)]);
            typeChanged = true;
        }
        switch (this.typ) {
        case TypeString:
            if (typeChanged || random.nextInt(2) == 0) {
                this.setString(Types.StringRandom(random));
            }
            break;
        case TypeBool:
            if (typeChanged || random.nextInt(2) == 0) {
                this.setBool(Types.BoolRandom(random));
            }
            break;
        case TypeInt64:
            if (typeChanged || random.nextInt(2) == 0) {
                this.setInt64(Types.Int64Random(random));
            }
            break;
        case TypeFloat64:
            if (typeChanged || random.nextInt(2) == 0) {
                this.setFloat64(Types.Float64Random(random));
            }
            break;
        case TypeArray:
            if (typeChanged || random.nextInt(2) == 0) {
                this.array.mutateRandom(random);
            }
            break;
        case TypeKVList:
            if (typeChanged || random.nextInt(2) == 0) {
                this.kVList.mutateRandom(random);
            }
            break;
        case TypeBytes:
            if (typeChanged || random.nextInt(2) == 0) {
                this.setBytes(Types.BytesRandom(random));
            }
            break;
        default:
            break;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((AnyValue)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            string,
            bool,
            int64,
            float64,
            array,
            kVList,
            bytes,
            typ
        );
    }
}

