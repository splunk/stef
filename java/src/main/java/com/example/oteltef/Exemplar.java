// Code generated by stefgen. DO NOT EDIT.
// Exemplar Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class Exemplar {
    // Field values.
    
    long timestamp;
    ExemplarValue value;
    byte[] spanID;
    byte[] traceID;
    Attributes filteredAttributes;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "Exemplar";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedTimestamp = 1 << 0;
    public static final long fieldModifiedValue = 1 << 1;
    public static final long fieldModifiedSpanID = 1 << 2;
    public static final long fieldModifiedTraceID = 1 << 3;
    public static final long fieldModifiedFilteredAttributes = 1 << 4;

    

    public Exemplar() {
        init(null, 0);
    }

    Exemplar(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        
        value = new ExemplarValue(modifiedFields, fieldModifiedValue);
        spanID = Types.emptyBytes;
        traceID = Types.emptyBytes;
        filteredAttributes = new Attributes(modifiedFields, fieldModifiedFilteredAttributes);
    }

    void reset() {
        
        
        value.reset();
        spanID = Types.emptyBytes;
        traceID = Types.emptyBytes;
        filteredAttributes.reset();
    }

    
    public long getTimestamp() {
        return timestamp;
    }

    // setTimestamp sets the value of Timestamp field.
    public void setTimestamp(long v) {
        if (!Types.Uint64Equal(this.timestamp, v)) {
            this.timestamp = v;
            this.markTimestampModified();
        }
    }

    private void markTimestampModified() {
        this.modifiedFields.markModified(fieldModifiedTimestamp);
    }

    // isTimestampModified returns true if the value of Timestamp field was modified since
    // Exemplar was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isTimestampModified() {
        return (this.modifiedFields.mask & fieldModifiedTimestamp) != 0;
    }
    
    public ExemplarValue getValue() {
        return this.value;
    }

    private void markValueModified() {
        this.modifiedFields.markModified(fieldModifiedValue);
    }

    // isValueModified returns true if the value of Value field was modified since
    // Exemplar was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isValueModified() {
        return (this.modifiedFields.mask & fieldModifiedValue) != 0;
    }
    
    public byte[] getSpanID() {
        return spanID;
    }

    // setSpanID sets the value of SpanID field.
    public void setSpanID(byte[] v) {
        if (!Types.BytesEqual(this.spanID, v)) {
            this.spanID = v;
            this.markSpanIDModified();
        }
    }

    private void markSpanIDModified() {
        this.modifiedFields.markModified(fieldModifiedSpanID);
    }

    // isSpanIDModified returns true if the value of SpanID field was modified since
    // Exemplar was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isSpanIDModified() {
        return (this.modifiedFields.mask & fieldModifiedSpanID) != 0;
    }
    
    public byte[] getTraceID() {
        return traceID;
    }

    // setTraceID sets the value of TraceID field.
    public void setTraceID(byte[] v) {
        if (!Types.BytesEqual(this.traceID, v)) {
            this.traceID = v;
            this.markTraceIDModified();
        }
    }

    private void markTraceIDModified() {
        this.modifiedFields.markModified(fieldModifiedTraceID);
    }

    // isTraceIDModified returns true if the value of TraceID field was modified since
    // Exemplar was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isTraceIDModified() {
        return (this.modifiedFields.mask & fieldModifiedTraceID) != 0;
    }
    
    public Attributes getFilteredAttributes() {
        return this.filteredAttributes;
    }

    private void markFilteredAttributesModified() {
        this.modifiedFields.markModified(fieldModifiedFilteredAttributes);
    }

    // isFilteredAttributesModified returns true if the value of FilteredAttributes field was modified since
    // Exemplar was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isFilteredAttributesModified() {
        return (this.modifiedFields.mask & fieldModifiedFilteredAttributes) != 0;
    }
    

    void markModifiedRecursively() {
        value.markModifiedRecursively();
        filteredAttributes.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedTimestamp | 
            fieldModifiedValue | 
            fieldModifiedSpanID | 
            fieldModifiedTraceID | 
            fieldModifiedFilteredAttributes | 0;
    }

    void markUnmodifiedRecursively() {
        if (isValueModified()) {
            value.markUnmodifiedRecursively();
        }
        if (isFilteredAttributesModified()) {
            filteredAttributes.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    public Exemplar clone() {
        Exemplar cpy = new Exemplar();
        cpy.timestamp = this.timestamp;
        cpy.value = this.value.clone();
        cpy.spanID = this.spanID;
        cpy.traceID = this.traceID;
        cpy.filteredAttributes = this.filteredAttributes.clone();
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        size += this.value.byteSize();
        
        
        size += this.filteredAttributes.byteSize();
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(Exemplar src) {
        setTimestamp(src.getTimestamp());
        value.copyFrom(src.value);
        setSpanID(src.getSpanID());
        setTraceID(src.getTraceID());
        filteredAttributes.copyFrom(src.filteredAttributes);
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(Exemplar right) {
        // Compare Timestamp field.
        if (!Types.Uint64Equal(this.timestamp, right.timestamp)) {
            return false;
        }
        // Compare Value field.
        if (!this.value.equals(right.value)) {
            return false;
        }
        // Compare SpanID field.
        if (!Types.BytesEqual(this.spanID, right.spanID)) {
            return false;
        }
        // Compare TraceID field.
        if (!Types.BytesEqual(this.traceID, right.traceID)) {
            return false;
        }
        // Compare FilteredAttributes field.
        if (!this.filteredAttributes.equals(right.filteredAttributes)) {
            return false;
        }
        return true;
    }

    public static boolean equals(Exemplar left, Exemplar right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(Exemplar left, Exemplar right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare Timestamp field.
        c = Types.Uint64Compare(left.timestamp, right.timestamp);
        if (c != 0) {
            return c;
        }
        
        // Compare Value field.
        c = ExemplarValue.compare(left.value, right.value);
        if (c != 0) {
            return c;
        }
        
        // Compare SpanID field.
        c = Types.BytesCompare(left.spanID, right.spanID);
        if (c != 0) {
            return c;
        }
        
        // Compare TraceID field.
        c = Types.BytesCompare(left.traceID, right.traceID);
        if (c != 0) {
            return c;
        }
        
        // Compare FilteredAttributes field.
        c = Attributes.compare(left.filteredAttributes, right.filteredAttributes);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(5,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.setTimestamp(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.value.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setSpanID(Types.BytesRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setTraceID(Types.BytesRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.filteredAttributes.mutateRandom(random);
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((Exemplar)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            timestamp,
            value,
            spanID,
            traceID,
            filteredAttributes
        );
    }

    
}
