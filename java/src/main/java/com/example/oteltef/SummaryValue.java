// Code generated by stefgen. DO NOT EDIT.
// SummaryValue Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class SummaryValue {
    // Field values.
    
    long count;
    double sum;
    QuantileValueArray quantileValues;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "SummaryValue";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedCount = 1 << 0;
    public static final long fieldModifiedSum = 1 << 1;
    public static final long fieldModifiedQuantileValues = 1 << 2;

    

    public SummaryValue() {
        init(null, 0);
    }

    SummaryValue(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        
        
        quantileValues = new QuantileValueArray(modifiedFields, fieldModifiedQuantileValues);
    }

    void reset() {
        
        
        
        quantileValues.reset();
    }

    
    public long getCount() {
        return count;
    }

    // setCount sets the value of Count field.
    public void setCount(long v) {
        if (!Types.Uint64Equal(this.count, v)) {
            this.count = v;
            this.markCountModified();
        }
    }

    private void markCountModified() {
        this.modifiedFields.markModified(fieldModifiedCount);
    }

    // isCountModified returns true if the value of Count field was modified since
    // SummaryValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isCountModified() {
        return (this.modifiedFields.mask & fieldModifiedCount) != 0;
    }
    
    public double getSum() {
        return sum;
    }

    // setSum sets the value of Sum field.
    public void setSum(double v) {
        if (!Types.Float64Equal(this.sum, v)) {
            this.sum = v;
            this.markSumModified();
        }
    }

    private void markSumModified() {
        this.modifiedFields.markModified(fieldModifiedSum);
    }

    // isSumModified returns true if the value of Sum field was modified since
    // SummaryValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isSumModified() {
        return (this.modifiedFields.mask & fieldModifiedSum) != 0;
    }
    
    public QuantileValueArray getQuantileValues() {
        return this.quantileValues;
    }

    private void markQuantileValuesModified() {
        this.modifiedFields.markModified(fieldModifiedQuantileValues);
    }

    // isQuantileValuesModified returns true if the value of QuantileValues field was modified since
    // SummaryValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isQuantileValuesModified() {
        return (this.modifiedFields.mask & fieldModifiedQuantileValues) != 0;
    }
    

    void markModifiedRecursively() {
        quantileValues.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedCount | 
            fieldModifiedSum | 
            fieldModifiedQuantileValues | 0;
    }

    void markUnmodifiedRecursively() {
        if (isQuantileValuesModified()) {
            quantileValues.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    public SummaryValue clone() {
        SummaryValue cpy = new SummaryValue();
        cpy.count = this.count;
        cpy.sum = this.sum;
        cpy.quantileValues = this.quantileValues.clone();
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        
        size += this.quantileValues.byteSize();
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(SummaryValue src) {
        setCount(src.getCount());
        setSum(src.getSum());
        quantileValues.copyFrom(src.quantileValues);
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(SummaryValue right) {
        // Compare Count field.
        if (!Types.Uint64Equal(this.count, right.count)) {
            return false;
        }
        // Compare Sum field.
        if (!Types.Float64Equal(this.sum, right.sum)) {
            return false;
        }
        // Compare QuantileValues field.
        if (!this.quantileValues.equals(right.quantileValues)) {
            return false;
        }
        return true;
    }

    public static boolean equals(SummaryValue left, SummaryValue right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(SummaryValue left, SummaryValue right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare Count field.
        c = Types.Uint64Compare(left.count, right.count);
        if (c != 0) {
            return c;
        }
        
        // Compare Sum field.
        c = Types.Float64Compare(left.sum, right.sum);
        if (c != 0) {
            return c;
        }
        
        // Compare QuantileValues field.
        c = QuantileValueArray.compare(left.quantileValues, right.quantileValues);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(3,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.setCount(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setSum(Types.Float64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.quantileValues.mutateRandom(random);
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((SummaryValue)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            count,
            sum,
            quantileValues
        );
    }

    
}
