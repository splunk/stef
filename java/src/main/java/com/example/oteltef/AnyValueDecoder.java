// Code generated by stefc. DO NOT EDIT.
// AnyValueDecoder implements decoding of AnyValue
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class AnyValueDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    // fieldCount is the number of fields, i.e. the number of types in this oneof.
    private int fieldCount;
    // Number of bits needed to encode the type (including None type).
    private int typeBitCount;

    // Field decoders.
    
    private StringDictDecoder stringDecoder;
    private boolean isStringRecursive = false; // Indicates String field's type is recursive.
    private BoolDecoder boolDecoder;
    private boolean isBoolRecursive = false; // Indicates Bool field's type is recursive.
    private Int64Decoder int64Decoder;
    private boolean isInt64Recursive = false; // Indicates Int64 field's type is recursive.
    private Float64Decoder float64Decoder;
    private boolean isFloat64Recursive = false; // Indicates Float64 field's type is recursive.
    private AnyValueArrayDecoder arrayDecoder;
    private boolean isArrayRecursive = false; // Indicates Array field's type is recursive.
    private KeyValueListDecoder kVListDecoder;
    private boolean isKVListRecursive = false; // Indicates KVList field's type is recursive.
    private BytesDecoder bytesDecoder;
    private boolean isBytesRecursive = false; // Indicates Bytes field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this decoder in the state so that we can detect recursion.
        if (state.AnyValueDecoder != null) {
            throw new IllegalStateException("cannot initialize AnyValueDecoder: already initialized");
        }
        state.AnyValueDecoder = this;

        try {
            this.fieldCount = state.getStructFieldCounts().getAnyValueFieldCount();
            this.typeBitCount = Integer.SIZE - Integer.numberOfLeadingZeros(this.fieldCount+1);
            this.column = columns.getColumn();
            Exception err = null;
            
            if (this.fieldCount <= 0) {
                return; // String and subsequent fields are skipped.
            }
            stringDecoder = new StringDictDecoder();
            stringDecoder.init(state.AnyValueString, columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Bool and subsequent fields are skipped.
            }
            boolDecoder = new BoolDecoder();
            boolDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // Int64 and subsequent fields are skipped.
            }
            int64Decoder = new Int64Decoder();
            int64Decoder.init(columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // Float64 and subsequent fields are skipped.
            }
            float64Decoder = new Float64Decoder();
            float64Decoder.init(columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // Array and subsequent fields are skipped.
            }
            if (state.AnyValueArrayDecoder != null) {
                // Recursion detected, use the existing decoder.
                arrayDecoder = state.AnyValueArrayDecoder;
                isArrayRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                arrayDecoder = new AnyValueArrayDecoder();
                arrayDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 5) {
                return; // KVList and subsequent fields are skipped.
            }
            if (state.KeyValueListDecoder != null) {
                // Recursion detected, use the existing decoder.
                kVListDecoder = state.KeyValueListDecoder;
                isKVListRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                kVListDecoder = new KeyValueListDecoder();
                kVListDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 6) {
                return; // Bytes and subsequent fields are skipped.
            }
            bytesDecoder = new BytesDecoder();
            bytesDecoder.init(columns.addSubColumn());
        } finally {
            state.AnyValueDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // String and subsequent fields are skipped.
        }
        stringDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Bool and subsequent fields are skipped.
        }
        boolDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Int64 and subsequent fields are skipped.
        }
        int64Decoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // Float64 and subsequent fields are skipped.
        }
        float64Decoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // Array and subsequent fields are skipped.
        }
        
        if (!isArrayRecursive) {
            arrayDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 5) {
            return; // KVList and subsequent fields are skipped.
        }
        
        if (!isKVListRecursive) {
            kVListDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 6) {
            return; // Bytes and subsequent fields are skipped.
        }
        bytesDecoder.continueDecoding();
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            return; // String and all subsequent fields are skipped.
        }
        stringDecoder.reset();
        if (fieldCount <= 1) {
            return; // Bool and all subsequent fields are skipped.
        }
        boolDecoder.reset();
        if (fieldCount <= 2) {
            return; // Int64 and all subsequent fields are skipped.
        }
        int64Decoder.reset();
        if (fieldCount <= 3) {
            return; // Float64 and all subsequent fields are skipped.
        }
        float64Decoder.reset();
        if (fieldCount <= 4) {
            return; // Array and all subsequent fields are skipped.
        }
        if (!isArrayRecursive) {
            arrayDecoder.reset();
        }
        if (fieldCount <= 5) {
            return; // KVList and all subsequent fields are skipped.
        }
        if (!isKVListRecursive) {
            kVListDecoder.reset();
        }
        if (fieldCount <= 6) {
            return; // Bytes and all subsequent fields are skipped.
        }
        bytesDecoder.reset();
    }

    // Decode decodes a value from the buffer into dst.
    public AnyValue decode(AnyValue dst) throws IOException {
        // Read type delta
        long typ = this.buf.readBits(typeBitCount);
        if (typ < 0 || typ >= AnyValue.Type.values().length) {
            throw new IOException("Invalid oneof type");
        }
        AnyValue.Type newType = AnyValue.Type.values()[(int)typ];
        if (dst.typ != newType) {
            dst.typ = newType;
            // The type changed, we need to reset the contained value so that
            // it does not contain carry-over data from a previous record that
            // was of this same type.
            dst.resetContained();
        }
        // Decode selected field
        switch (dst.typ) {
        case TypeString:
            dst.string = this.stringDecoder.decode();
            break;
        case TypeBool:
            dst.bool = this.boolDecoder.decode();
            break;
        case TypeInt64:
            dst.int64 = this.int64Decoder.decode();
            break;
        case TypeFloat64:
            dst.float64 = this.float64Decoder.decode();
            break;
        case TypeArray:
            if (dst.array == null) {
                dst.array = new AnyValueArray(dst.parentModifiedFields, dst.parentModifiedBit);
            }
            dst.array = this.arrayDecoder.decode(dst.array);
            break;
        case TypeKVList:
            if (dst.kVList == null) {
                dst.kVList = new KeyValueList(dst.parentModifiedFields, dst.parentModifiedBit);
            }
            dst.kVList = this.kVListDecoder.decode(dst.kVList);
            break;
        case TypeBytes:
            dst.bytes = this.bytesDecoder.decode();
            break;
        default:
            break;
        }
        return dst;
    }
}
