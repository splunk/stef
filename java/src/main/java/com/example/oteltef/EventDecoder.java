// Code generated by stefgen. DO NOT EDIT.
// EventDecoder implements decoding of Event
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class EventDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private Event lastVal;
    private int fieldCount;

    
    private StringDecoder nameDecoder;
    private boolean isNameRecursive = false; // Indicates Name field's type is recursive.
    private Uint64Decoder timeUnixNanoDecoder;
    private boolean isTimeUnixNanoRecursive = false; // Indicates TimeUnixNano field's type is recursive.
    private AttributesDecoder attributesDecoder;
    private boolean isAttributesRecursive = false; // Indicates Attributes field's type is recursive.
    private Uint64Decoder droppedAttributesCountDecoder;
    private boolean isDroppedAttributesCountRecursive = false; // Indicates DroppedAttributesCount field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.EventDecoder != null) {
            throw new IllegalStateException("cannot initialize EventDecoder: already initialized");
        }
        state.EventDecoder = this;

        try {
            if (state.getOverrideSchema() != null) {
                int fieldCount = state.getOverrideSchema().getFieldCount("Event");
                fieldCount = fieldCount;
            } else {
                fieldCount = 4;
            }
            column = columns.getColumn();
            
            lastVal = new Event(null, 0);
            
            if (this.fieldCount <= 0) {
                return; // Name and subsequent fields are skipped.
            }
            nameDecoder = new StringDecoder();
            nameDecoder.init(state.SpanEventName, columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // TimeUnixNano and subsequent fields are skipped.
            }
            timeUnixNanoDecoder = new Uint64Decoder();
            timeUnixNanoDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // Attributes and subsequent fields are skipped.
            }
            if (state.AttributesDecoder != null) {
                // Recursion detected, use the existing decoder.
                attributesDecoder = state.AttributesDecoder;
                isAttributesRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                attributesDecoder = new AttributesDecoder();
                attributesDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 3) {
                return; // DroppedAttributesCount and subsequent fields are skipped.
            }
            droppedAttributesCountDecoder = new Uint64Decoder();
            droppedAttributesCountDecoder.init(columns.addSubColumn());
        } finally {
            state.EventDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Name and subsequent fields are skipped.
        }
        nameDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // TimeUnixNano and subsequent fields are skipped.
        }
        timeUnixNanoDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Attributes and subsequent fields are skipped.
        }
        
        if (!isAttributesRecursive) {
            attributesDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 3) {
            return; // DroppedAttributesCount and subsequent fields are skipped.
        }
        droppedAttributesCountDecoder.continueDecoding();
    }

    public void reset() {
        nameDecoder.reset();
        timeUnixNanoDecoder.reset();
        if (!isAttributesRecursive) {
            attributesDecoder.reset();
        }
        droppedAttributesCountDecoder.reset();
    }

    public Event decode(Event dstPtr) throws IOException {
        Event val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Event.fieldModifiedName) != 0) {
            // Field is changed and is present, decode it.
            val.name = nameDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Event.fieldModifiedTimeUnixNano) != 0) {
            // Field is changed and is present, decode it.
            val.timeUnixNano = timeUnixNanoDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Event.fieldModifiedAttributes) != 0) {
            // Field is changed and is present, decode it.
            if (val.attributes == null) {
                val.attributes = new Attributes(val.modifiedFields, Event.fieldModifiedAttributes);
            }
            val.attributes = attributesDecoder.decode(val.attributes);
        }
        
        if ((val.modifiedFields.mask & Event.fieldModifiedDroppedAttributesCount) != 0) {
            // Field is changed and is present, decode it.
            val.droppedAttributesCount = droppedAttributesCountDecoder.decode();
        }
        
        
        return val;
    }
}

