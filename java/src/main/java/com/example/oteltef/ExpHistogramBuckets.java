// Code generated by stefgen. DO NOT EDIT.
// ExpHistogramBuckets Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class ExpHistogramBuckets {
    // Field values.
    
    long offset;
    Uint64Array bucketCounts;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "ExpHistogramBuckets";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedOffset = 1 << 0;
    public static final long fieldModifiedBucketCounts = 1 << 1;

    

    public ExpHistogramBuckets() {
        init(null, 0);
    }

    ExpHistogramBuckets(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        
        bucketCounts = new Uint64Array(modifiedFields, fieldModifiedBucketCounts);
    }

    
    public long getOffset() {
        return offset;
    }

    // setOffset sets the value of Offset field.
    public void setOffset(long v) {
        if (!Types.Int64Equal(this.offset, v)) {
            this.offset = v;
            this.markOffsetModified();
        }
    }

    private void markOffsetModified() {
        this.modifiedFields.markModified(fieldModifiedOffset);
    }

    // isOffsetModified returns true if the value of Offset field was modified since
    // ExpHistogramBuckets was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isOffsetModified() {
        return (this.modifiedFields.mask & fieldModifiedOffset) != 0;
    }
    
    public Uint64Array getBucketCounts() {
        return this.bucketCounts;
    }

    // isBucketCountsModified returns true if the value of BucketCounts field was modified since
    // ExpHistogramBuckets was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isBucketCountsModified() {
        return (this.modifiedFields.mask & fieldModifiedBucketCounts) != 0;
    }
    

    void markUnmodified() {
        modifiedFields.markUnmodified();
        if (this.isBucketCountsModified()) {
            this.bucketCounts.markUnmodified();
        }
    }

    void markModifiedRecursively() {
        bucketCounts.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedOffset | 
            fieldModifiedBucketCounts | 0;
    }

    void markUnmodifiedRecursively() {
        if (isBucketCountsModified()) {
            bucketCounts.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    // markDiffModified marks fields in this struct modified if they differ from
    // the corresponding fields in v.
    boolean markDiffModified(ExpHistogramBuckets v) {
        boolean modified = false;
        if (!Types.Int64Equal(offset, v.offset)) {
            markOffsetModified();
            modified = true;
        }
        
        if (bucketCounts.markDiffModified(v.bucketCounts)) {
            modifiedFields.markModified(fieldModifiedBucketCounts);
            modified = true;
        }
        
        return modified;
    }

    public ExpHistogramBuckets clone() {
        ExpHistogramBuckets cpy = new ExpHistogramBuckets();
        cpy.offset = this.offset;
        cpy.bucketCounts = this.bucketCounts.clone();
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        size += this.bucketCounts.byteSize();
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(ExpHistogramBuckets src) {
        setOffset(src.getOffset());
        bucketCounts.copyFrom(src.bucketCounts);
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(ExpHistogramBuckets val) {
        if (!Types.Int64Equal(this.offset, val.offset)) {
            return false;
        }
        if (!this.bucketCounts.equals(val.bucketCounts)) {
            return false;
        }
        return true;
    }

    public static boolean equals(ExpHistogramBuckets left, ExpHistogramBuckets right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(ExpHistogramBuckets left, ExpHistogramBuckets right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        c = Types.Int64Compare(left.offset, right.offset);
        if (c != 0) {
            return c;
        }
        
        c = Uint64Array.compare(left.bucketCounts, right.bucketCounts);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = 2;
        
        if (random.nextInt(fieldCount) == 0) {
            this.setOffset(Types.Int64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.bucketCounts.mutateRandom(random);
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((ExpHistogramBuckets)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            offset,
            bucketCounts
        );
    }

    
}
