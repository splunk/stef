// Code generated by stefgen. DO NOT EDIT.
// Span Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class Span {
    // Field values.
    
    byte[] traceID;
    byte[] spanID;
    StringValue traceState;
    byte[] parentSpanID;
    long flags;
    StringValue name;
    long kind;
    long startTimeUnixNano;
    long endTimeUnixNano;
    Attributes attributes;
    long droppedAttributesCount;
    EventArray events;
    LinkArray links;
    SpanStatus status;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "Span";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedTraceID = 1 << 0;
    public static final long fieldModifiedSpanID = 1 << 1;
    public static final long fieldModifiedTraceState = 1 << 2;
    public static final long fieldModifiedParentSpanID = 1 << 3;
    public static final long fieldModifiedFlags = 1 << 4;
    public static final long fieldModifiedName = 1 << 5;
    public static final long fieldModifiedKind = 1 << 6;
    public static final long fieldModifiedStartTimeUnixNano = 1 << 7;
    public static final long fieldModifiedEndTimeUnixNano = 1 << 8;
    public static final long fieldModifiedAttributes = 1 << 9;
    public static final long fieldModifiedDroppedAttributesCount = 1 << 10;
    public static final long fieldModifiedEvents = 1 << 11;
    public static final long fieldModifiedLinks = 1 << 12;
    public static final long fieldModifiedStatus = 1 << 13;

    

    public Span() {
        init(null, 0);
    }

    Span(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        traceID = Types.emptyBytes;
        spanID = Types.emptyBytes;
        traceState = StringValue.empty;
        parentSpanID = Types.emptyBytes;
        
        name = StringValue.empty;
        
        
        
        attributes = new Attributes(modifiedFields, fieldModifiedAttributes);
        
        events = new EventArray(modifiedFields, fieldModifiedEvents);
        links = new LinkArray(modifiedFields, fieldModifiedLinks);
        status = new SpanStatus(modifiedFields, fieldModifiedStatus);
    }

    
    public byte[] getTraceID() {
        return traceID;
    }

    // setTraceID sets the value of TraceID field.
    public void setTraceID(byte[] v) {
        if (!Types.BytesEqual(this.traceID, v)) {
            this.traceID = v;
            this.markTraceIDModified();
        }
    }

    private void markTraceIDModified() {
        this.modifiedFields.markModified(fieldModifiedTraceID);
    }

    // isTraceIDModified returns true if the value of TraceID field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isTraceIDModified() {
        return (this.modifiedFields.mask & fieldModifiedTraceID) != 0;
    }
    
    public byte[] getSpanID() {
        return spanID;
    }

    // setSpanID sets the value of SpanID field.
    public void setSpanID(byte[] v) {
        if (!Types.BytesEqual(this.spanID, v)) {
            this.spanID = v;
            this.markSpanIDModified();
        }
    }

    private void markSpanIDModified() {
        this.modifiedFields.markModified(fieldModifiedSpanID);
    }

    // isSpanIDModified returns true if the value of SpanID field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isSpanIDModified() {
        return (this.modifiedFields.mask & fieldModifiedSpanID) != 0;
    }
    
    public StringValue getTraceState() {
        return traceState;
    }

    // setTraceState sets the value of TraceState field.
    public void setTraceState(StringValue v) {
        if (!Types.StringEqual(this.traceState, v)) {
            this.traceState = v;
            this.markTraceStateModified();
        }
    }

    private void markTraceStateModified() {
        this.modifiedFields.markModified(fieldModifiedTraceState);
    }

    // isTraceStateModified returns true if the value of TraceState field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isTraceStateModified() {
        return (this.modifiedFields.mask & fieldModifiedTraceState) != 0;
    }
    
    public byte[] getParentSpanID() {
        return parentSpanID;
    }

    // setParentSpanID sets the value of ParentSpanID field.
    public void setParentSpanID(byte[] v) {
        if (!Types.BytesEqual(this.parentSpanID, v)) {
            this.parentSpanID = v;
            this.markParentSpanIDModified();
        }
    }

    private void markParentSpanIDModified() {
        this.modifiedFields.markModified(fieldModifiedParentSpanID);
    }

    // isParentSpanIDModified returns true if the value of ParentSpanID field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isParentSpanIDModified() {
        return (this.modifiedFields.mask & fieldModifiedParentSpanID) != 0;
    }
    
    public long getFlags() {
        return flags;
    }

    // setFlags sets the value of Flags field.
    public void setFlags(long v) {
        if (!Types.Uint64Equal(this.flags, v)) {
            this.flags = v;
            this.markFlagsModified();
        }
    }

    private void markFlagsModified() {
        this.modifiedFields.markModified(fieldModifiedFlags);
    }

    // isFlagsModified returns true if the value of Flags field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isFlagsModified() {
        return (this.modifiedFields.mask & fieldModifiedFlags) != 0;
    }
    
    public StringValue getName() {
        return name;
    }

    // setName sets the value of Name field.
    public void setName(StringValue v) {
        if (!Types.StringEqual(this.name, v)) {
            this.name = v;
            this.markNameModified();
        }
    }

    private void markNameModified() {
        this.modifiedFields.markModified(fieldModifiedName);
    }

    // isNameModified returns true if the value of Name field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isNameModified() {
        return (this.modifiedFields.mask & fieldModifiedName) != 0;
    }
    
    public long getKind() {
        return kind;
    }

    // setKind sets the value of Kind field.
    public void setKind(long v) {
        if (!Types.Uint64Equal(this.kind, v)) {
            this.kind = v;
            this.markKindModified();
        }
    }

    private void markKindModified() {
        this.modifiedFields.markModified(fieldModifiedKind);
    }

    // isKindModified returns true if the value of Kind field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isKindModified() {
        return (this.modifiedFields.mask & fieldModifiedKind) != 0;
    }
    
    public long getStartTimeUnixNano() {
        return startTimeUnixNano;
    }

    // setStartTimeUnixNano sets the value of StartTimeUnixNano field.
    public void setStartTimeUnixNano(long v) {
        if (!Types.Uint64Equal(this.startTimeUnixNano, v)) {
            this.startTimeUnixNano = v;
            this.markStartTimeUnixNanoModified();
        }
    }

    private void markStartTimeUnixNanoModified() {
        this.modifiedFields.markModified(fieldModifiedStartTimeUnixNano);
    }

    // isStartTimeUnixNanoModified returns true if the value of StartTimeUnixNano field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isStartTimeUnixNanoModified() {
        return (this.modifiedFields.mask & fieldModifiedStartTimeUnixNano) != 0;
    }
    
    public long getEndTimeUnixNano() {
        return endTimeUnixNano;
    }

    // setEndTimeUnixNano sets the value of EndTimeUnixNano field.
    public void setEndTimeUnixNano(long v) {
        if (!Types.Uint64Equal(this.endTimeUnixNano, v)) {
            this.endTimeUnixNano = v;
            this.markEndTimeUnixNanoModified();
        }
    }

    private void markEndTimeUnixNanoModified() {
        this.modifiedFields.markModified(fieldModifiedEndTimeUnixNano);
    }

    // isEndTimeUnixNanoModified returns true if the value of EndTimeUnixNano field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isEndTimeUnixNanoModified() {
        return (this.modifiedFields.mask & fieldModifiedEndTimeUnixNano) != 0;
    }
    
    public Attributes getAttributes() {
        return this.attributes;
    }

    private void markAttributesModified() {
        this.modifiedFields.markModified(fieldModifiedAttributes);
    }

    // isAttributesModified returns true if the value of Attributes field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isAttributesModified() {
        return (this.modifiedFields.mask & fieldModifiedAttributes) != 0;
    }
    
    public long getDroppedAttributesCount() {
        return droppedAttributesCount;
    }

    // setDroppedAttributesCount sets the value of DroppedAttributesCount field.
    public void setDroppedAttributesCount(long v) {
        if (!Types.Uint64Equal(this.droppedAttributesCount, v)) {
            this.droppedAttributesCount = v;
            this.markDroppedAttributesCountModified();
        }
    }

    private void markDroppedAttributesCountModified() {
        this.modifiedFields.markModified(fieldModifiedDroppedAttributesCount);
    }

    // isDroppedAttributesCountModified returns true if the value of DroppedAttributesCount field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isDroppedAttributesCountModified() {
        return (this.modifiedFields.mask & fieldModifiedDroppedAttributesCount) != 0;
    }
    
    public EventArray getEvents() {
        return this.events;
    }

    private void markEventsModified() {
        this.modifiedFields.markModified(fieldModifiedEvents);
    }

    // isEventsModified returns true if the value of Events field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isEventsModified() {
        return (this.modifiedFields.mask & fieldModifiedEvents) != 0;
    }
    
    public LinkArray getLinks() {
        return this.links;
    }

    private void markLinksModified() {
        this.modifiedFields.markModified(fieldModifiedLinks);
    }

    // isLinksModified returns true if the value of Links field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isLinksModified() {
        return (this.modifiedFields.mask & fieldModifiedLinks) != 0;
    }
    
    public SpanStatus getStatus() {
        return this.status;
    }

    private void markStatusModified() {
        this.modifiedFields.markModified(fieldModifiedStatus);
    }

    // isStatusModified returns true if the value of Status field was modified since
    // Span was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isStatusModified() {
        return (this.modifiedFields.mask & fieldModifiedStatus) != 0;
    }
    

    void markUnmodified() {
        modifiedFields.markUnmodified();
        if (this.isAttributesModified()) {
            this.attributes.markUnmodified();
        }
        if (this.isEventsModified()) {
            this.events.markUnmodified();
        }
        if (this.isLinksModified()) {
            this.links.markUnmodified();
        }
        if (this.isStatusModified()) {
            this.status.markUnmodified();
        }
    }

    void markModifiedRecursively() {
        attributes.markModifiedRecursively();
        events.markModifiedRecursively();
        links.markModifiedRecursively();
        status.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedTraceID | 
            fieldModifiedSpanID | 
            fieldModifiedTraceState | 
            fieldModifiedParentSpanID | 
            fieldModifiedFlags | 
            fieldModifiedName | 
            fieldModifiedKind | 
            fieldModifiedStartTimeUnixNano | 
            fieldModifiedEndTimeUnixNano | 
            fieldModifiedAttributes | 
            fieldModifiedDroppedAttributesCount | 
            fieldModifiedEvents | 
            fieldModifiedLinks | 
            fieldModifiedStatus | 0;
    }

    void markUnmodifiedRecursively() {
        if (isAttributesModified()) {
            attributes.markUnmodifiedRecursively();
        }
        if (isEventsModified()) {
            events.markUnmodifiedRecursively();
        }
        if (isLinksModified()) {
            links.markUnmodifiedRecursively();
        }
        if (isStatusModified()) {
            status.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    // markDiffModified marks fields in this struct modified if they differ from
    // the corresponding fields in v.
    boolean markDiffModified(Span v) {
        boolean modified = false;
        if (!Types.BytesEqual(traceID, v.traceID)) {
            markTraceIDModified();
            modified = true;
        }
        
        if (!Types.BytesEqual(spanID, v.spanID)) {
            markSpanIDModified();
            modified = true;
        }
        
        if (!Types.StringEqual(traceState, v.traceState)) {
            markTraceStateModified();
            modified = true;
        }
        
        if (!Types.BytesEqual(parentSpanID, v.parentSpanID)) {
            markParentSpanIDModified();
            modified = true;
        }
        
        if (!Types.Uint64Equal(flags, v.flags)) {
            markFlagsModified();
            modified = true;
        }
        
        if (!Types.StringEqual(name, v.name)) {
            markNameModified();
            modified = true;
        }
        
        if (!Types.Uint64Equal(kind, v.kind)) {
            markKindModified();
            modified = true;
        }
        
        if (!Types.Uint64Equal(startTimeUnixNano, v.startTimeUnixNano)) {
            markStartTimeUnixNanoModified();
            modified = true;
        }
        
        if (!Types.Uint64Equal(endTimeUnixNano, v.endTimeUnixNano)) {
            markEndTimeUnixNanoModified();
            modified = true;
        }
        
        if (attributes.markDiffModified(v.attributes)) {
            modifiedFields.markModified(fieldModifiedAttributes);
            modified = true;
        }
        
        if (!Types.Uint64Equal(droppedAttributesCount, v.droppedAttributesCount)) {
            markDroppedAttributesCountModified();
            modified = true;
        }
        
        if (events.markDiffModified(v.events)) {
            modifiedFields.markModified(fieldModifiedEvents);
            modified = true;
        }
        
        if (links.markDiffModified(v.links)) {
            modifiedFields.markModified(fieldModifiedLinks);
            modified = true;
        }
        
        if (status.markDiffModified(v.status)) {
            modifiedFields.markModified(fieldModifiedStatus);
            modified = true;
        }
        
        return modified;
    }

    public Span clone() {
        Span cpy = new Span();
        cpy.traceID = this.traceID;
        cpy.spanID = this.spanID;
        cpy.traceState = this.traceState;
        cpy.parentSpanID = this.parentSpanID;
        cpy.flags = this.flags;
        cpy.name = this.name;
        cpy.kind = this.kind;
        cpy.startTimeUnixNano = this.startTimeUnixNano;
        cpy.endTimeUnixNano = this.endTimeUnixNano;
        cpy.attributes = this.attributes.clone();
        cpy.droppedAttributesCount = this.droppedAttributesCount;
        cpy.events = this.events.clone();
        cpy.links = this.links.clone();
        cpy.status = this.status.clone();
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        
        
        
        
        
        
        
        
        size += this.attributes.byteSize();
        
        size += this.events.byteSize();
        size += this.links.byteSize();
        size += this.status.byteSize();
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(Span src) {
        setTraceID(src.getTraceID());
        setSpanID(src.getSpanID());
        setTraceState(src.getTraceState());
        setParentSpanID(src.getParentSpanID());
        setFlags(src.getFlags());
        setName(src.getName());
        setKind(src.getKind());
        setStartTimeUnixNano(src.getStartTimeUnixNano());
        setEndTimeUnixNano(src.getEndTimeUnixNano());
        attributes.copyFrom(src.attributes);
        setDroppedAttributesCount(src.getDroppedAttributesCount());
        events.copyFrom(src.events);
        links.copyFrom(src.links);
        status.copyFrom(src.status);
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(Span right) {
        // Compare TraceID field.
        if (!Types.BytesEqual(this.traceID, right.traceID)) {
            return false;
        }
        // Compare SpanID field.
        if (!Types.BytesEqual(this.spanID, right.spanID)) {
            return false;
        }
        // Compare TraceState field.
        if (!Types.StringEqual(this.traceState, right.traceState)) {
            return false;
        }
        // Compare ParentSpanID field.
        if (!Types.BytesEqual(this.parentSpanID, right.parentSpanID)) {
            return false;
        }
        // Compare Flags field.
        if (!Types.Uint64Equal(this.flags, right.flags)) {
            return false;
        }
        // Compare Name field.
        if (!Types.StringEqual(this.name, right.name)) {
            return false;
        }
        // Compare Kind field.
        if (!Types.Uint64Equal(this.kind, right.kind)) {
            return false;
        }
        // Compare StartTimeUnixNano field.
        if (!Types.Uint64Equal(this.startTimeUnixNano, right.startTimeUnixNano)) {
            return false;
        }
        // Compare EndTimeUnixNano field.
        if (!Types.Uint64Equal(this.endTimeUnixNano, right.endTimeUnixNano)) {
            return false;
        }
        // Compare Attributes field.
        if (!this.attributes.equals(right.attributes)) {
            return false;
        }
        // Compare DroppedAttributesCount field.
        if (!Types.Uint64Equal(this.droppedAttributesCount, right.droppedAttributesCount)) {
            return false;
        }
        // Compare Events field.
        if (!this.events.equals(right.events)) {
            return false;
        }
        // Compare Links field.
        if (!this.links.equals(right.links)) {
            return false;
        }
        // Compare Status field.
        if (!this.status.equals(right.status)) {
            return false;
        }
        return true;
    }

    public static boolean equals(Span left, Span right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(Span left, Span right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare TraceID field.
        c = Types.BytesCompare(left.traceID, right.traceID);
        if (c != 0) {
            return c;
        }
        
        // Compare SpanID field.
        c = Types.BytesCompare(left.spanID, right.spanID);
        if (c != 0) {
            return c;
        }
        
        // Compare TraceState field.
        c = Types.StringCompare(left.traceState, right.traceState);
        if (c != 0) {
            return c;
        }
        
        // Compare ParentSpanID field.
        c = Types.BytesCompare(left.parentSpanID, right.parentSpanID);
        if (c != 0) {
            return c;
        }
        
        // Compare Flags field.
        c = Types.Uint64Compare(left.flags, right.flags);
        if (c != 0) {
            return c;
        }
        
        // Compare Name field.
        c = Types.StringCompare(left.name, right.name);
        if (c != 0) {
            return c;
        }
        
        // Compare Kind field.
        c = Types.Uint64Compare(left.kind, right.kind);
        if (c != 0) {
            return c;
        }
        
        // Compare StartTimeUnixNano field.
        c = Types.Uint64Compare(left.startTimeUnixNano, right.startTimeUnixNano);
        if (c != 0) {
            return c;
        }
        
        // Compare EndTimeUnixNano field.
        c = Types.Uint64Compare(left.endTimeUnixNano, right.endTimeUnixNano);
        if (c != 0) {
            return c;
        }
        
        // Compare Attributes field.
        c = Attributes.compare(left.attributes, right.attributes);
        if (c != 0) {
            return c;
        }
        
        // Compare DroppedAttributesCount field.
        c = Types.Uint64Compare(left.droppedAttributesCount, right.droppedAttributesCount);
        if (c != 0) {
            return c;
        }
        
        // Compare Events field.
        c = EventArray.compare(left.events, right.events);
        if (c != 0) {
            return c;
        }
        
        // Compare Links field.
        c = LinkArray.compare(left.links, right.links);
        if (c != 0) {
            return c;
        }
        
        // Compare Status field.
        c = SpanStatus.compare(left.status, right.status);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(14,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.setTraceID(Types.BytesRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setSpanID(Types.BytesRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setTraceState(Types.StringRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setParentSpanID(Types.BytesRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setFlags(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setName(Types.StringRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setKind(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setStartTimeUnixNano(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setEndTimeUnixNano(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.attributes.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setDroppedAttributesCount(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.events.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.links.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.status.mutateRandom(random);
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((Span)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            traceID,
            spanID,
            traceState,
            parentSpanID,
            flags,
            name,
            kind,
            startTimeUnixNano,
            endTimeUnixNano,
            attributes,
            droppedAttributesCount,
            events,
            links,
            status
        );
    }

    
}
