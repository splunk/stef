// Code generated by stefgen. DO NOT EDIT.
package com.example.oteltef;

import net.stef.Types;

import java.util.*;
import java.util.Objects;

// AnyValueArray is a variable size array.
public class AnyValueArray {
    AnyValue[] elems = new AnyValue[0];

    // elemsLen is the number of elements contains in the elems, elemsLen<=elems.length.
    int elemsLen = 0;

    private ModifiedFields parentModifiedFields;
    private long parentModifiedBit;

    AnyValueArray() {
        init(null, 0);
    }

    AnyValueArray(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        this.parentModifiedFields = parentModifiedFields;
        this.parentModifiedBit = parentModifiedBit;
    }

    // clone() creates a deep copy of AnyValueArray
    public AnyValueArray clone() {
        AnyValueArray clone = new AnyValueArray();
        clone.copyFrom(this);
        return clone;
    }

    // byteSize returns approximate memory usage in bytes. Used to calculate
    // memory used by dictionaries.
    public int byteSize() {
        int size = 0; // calculate size of the array in bytes.
        
        for (var elem : elems) {
            size += elem.byteSize();
        }
        
        return size;
    }

    

    // Append a new element at the end of the array.
    public void append(AnyValue val) {
        ensureElems(elemsLen + 1);
        elems[elemsLen] = val;
        elemsLen++;
        markModified();
    }

    public void markModified() {
        if (parentModifiedFields != null) {
            parentModifiedFields.markModified(parentModifiedBit);
        }
    }

    public void markUnmodified() {
        if (parentModifiedFields != null) {
            parentModifiedFields.markUnmodified();
        }
    }

    public void markUnmodifiedRecursively() {
        
        for (int i=0; i<elemsLen; i++) {
            elems[i].markUnmodifiedRecursively();
        }
        
    }

    public void copyFrom(AnyValueArray src) {
        if (elemsLen != src.elemsLen) {
            ensureElems(src.elemsLen);
            markModified();
        }
        if (src.elemsLen > 0) {
            // Allocate all elements at once.
            for (int i = 0; i < src.elemsLen; i++) {
                
                elems[i] = new AnyValue(parentModifiedFields, parentModifiedBit);
                // Copy the element.
                elems[i].copyFrom(src.elems[i]);
            }
        }
    }

    // len returns the number of elements in the array.
    public int len() {
        return elemsLen;
    }

    // at returns element at index i.
    public AnyValue at(int i) {
        return elems[i];
    }

    // ensureElems ensures that elems array has at least newLen elements allocated.
    // It will grow/reallocate the array if needed.
    // elemsLen will be set to newLen.
    // This method does not initialize new elements in the array.
    void ensureElems(int newLen) {
        if (elems.length < newLen) {
            int allocLen = Math.max(newLen, elems.length * 2);
            AnyValue[] newElems = new AnyValue[allocLen];
            System.arraycopy(elems, 0, newElems, 0, elems.length);
            elems = newElems;
        }
        elemsLen = newLen;
    }

    // ensureLen ensures the length of the array is equal to newLen.
    // It will grow or shrink the array if needed, and initialize newly added elements
    // if the element type requires initialization.
    public void ensureLen(int newLen) {
        int oldLen = elemsLen;
        if (newLen==oldLen) {
            return; // No change needed.
        }

        if (newLen > oldLen) {
            ensureElems(newLen);
            markModified();
            
            // Initialize newly added elements.
            for (int i = oldLen; i < newLen; i++) {
                
                elems[i] = new AnyValue(parentModifiedFields, parentModifiedBit);
            }
            
        } else if (oldLen > newLen) {
            // Shrink it
            elemsLen = newLen;
            markModified();
        }
    }

    // equals performs deep comparison and returns true if array is equal to val.
    public boolean equals(AnyValueArray val) {
        if (elemsLen != val.elemsLen) {
            return false;
        }
        for (int i = 0; i < elemsLen; i++) {
            
            if (!elems[i].equals(val.elems[i])) {
                return false;
            }
            
        }
        return true;
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(AnyValueArray left, AnyValueArray right) {
        int c = left.elemsLen - right.elemsLen;
        if (c != 0) {
            return c;
        }
        for (int i = 0; i < left.elemsLen; i++) {
            int fc = AnyValue.compare(left.elems[i], right.elems[i]);
            if (fc < 0) {
                return -1;
            }
            if (fc > 0) {
                return 1;
            }
        }
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using
    // random parameter as a deterministic generator.
    void mutateRandom(Random random) {
        if (random.nextInt(20) == 0) {
            ensureLen(len() + 1);
        }
        if (random.nextInt(20) == 0 && len() > 0) {
            ensureLen(len() - 1);
        }
        for (int i = 0; i < elemsLen; i++) {
            if (random.nextInt(2 * elemsLen) == 0) {
                
                elems[i].mutateRandom(random);
                
            }
        }
    }
}
