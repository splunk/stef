// Code generated by stefgen. DO NOT EDIT.
// ExemplarEncoder implements encoding of Exemplar
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class ExemplarEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private Uint64Encoder timestampEncoder = new Uint64Encoder();
    private ExemplarValueEncoder valueEncoder = new ExemplarValueEncoder();
    private BytesEncoder spanIDEncoder = new BytesEncoder();
    private BytesEncoder traceIDEncoder = new BytesEncoder();
    private AttributesEncoder filteredAttributesEncoder = new AttributesEncoder();
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        state.ExemplarEncoder = this;
        this.limiter = state.getLimiter();

        if (state.getOverrideSchema() != null) {
            int fieldCount = state.getOverrideSchema().getFieldCount("Exemplar");
            this.fieldCount = fieldCount;
            this.keepFieldMask = ~((~0L) << this.fieldCount);
        } else {
            this.fieldCount = 5;
            this.keepFieldMask = ~0L;
        }

        
        if (this.fieldCount <= 0) {
            return; // Timestamp and subsequent fields are skipped.
        }
        this.timestampEncoder.init(this.limiter, columns.addSubColumn());
        if (this.fieldCount <= 1) {
            return; // Value and subsequent fields are skipped.
        }
        this.valueEncoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 2) {
            return; // SpanID and subsequent fields are skipped.
        }
        this.spanIDEncoder.init(null, this.limiter, columns.addSubColumn());
        if (this.fieldCount <= 3) {
            return; // TraceID and subsequent fields are skipped.
        }
        this.traceIDEncoder.init(null, this.limiter, columns.addSubColumn());
        if (this.fieldCount <= 4) {
            return; // FilteredAttributes and subsequent fields are skipped.
        }
        this.filteredAttributesEncoder.init(state, columns.addSubColumn());
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcedly writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        this.timestampEncoder.reset();
        this.valueEncoder.reset();
        this.spanIDEncoder.reset();
        this.traceIDEncoder.reset();
        this.filteredAttributesEncoder.reset();
    }

    // encode encodes val into buf
    public void encode(Exemplar val) throws IOException {
        int oldLen = this.buf.bitCount();

        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Exemplar.fieldModifiedTimestamp | 
                Exemplar.fieldModifiedValue | 
                Exemplar.fieldModifiedSpanID | 
                Exemplar.fieldModifiedTraceID | 
                Exemplar.fieldModifiedFilteredAttributes | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Exemplar.fieldModifiedTimestamp) != 0) {
            // Encode Timestamp
            this.timestampEncoder.encode(val.timestamp);
        }
        
        if ((fieldMask & Exemplar.fieldModifiedValue) != 0) {
            // Encode Value
            this.valueEncoder.encode(val.value);
        }
        
        if ((fieldMask & Exemplar.fieldModifiedSpanID) != 0) {
            // Encode SpanID
            this.spanIDEncoder.encode(val.spanID);
        }
        
        if ((fieldMask & Exemplar.fieldModifiedTraceID) != 0) {
            // Encode TraceID
            this.traceIDEncoder.encode(val.traceID);
        }
        
        if ((fieldMask & Exemplar.fieldModifiedFilteredAttributes) != 0) {
            // Encode FilteredAttributes
            this.filteredAttributesEncoder.encode(val.filteredAttributes);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        
        if (this.fieldCount <= 0) {
            return; // Timestamp and subsequent fields are skipped.
        }
        this.timestampEncoder.collectColumns(columnSet.at(0));
        if (this.fieldCount <= 1) {
            return; // Value and subsequent fields are skipped.
        }
        this.valueEncoder.collectColumns(columnSet.at(1));
        if (this.fieldCount <= 2) {
            return; // SpanID and subsequent fields are skipped.
        }
        this.spanIDEncoder.collectColumns(columnSet.at(2));
        if (this.fieldCount <= 3) {
            return; // TraceID and subsequent fields are skipped.
        }
        this.traceIDEncoder.collectColumns(columnSet.at(3));
        if (this.fieldCount <= 4) {
            return; // FilteredAttributes and subsequent fields are skipped.
        }
        this.filteredAttributesEncoder.collectColumns(columnSet.at(4));
    }
}

