// Code generated by stefgen. DO NOT EDIT.
// PointValueDecoder implements decoding of PointValue
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class PointValueDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private PointValue lastValPtr;
    private PointValue lastVal = new PointValue();
    private int fieldCount;
    private PointValue.Type prevType;

    // Field decoders.
    
    private Int64Decoder int64Decoder;
    private boolean isInt64Recursive = false; // Indicates Int64 field's type is recursive.
    private Float64Decoder float64Decoder;
    private boolean isFloat64Recursive = false; // Indicates Float64 field's type is recursive.
    private HistogramValueDecoder histogramDecoder;
    private boolean isHistogramRecursive = false; // Indicates Histogram field's type is recursive.
    private ExpHistogramValueDecoder expHistogramDecoder;
    private boolean isExpHistogramRecursive = false; // Indicates ExpHistogram field's type is recursive.
    private SummaryValueDecoder summaryDecoder;
    private boolean isSummaryRecursive = false; // Indicates Summary field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this decoder in the state so that we can detect recursion.
        if (state.PointValueDecoder != null) {
            throw new IllegalStateException("cannot initialize PointValueDecoder: already initialized");
        }
        state.PointValueDecoder = this;

        try {
            prevType = PointValue.Type.TypeNone;
            this.fieldCount = state.getStructFieldCounts().getPointValueFieldCount();
            this.column = columns.getColumn();
            this.lastVal.init(null, 0);
            this.lastValPtr = this.lastVal;
            Exception err = null;
            
            if (this.fieldCount <= 0) {
                return; // Int64 and subsequent fields are skipped.
            }
            int64Decoder = new Int64Decoder();
            this.int64Decoder.init(columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Float64 and subsequent fields are skipped.
            }
            float64Decoder = new Float64Decoder();
            this.float64Decoder.init(columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // Histogram and subsequent fields are skipped.
            }
            if (state.HistogramValueDecoder != null) {
                // Recursion detected, use the existing decoder.
                histogramDecoder = state.HistogramValueDecoder;
                isHistogramRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                histogramDecoder = new HistogramValueDecoder();
                histogramDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 3) {
                return; // ExpHistogram and subsequent fields are skipped.
            }
            if (state.ExpHistogramValueDecoder != null) {
                // Recursion detected, use the existing decoder.
                expHistogramDecoder = state.ExpHistogramValueDecoder;
                isExpHistogramRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                expHistogramDecoder = new ExpHistogramValueDecoder();
                expHistogramDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 4) {
                return; // Summary and subsequent fields are skipped.
            }
            if (state.SummaryValueDecoder != null) {
                // Recursion detected, use the existing decoder.
                summaryDecoder = state.SummaryValueDecoder;
                isSummaryRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                summaryDecoder = new SummaryValueDecoder();
                summaryDecoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.PointValueDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Int64 and subsequent fields are skipped.
        }
        int64Decoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Float64 and subsequent fields are skipped.
        }
        float64Decoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Histogram and subsequent fields are skipped.
        }
        
        if (!isHistogramRecursive) {
            histogramDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 3) {
            return; // ExpHistogram and subsequent fields are skipped.
        }
        
        if (!isExpHistogramRecursive) {
            expHistogramDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 4) {
            return; // Summary and subsequent fields are skipped.
        }
        
        if (!isSummaryRecursive) {
            summaryDecoder.continueDecoding();
        }
        
    }

    public void reset() {
        prevType = PointValue.Type.TypeNone;
        
        if (fieldCount <= 0) {
            return; // Int64 and all subsequent fields are skipped.
        }
        int64Decoder.reset();
        if (fieldCount <= 1) {
            return; // Float64 and all subsequent fields are skipped.
        }
        float64Decoder.reset();
        if (fieldCount <= 2) {
            return; // Histogram and all subsequent fields are skipped.
        }
        if (!isHistogramRecursive) {
            histogramDecoder.reset();
        }
        if (fieldCount <= 3) {
            return; // ExpHistogram and all subsequent fields are skipped.
        }
        if (!isExpHistogramRecursive) {
            expHistogramDecoder.reset();
        }
        if (fieldCount <= 4) {
            return; // Summary and all subsequent fields are skipped.
        }
        if (!isSummaryRecursive) {
            summaryDecoder.reset();
        }
    }

    // Decode decodes a value from the buffer into dst.
    public PointValue decode(PointValue dst) throws IOException {
        // Read type delta
        long typeDelta = this.buf.readVarintCompact();
        long typ = prevType.getValue() + typeDelta;
        if (typ < 0 || typ >= PointValue.Type.values().length) {
            throw new IOException("Invalid oneof type");
        }
        dst.typ = PointValue.Type.values()[(int)typ];
        prevType = dst.typ;
        this.lastValPtr = dst;
        // Decode selected field
        switch (dst.typ) {
        case TypeInt64:
            dst.int64 = this.int64Decoder.decode();
            break;
        case TypeFloat64:
            dst.float64 = this.float64Decoder.decode();
            break;
        case TypeHistogram:
            if (dst.histogram == null) {
                dst.histogram = new HistogramValue(dst.parentModifiedFields, dst.parentModifiedBit);
            }
            dst.histogram = this.histogramDecoder.decode(dst.histogram);
            break;
        case TypeExpHistogram:
            if (dst.expHistogram == null) {
                dst.expHistogram = new ExpHistogramValue(dst.parentModifiedFields, dst.parentModifiedBit);
            }
            dst.expHistogram = this.expHistogramDecoder.decode(dst.expHistogram);
            break;
        case TypeSummary:
            if (dst.summary == null) {
                dst.summary = new SummaryValue(dst.parentModifiedFields, dst.parentModifiedBit);
            }
            dst.summary = this.summaryDecoder.decode(dst.summary);
            break;
        default:
            break;
        }
        return dst;
    }
}
