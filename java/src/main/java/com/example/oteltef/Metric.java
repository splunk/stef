// Code generated by stefc. DO NOT EDIT.
// Metric Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class Metric {
    // Field values.
    
    StringValue name;
    StringValue description;
    StringValue unit;
    long type_;
    Attributes metadata;
    Float64Array histogramBounds;
    long aggregationTemporality;
    boolean monotonic;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "Metric";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedName = 1 << 0;
    public static final long fieldModifiedDescription = 1 << 1;
    public static final long fieldModifiedUnit = 1 << 2;
    public static final long fieldModifiedType = 1 << 3;
    public static final long fieldModifiedMetadata = 1 << 4;
    public static final long fieldModifiedHistogramBounds = 1 << 5;
    public static final long fieldModifiedAggregationTemporality = 1 << 6;
    public static final long fieldModifiedMonotonic = 1 << 7;

    

    public Metric() {
        init(null, 0);
    }

    Metric(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        name = StringValue.empty;
        description = StringValue.empty;
        unit = StringValue.empty;
        type_ = 0;
        metadata = new Attributes(modifiedFields, fieldModifiedMetadata);
        histogramBounds = new Float64Array(modifiedFields, fieldModifiedHistogramBounds);
        aggregationTemporality = 0;
        monotonic = false;
    }

    void reset() {
        
        name = StringValue.empty;
        description = StringValue.empty;
        unit = StringValue.empty;
        type_ = 0;
        if (metadata != null) {
            metadata.reset();
        }
        if (histogramBounds != null) {
            histogramBounds.reset();
        }
        aggregationTemporality = 0;
        monotonic = false;
    }

    
    public StringValue getName() {
        return name;
    }

    // setName sets the value of Name field.
    public void setName(StringValue v) {
        if (!Types.StringEqual(this.name, v)) {
            this.name = v;
            this.markNameModified();
        }
    }

    private void markNameModified() {
        this.modifiedFields.markModified(fieldModifiedName);
    }

    // isNameModified returns true if the value of Name field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isNameModified() {
        return (this.modifiedFields.mask & fieldModifiedName) != 0;
    }
    
    public StringValue getDescription() {
        return description;
    }

    // setDescription sets the value of Description field.
    public void setDescription(StringValue v) {
        if (!Types.StringEqual(this.description, v)) {
            this.description = v;
            this.markDescriptionModified();
        }
    }

    private void markDescriptionModified() {
        this.modifiedFields.markModified(fieldModifiedDescription);
    }

    // isDescriptionModified returns true if the value of Description field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isDescriptionModified() {
        return (this.modifiedFields.mask & fieldModifiedDescription) != 0;
    }
    
    public StringValue getUnit() {
        return unit;
    }

    // setUnit sets the value of Unit field.
    public void setUnit(StringValue v) {
        if (!Types.StringEqual(this.unit, v)) {
            this.unit = v;
            this.markUnitModified();
        }
    }

    private void markUnitModified() {
        this.modifiedFields.markModified(fieldModifiedUnit);
    }

    // isUnitModified returns true if the value of Unit field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isUnitModified() {
        return (this.modifiedFields.mask & fieldModifiedUnit) != 0;
    }
    
    public MetricType getType() {
        return MetricType.fromValue(type_);
    }

    // setType sets the value of Type field.
    public void setType(MetricType v) {
        if (!Types.Uint64Equal(this.type_, v.getValue())) {
            this.type_ = v.getValue();
            this.markTypeModified();
        }
    }

    private void markTypeModified() {
        this.modifiedFields.markModified(fieldModifiedType);
    }

    // isTypeModified returns true if the value of Type field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isTypeModified() {
        return (this.modifiedFields.mask & fieldModifiedType) != 0;
    }
    
    public Attributes getMetadata() {
        return this.metadata;
    }

    private void markMetadataModified() {
        this.modifiedFields.markModified(fieldModifiedMetadata);
    }

    // isMetadataModified returns true if the value of Metadata field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isMetadataModified() {
        return (this.modifiedFields.mask & fieldModifiedMetadata) != 0;
    }
    
    public Float64Array getHistogramBounds() {
        return this.histogramBounds;
    }

    private void markHistogramBoundsModified() {
        this.modifiedFields.markModified(fieldModifiedHistogramBounds);
    }

    // isHistogramBoundsModified returns true if the value of HistogramBounds field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isHistogramBoundsModified() {
        return (this.modifiedFields.mask & fieldModifiedHistogramBounds) != 0;
    }
    
    public AggregationTemporality getAggregationTemporality() {
        return AggregationTemporality.fromValue(aggregationTemporality);
    }

    // setAggregationTemporality sets the value of AggregationTemporality field.
    public void setAggregationTemporality(AggregationTemporality v) {
        if (!Types.Uint64Equal(this.aggregationTemporality, v.getValue())) {
            this.aggregationTemporality = v.getValue();
            this.markAggregationTemporalityModified();
        }
    }

    private void markAggregationTemporalityModified() {
        this.modifiedFields.markModified(fieldModifiedAggregationTemporality);
    }

    // isAggregationTemporalityModified returns true if the value of AggregationTemporality field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isAggregationTemporalityModified() {
        return (this.modifiedFields.mask & fieldModifiedAggregationTemporality) != 0;
    }
    
    public boolean getMonotonic() {
        return monotonic;
    }

    // setMonotonic sets the value of Monotonic field.
    public void setMonotonic(boolean v) {
        if (!Types.BoolEqual(this.monotonic, v)) {
            this.monotonic = v;
            this.markMonotonicModified();
        }
    }

    private void markMonotonicModified() {
        this.modifiedFields.markModified(fieldModifiedMonotonic);
    }

    // isMonotonicModified returns true if the value of Monotonic field was modified since
    // Metric was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isMonotonicModified() {
        return (this.modifiedFields.mask & fieldModifiedMonotonic) != 0;
    }
    

    void markModifiedRecursively() {
        metadata.markModifiedRecursively();
        histogramBounds.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedName | 
            fieldModifiedDescription | 
            fieldModifiedUnit | 
            fieldModifiedType | 
            fieldModifiedMetadata | 
            fieldModifiedHistogramBounds | 
            fieldModifiedAggregationTemporality | 
            fieldModifiedMonotonic | 0;
    }

    void markUnmodifiedRecursively() {
        if (isMetadataModified()) {
            metadata.markUnmodifiedRecursively();
        }
        if (isHistogramBoundsModified()) {
            histogramBounds.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    public Metric clone() {
        Metric cpy = new Metric();
        cpy.name = this.name;
        cpy.description = this.description;
        cpy.unit = this.unit;
        cpy.type_ = this.type_;
        cpy.metadata = this.metadata.clone();
        cpy.histogramBounds = this.histogramBounds.clone();
        cpy.aggregationTemporality = this.aggregationTemporality;
        cpy.monotonic = this.monotonic;
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        
        
        
        size += this.metadata.byteSize();
        size += this.histogramBounds.byteSize();
        
        
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(Metric src) {
        setName(src.getName());
        setDescription(src.getDescription());
        setUnit(src.getUnit());
        setType(src.getType());
        metadata.copyFrom(src.metadata);
        histogramBounds.copyFrom(src.histogramBounds);
        setAggregationTemporality(src.getAggregationTemporality());
        setMonotonic(src.getMonotonic());
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(Metric right) {
        // Compare Name field.
        if (!Types.StringEqual(this.name, right.name)) {
            return false;
        }
        // Compare Description field.
        if (!Types.StringEqual(this.description, right.description)) {
            return false;
        }
        // Compare Unit field.
        if (!Types.StringEqual(this.unit, right.unit)) {
            return false;
        }
        // Compare Type field.
        if (!Types.Uint64Equal(this.type_, right.type_)) {
            return false;
        }
        // Compare Metadata field.
        if (!this.metadata.equals(right.metadata)) {
            return false;
        }
        // Compare HistogramBounds field.
        if (!this.histogramBounds.equals(right.histogramBounds)) {
            return false;
        }
        // Compare AggregationTemporality field.
        if (!Types.Uint64Equal(this.aggregationTemporality, right.aggregationTemporality)) {
            return false;
        }
        // Compare Monotonic field.
        if (!Types.BoolEqual(this.monotonic, right.monotonic)) {
            return false;
        }
        return true;
    }

    public static boolean equals(Metric left, Metric right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(Metric left, Metric right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare Name field.
        c = Types.StringCompare(left.name, right.name);
        if (c != 0) {
            return c;
        }
        
        // Compare Description field.
        c = Types.StringCompare(left.description, right.description);
        if (c != 0) {
            return c;
        }
        
        // Compare Unit field.
        c = Types.StringCompare(left.unit, right.unit);
        if (c != 0) {
            return c;
        }
        
        // Compare Type field.
        c = Types.Uint64Compare(left.type_, right.type_);
        if (c != 0) {
            return c;
        }
        
        // Compare Metadata field.
        c = Attributes.compare(left.metadata, right.metadata);
        if (c != 0) {
            return c;
        }
        
        // Compare HistogramBounds field.
        c = Float64Array.compare(left.histogramBounds, right.histogramBounds);
        if (c != 0) {
            return c;
        }
        
        // Compare AggregationTemporality field.
        c = Types.Uint64Compare(left.aggregationTemporality, right.aggregationTemporality);
        if (c != 0) {
            return c;
        }
        
        // Compare Monotonic field.
        c = Types.BoolCompare(left.monotonic, right.monotonic);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(8,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.setName(Types.StringRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setDescription(Types.StringRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setUnit(Types.StringRandom(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setType(MetricType.fromValue((Types.Uint64Random(random) & 0x7FFFFFFFFFFFFFFFL) % 5));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.metadata.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.histogramBounds.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setAggregationTemporality(AggregationTemporality.fromValue((Types.Uint64Random(random) & 0x7FFFFFFFFFFFFFFFL) % 3));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setMonotonic(Types.BoolRandom(random));
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((Metric)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            name,
            description,
            unit,
            type_,
            metadata,
            histogramBounds,
            aggregationTemporality,
            monotonic
        );
    }

    
}
