// Code generated by stefc. DO NOT EDIT.
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;

import java.util.*;
import java.util.Objects;

import static java.lang.Math.min;

// Attributes is a multimap, (aka an associative array or a list) of key value
// pairs from StringValue to AnyValue.
public class Attributes {
    // The key-value pair, element of the map.
    public static class Elem {
        StringValue key;
        AnyValue value;
    }

    // The list of map elements.
    // elems may be allocated more capacity than the map currently needs,
    // i.e. ony the first elemsLen elements are considered present.
    Elem[] elems = new Elem[0];

    // elemsLen is the number of elements contains in the elems, elemsLen<=elems.length.
    int elemsLen = 0;

    // The number of elements in elems that are inited, initedCount>=elemsLen.
    // initedCount may be higher than elemensLen if the map has shrunk from
    // a previous larger size.
    private int initedCount = 0;

    ModifiedFieldsMultimap modifiedElems = new ModifiedFieldsMultimap();

    public Attributes() {
        init(null, 0);
    }

    Attributes(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedElems.init(parentModifiedFields, parentModifiedBit);
    }

    // reset the multimap to its initial state, as if init() was just called.
    // Will not reset internal fields such as parentModifiedFields.
    void reset() {
        elemsLen = 0;
    }

    // clone() creates a deep copy of Attributes
    public Attributes clone() {
        Attributes clone = new Attributes();
        copyAttributes(clone, this);
        return clone;
    }

    // len returns the number of elements in the multimap.
    public int len() {
        return elemsLen;
    }

    // at returns element at index i.
    public Elem at(int i) {
        return elems[i];
    }

    // ensureElems ensures that elems array has at least newLen elements allocated.
    // It will grow/reallocate the array if needed.
    // elemsLen will be set to newLen.
    // This method does not call init() on new elements in the array.
    void ensureElems(int newLen) {
        if (elems.length < newLen) {
            int allocLen = Math.max(newLen, elems.length * 2);
            Elem[] newElems = new Elem[allocLen];
            System.arraycopy(elems, 0, newElems, 0, elems.length);
            elems = newElems;
        }
        elemsLen = newLen;
    }

    // ensureLen ensures the length of the array is equal to newLen.
    // It will grow or shrink the array if needed, and initialize newly added elements
    // if the element type requires initialization.
    // If the arrays grows, the newly added elements will be initialized to the
    // initial values of key and value.
    public void ensureLen(int newLen) {
        int oldLen = elemsLen;
        if (newLen == oldLen) {
            return; // No change needed.
        }

        modifiedElems.changeLen(oldLen, newLen);

        ensureElems(newLen);
        for (int i=initedCount; i < newLen; i++) {
            elems[i] = new Elem();
            elems[i].key = StringValue.empty;
            elems[i].value = new AnyValue(modifiedElems.vals, modifiedElems.maskForIndex(i));
        }
        if (initedCount < newLen) {
            initedCount = newLen;
        }

        for (int i=min(oldLen, newLen); i < newLen; i++) {
            // Reset newly added values keys to initial state.
            elems[i].value.reset();
        }
    }

    void markModifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            elems[i].value.markModifiedRecursively();
        }
        modifiedElems.markUnmodifiedAll();
    }

    void markUnmodifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            elems[i].value.markUnmodifiedRecursively();
        }
    }

    // Append adds a key-value pair to the multimap.
    public void append(StringValue k, AnyValue v) {
        modifiedElems.changeLen(elemsLen, elemsLen+1);
        ensureElems(elemsLen + 1);
        Elem elem = new Elem();
        elem.key = k;
        elem.value = v;
        elems[elemsLen-1] = elem;
    }

    // setKey sets the key of the element at index i.
    public void setKey(int i, StringValue k) {
        if (!Types.StringEqual(elems[i].key, k)) {
            elems[i].key = k;
            modifiedElems.markKeyModified(i);
        }
    }

    // setValue sets the value of the element at index i.
    public void setValue(int i, AnyValue v) {
        if (!elems[i].value.equals(v)) {
            elems[i].value = v;
            modifiedElems.markValModified(i);
        }
    }

    // byteSize returns approximate memory usage in bytes. Used to calculate
    // memory used by dictionaries.
    public int byteSize() {
        int size = 0;
        size += this.elemsLen * 16; // TODO: estimate size of Elem objects
        return size;
    }

    // Copy all elements from src to this multimap.
    public void copyFrom(Attributes src) {
        if (elemsLen!=src.elemsLen) {
            ensureLen(src.elemsLen);
        }
        for (int i=0; i < src.elemsLen; i++) {
            if (!Types.StringEqual(elems[i].key, src.elems[i].key)) {
                elems[i].key = src.elems[i].key;
                modifiedElems.markKeyModified(i);
            }
        
            if (!elems[i].value.equals(src.elems[i].value)) {
                elems[i].value.copyFrom(src.elems[i].value);
                modifiedElems.markValModified(i);
            }
        }
    }

    // areKeysModified returns true if any key in the multimap was modified
    // since the modified flags were last cleared.
    boolean areKeysModified() {
    	return modifiedElems.areKeysModified();
    }

    // equals performs deep comparison and returns true if this multimap is equal to val.
    public boolean equals(Attributes val) {
        if (elemsLen != val.elemsLen) {
            return false;
        }
        for (int i = 0; i<elemsLen; i++) {
            if (!Types.StringEqual(elems[i].key,val.elems[i].key)) {
                return false;
            }
            if (!elems[i].value.equals(val.elems[i].value)) {
                return false;
            }
        }
        return true;
    }

    // compare compares two multimaps lexicographically.
    public static int compare(Attributes left, Attributes right) {
        int l = Math.min(left.elemsLen, right.elemsLen);
        for (int i = 0; i < l; i++) {
            int c = Types.StringCompare(left.elems[i].key, right.elems[i].key);
            if (c != 0) return c;
        }
    
        int lenDiff = left.elemsLen - right.elemsLen;
        if (lenDiff != 0) {
            return lenDiff;
        }
    
        for (int i = 0; i < l; i++) {
            int c = AnyValue.compare(left.elems[i].value, right.elems[i].value);
            if (c != 0) return c;
        }
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random parameter as a deterministic generator.
    void mutateRandom(Random random) {
        if (random.nextInt(20) == 0) {
            ensureLen(elemsLen + 1);
        }
        if (random.nextInt(20) == 0 && elemsLen > 0) {
            ensureLen(elemsLen - 1);
        }
        for (int i = 0; i < elemsLen; i++) {
            if (random.nextInt(4 * elemsLen) == 0) {
                setKey(i, Types.StringRandom(random));
            }
            if (random.nextInt(4 * elemsLen) == 0) {
                elems[i].value.mutateRandom(random);
            }
        }
    }

    // Helper for copying multimaps
    public static void copyAttributes(Attributes dst, Attributes src) {
        dst.copyFrom(src);
    }
}
