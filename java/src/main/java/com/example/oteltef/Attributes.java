// Code generated by stefgen. DO NOT EDIT.
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;

import java.util.*;
import java.util.Objects;

// Attributes is a multimap, (aka an associative array or a list) of key value
// pairs from StringValue to AnyValue.
public class Attributes {
    // The key-value pair, element of the map.
    public static class Elem {
        StringValue key;
        AnyValue value;
    }

    // The list of map elements.
    // elems may be allocated more capacity than the map currently needs,
    // i.e. ony the first elemsLen elements are considered present.
    Elem[] elems = new Elem[0];

    // elemsLen is the number of elements contains in the elems, elemsLen<=elems.length.
    int elemsLen = 0;

    // The number of elements in elems that are inited, initedCount>=elemsLen.
    // initedCount may be higher than elemensLen if the map has shrunk from
    // a previous larger size.
    private int initedCount = 0;

    // Reference to parent struct's modifiedFields and the bit to set
    // if needed to indicate this field is modified.
    private ModifiedFields parentModifiedFields;
    private long parentModifiedBit;

    public Attributes() {
        init(null, 0);
    }

    Attributes(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        this.parentModifiedFields = parentModifiedFields;
        this.parentModifiedBit = parentModifiedBit;
    }

    // clone() creates a deep copy of Attributes
    public Attributes clone() {
        Attributes clone = new Attributes();
        copyAttributes(clone, this);
        return clone;
    }

    // len returns the number of elements in the multimap.
    public int len() {
        return elemsLen;
    }

    // at returns element at index i.
    public Elem at(int i) {
        return elems[i];
    }

    // ensureElems ensures that elems array has at least newLen elements allocated.
    // It will grow/reallocate the array if needed.
    // elemsLen will be set to newLen.
    // This method does not call init() on new elements in the array.
    void ensureElems(int newLen) {
        if (elems.length < newLen) {
            int allocLen = Math.max(newLen, elems.length * 2);
            Elem[] newElems = new Elem[allocLen];
            System.arraycopy(elems, 0, newElems, 0, elems.length);
            elems = newElems;
        }
        elemsLen = newLen;
    }

    // ensureLen ensures the length of the array is equal to newLen.
    // It will grow or shrink the array if needed, and initialize newly added elements
    // if the element type requires initialization.
    // If the arrays grows, the newly added elements will be initialized to the
    // initial values of key and value.
    public void ensureLen(int newLen) {
        int oldLen = elemsLen;
        if (newLen==oldLen) {
            return; // No change needed.
        }

        ensureElems(newLen);
        for (int i=initedCount; i < newLen; i++) {
            elems[i] = new Elem();
            elems[i].key = StringValue.empty;
            elems[i].value = new AnyValue(parentModifiedFields, parentModifiedBit);
        }
        if (initedCount < newLen) {
            initedCount = newLen;
        }
        markModified();
    }

    private void markModified() {
        if (parentModifiedFields != null) {
            parentModifiedFields.markModified(parentModifiedBit);
        }
    }

    void markUnmodified() {
        if (parentModifiedFields != null) {
            parentModifiedFields.markUnmodified();
        }
    }

    void markModifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            elems[i].value.markModifiedRecursively();
        }
    }

    void markUnmodifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            elems[i].value.markUnmodifiedRecursively();
        }
    }

    // markDiffModified marks fields in each key and value of this multimap modified if they
    // differ from the corresponding fields in v.
    boolean markDiffModified(Attributes v) {
        boolean modified = false;

        if (elemsLen != v.elemsLen) {
            // Array lengths are different, so they are definitely different.
            modified = true;
        }
        
        // Scan the elements and mark them as modified if they are different.
        int minLen = Math.min(elemsLen, v.elemsLen);
        for (int i=0; i < minLen; i++) {
            if (!Types.StringEqual(elems[i].key, v.elems[i].key)) {
                modified = true;
            }
            if (elems[i].value.markDiffModified(v.elems[i].value)) {
                modified = true;
            }
        }
        
        // Mark the rest of the elements as modified.
        for (int i=minLen; i<elemsLen; i++) {
            elems[i].value.markModifiedRecursively();
        }
        
        
        if (modified) {
            markModified();
        }
        
        return modified;
    }
    
    // markDiffModified marks fields in each value of this multimap modified if they
    // differ from the corresponding fields in v.
    // This function assumes the keys are the same and the lengths of multimaps are the same.
    boolean markValueDiffModified(Attributes v) {
        boolean modified = false;
        // Scan the elements and mark them as modified if they are different.
        for (int i=0; i < elemsLen; i++) {
            if (elems[i].value.markDiffModified(v.elems[i].value)) {
                modified = true;
            }
        }
        
        if (modified) {
            markModified();
        }
        
        return modified;
    }


    // Append adds a key-value pair to the multimap.
    public void append(StringValue k, AnyValue v) {
        ensureElems(elemsLen + 1);
        Elem elem = new Elem();
        elem.key = k;
        elem.value = v;
        elems[elemsLen-1] = elem;
        markModified();
    }

    // setKey sets the key of the element at index i.
    public void setKey(int i, StringValue k) {
        if (!Types.StringEqual(elems[i].key, k)) {
            elems[i].key = k;
            markModified();
        }
    }

    // setValue sets the value of the element at index i.
    public void setValue(int i, AnyValue v) {
        if (!elems[i].value.equals(v)) {
            elems[i].value = v;
            markModified();
        }
    }

    // Sorts the multimap by key.
    public void sort() {
        Arrays.sort(elems, 0, elemsLen, new Comparator<Elem>() {
            @Override
            public int compare(Elem a, Elem b) {
                return Types.StringCompare(a.key, b.key);
            }
        });
    }

    // byteSize returns approximate memory usage in bytes. Used to calculate
    // memory used by dictionaries.
    public int byteSize() {
        int size = 0;
        size += this.elemsLen * 16; // TODO: estimate size of Elem objects
        return size;
    }

    // Copy all elements from src to this multimap.
    public void copyFrom(Attributes src) {
        boolean modified = false;
        if (elemsLen!=src.elemsLen) {
            ensureLen(src.elemsLen);
            modified = true;
        }
        for (int i=0; i < src.elemsLen; i++) {
            if (!Types.StringEqual(elems[i].key, src.elems[i].key)) {
                elems[i].key = src.elems[i].key;
                modified = true;
            }
        
            if (!elems[i].value.equals(src.elems[i].value)) {
                elems[i].value.copyFrom(src.elems[i].value);
                modified = true;
            }
        }

        if (modified) {
            markModified();
        }
    }

    // equals performs deep comparison and returns true if this multimap is equal to val.
    public boolean equals(Attributes val) {
        if (elemsLen != val.elemsLen) {
            return false;
        }
        for (int i = 0; i<elemsLen; i++) {
            if (!Types.StringEqual(elems[i].key,val.elems[i].key)) {
                return false;
            }
            if (!elems[i].value.equals(val.elems[i].value)) {
                return false;
            }
        }
        return true;
    }

    // compare compares two multimaps lexicographically.
    public static int compare(Attributes left, Attributes right) {
        int l = Math.min(left.elemsLen, right.elemsLen);
        for (int i = 0; i < l; i++) {
            int c = Types.StringCompare(left.elems[i].key, right.elems[i].key);
            if (c != 0) return c;
        }
    
        int lenDiff = left.elemsLen - right.elemsLen;
        if (lenDiff != 0) {
            return lenDiff;
        }
    
        for (int i = 0; i < l; i++) {
            int c = AnyValue.compare(left.elems[i].value, right.elems[i].value);
            if (c != 0) return c;
        }
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random parameter as a deterministic generator.
    void mutateRandom(Random random) {
        if (random.nextInt(20) == 0) {
            ensureLen(elemsLen + 1);
        }
        if (random.nextInt(20) == 0 && elemsLen > 0) {
            ensureLen(elemsLen - 1);
        }
        for (int i = 0; i < elemsLen; i++) {
            if (random.nextInt(4 * elemsLen) == 0) {
                setKey(i, Types.StringRandom(random));
            }
            if (random.nextInt(4 * elemsLen) == 0) {
                elems[i].value.mutateRandom(random);
            }
        }
    }

    // Helper for copying multimaps
    public static void copyAttributes(Attributes dst, Attributes src) {
        dst.ensureLen(src.elemsLen);
        for (int i = 0; i < src.elemsLen; i++) {
            dst.elems[i].key = src.elems[i].key;
            dst.elems[i].value = src.elems[i].value;
        }
        dst.markModified();
    }

    boolean isSameKeys(Attributes val2) {
        if (elemsLen != val2.elemsLen) {
            return false;
        }

        for (int i=0; i<elemsLen; i++) {
            if (elems[i].key != val2.elems[i].key) {
                return false;
            }
        }

        return true;
    }
}
