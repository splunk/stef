// Code generated by stefc. DO NOT EDIT.
// ExpHistogramValueEncoder implements encoding of ExpHistogramValue
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class ExpHistogramValueEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private Uint64DeltaDeltaEncoder countEncoder;
    private boolean isCountRecursive = false; // Indicates Count field's type is recursive.
    private Float64Encoder sumEncoder;
    private boolean isSumRecursive = false; // Indicates Sum field's type is recursive.
    private Float64Encoder minEncoder;
    private boolean isMinRecursive = false; // Indicates Min field's type is recursive.
    private Float64Encoder maxEncoder;
    private boolean isMaxRecursive = false; // Indicates Max field's type is recursive.
    private Int64DeltaEncoder scaleEncoder;
    private boolean isScaleRecursive = false; // Indicates Scale field's type is recursive.
    private Uint64DeltaDeltaEncoder zeroCountEncoder;
    private boolean isZeroCountRecursive = false; // Indicates ZeroCount field's type is recursive.
    private ExpHistogramBucketsEncoder positiveBucketsEncoder;
    private boolean isPositiveBucketsRecursive = false; // Indicates PositiveBuckets field's type is recursive.
    private ExpHistogramBucketsEncoder negativeBucketsEncoder;
    private boolean isNegativeBucketsRecursive = false; // Indicates NegativeBuckets field's type is recursive.
    private Float64Encoder zeroThresholdEncoder;
    private boolean isZeroThresholdRecursive = false; // Indicates ZeroThreshold field's type is recursive.
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.ExpHistogramValueEncoder != null) {
            throw new IllegalStateException("cannot initialize ExpHistogramValueEncoder: already initialized");
        }
        state.ExpHistogramValueEncoder = this;

        try {
            this.limiter = state.getLimiter();

            this.fieldCount = state.getStructFieldCounts().getExpHistogramValueFieldCount();
            this.keepFieldMask = ~((~0L) << this.fieldCount);
            
            // Init encoder for Count field.
            if (this.fieldCount <= 0) {
                return; // Count and subsequent fields are skipped.
            }
            countEncoder = new Uint64DeltaDeltaEncoder();
            countEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Sum field.
            if (this.fieldCount <= 1) {
                return; // Sum and subsequent fields are skipped.
            }
            sumEncoder = new Float64Encoder();
            sumEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Min field.
            if (this.fieldCount <= 2) {
                return; // Min and subsequent fields are skipped.
            }
            minEncoder = new Float64Encoder();
            minEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Max field.
            if (this.fieldCount <= 3) {
                return; // Max and subsequent fields are skipped.
            }
            maxEncoder = new Float64Encoder();
            maxEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Scale field.
            if (this.fieldCount <= 4) {
                return; // Scale and subsequent fields are skipped.
            }
            scaleEncoder = new Int64DeltaEncoder();
            scaleEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for ZeroCount field.
            if (this.fieldCount <= 5) {
                return; // ZeroCount and subsequent fields are skipped.
            }
            zeroCountEncoder = new Uint64DeltaDeltaEncoder();
            zeroCountEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for PositiveBuckets field.
            if (this.fieldCount <= 6) {
                return; // PositiveBuckets and subsequent fields are skipped.
            }
            if (state.ExpHistogramBucketsEncoder != null) {
                // Recursion detected, use the existing encoder.
                positiveBucketsEncoder = state.ExpHistogramBucketsEncoder;
                isPositiveBucketsRecursive = true;
            } else {
                positiveBucketsEncoder = new ExpHistogramBucketsEncoder();
                positiveBucketsEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for NegativeBuckets field.
            if (this.fieldCount <= 7) {
                return; // NegativeBuckets and subsequent fields are skipped.
            }
            if (state.ExpHistogramBucketsEncoder != null) {
                // Recursion detected, use the existing encoder.
                negativeBucketsEncoder = state.ExpHistogramBucketsEncoder;
                isNegativeBucketsRecursive = true;
            } else {
                negativeBucketsEncoder = new ExpHistogramBucketsEncoder();
                negativeBucketsEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for ZeroThreshold field.
            if (this.fieldCount <= 8) {
                return; // ZeroThreshold and subsequent fields are skipped.
            }
            zeroThresholdEncoder = new Float64Encoder();
            zeroThresholdEncoder.init(limiter, columns.addSubColumn());
        } finally {
            state.ExpHistogramValueEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcefully writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        
        if (fieldCount <= 0) {
            return; // Count and all subsequent fields are skipped.
        }
        countEncoder.reset();
        if (fieldCount <= 1) {
            return; // Sum and all subsequent fields are skipped.
        }
        sumEncoder.reset();
        if (fieldCount <= 2) {
            return; // Min and all subsequent fields are skipped.
        }
        minEncoder.reset();
        if (fieldCount <= 3) {
            return; // Max and all subsequent fields are skipped.
        }
        maxEncoder.reset();
        if (fieldCount <= 4) {
            return; // Scale and all subsequent fields are skipped.
        }
        scaleEncoder.reset();
        if (fieldCount <= 5) {
            return; // ZeroCount and all subsequent fields are skipped.
        }
        zeroCountEncoder.reset();
        if (fieldCount <= 6) {
            return; // PositiveBuckets and all subsequent fields are skipped.
        }
        
        if (!isPositiveBucketsRecursive) {
            positiveBucketsEncoder.reset();
        }
        
        if (fieldCount <= 7) {
            return; // NegativeBuckets and all subsequent fields are skipped.
        }
        
        if (!isNegativeBucketsRecursive) {
            negativeBucketsEncoder.reset();
        }
        
        if (fieldCount <= 8) {
            return; // ZeroThreshold and all subsequent fields are skipped.
        }
        zeroThresholdEncoder.reset();
    }

    // encode encodes val into buf
    public void encode(ExpHistogramValue val) throws IOException {
        int oldLen = this.buf.bitCount();

        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                ExpHistogramValue.fieldModifiedCount | 
                ExpHistogramValue.fieldModifiedSum | 
                ExpHistogramValue.fieldModifiedMin | 
                ExpHistogramValue.fieldModifiedMax | 
                ExpHistogramValue.fieldModifiedScale | 
                ExpHistogramValue.fieldModifiedZeroCount | 
                ExpHistogramValue.fieldModifiedPositiveBuckets | 
                ExpHistogramValue.fieldModifiedNegativeBuckets | 
                ExpHistogramValue.fieldModifiedZeroThreshold | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Write bits to indicate which optional fields are set.
        this.buf.writeBits(val.optionalFieldsPresent, 3);
        // Encode modified, present fields.
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedCount) != 0) {
            // Encode Count
            this.countEncoder.encode(val.count);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedSum) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentSum) != 0) {
            // Encode Sum
            this.sumEncoder.encode(val.sum);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedMin) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentMin) != 0) {
            // Encode Min
            this.minEncoder.encode(val.min);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedMax) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentMax) != 0) {
            // Encode Max
            this.maxEncoder.encode(val.max);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedScale) != 0) {
            // Encode Scale
            this.scaleEncoder.encode(val.scale);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedZeroCount) != 0) {
            // Encode ZeroCount
            this.zeroCountEncoder.encode(val.zeroCount);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedPositiveBuckets) != 0) {
            // Encode PositiveBuckets
            this.positiveBucketsEncoder.encode(val.positiveBuckets);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedNegativeBuckets) != 0) {
            // Encode NegativeBuckets
            this.negativeBucketsEncoder.encode(val.negativeBuckets);
        }
        
        if ((fieldMask & ExpHistogramValue.fieldModifiedZeroThreshold) != 0) {
            // Encode ZeroThreshold
            this.zeroThresholdEncoder.encode(val.zeroThreshold);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect Count field.
        if (this.fieldCount <= 0) {
            return; // Count and subsequent fields are skipped.
        }
        
        countEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Sum field.
        if (this.fieldCount <= 1) {
            return; // Sum and subsequent fields are skipped.
        }
        
        sumEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Min field.
        if (this.fieldCount <= 2) {
            return; // Min and subsequent fields are skipped.
        }
        
        minEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Max field.
        if (this.fieldCount <= 3) {
            return; // Max and subsequent fields are skipped.
        }
        
        maxEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Scale field.
        if (this.fieldCount <= 4) {
            return; // Scale and subsequent fields are skipped.
        }
        
        scaleEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect ZeroCount field.
        if (this.fieldCount <= 5) {
            return; // ZeroCount and subsequent fields are skipped.
        }
        
        zeroCountEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect PositiveBuckets field.
        if (this.fieldCount <= 6) {
            return; // PositiveBuckets and subsequent fields are skipped.
        }
        if (!isPositiveBucketsRecursive) {
            positiveBucketsEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect NegativeBuckets field.
        if (this.fieldCount <= 7) {
            return; // NegativeBuckets and subsequent fields are skipped.
        }
        if (!isNegativeBucketsRecursive) {
            negativeBucketsEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect ZeroThreshold field.
        if (this.fieldCount <= 8) {
            return; // ZeroThreshold and subsequent fields are skipped.
        }
        
        zeroThresholdEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
    }
}

