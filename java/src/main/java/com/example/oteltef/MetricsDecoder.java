// Code generated by stefgen. DO NOT EDIT.
// MetricsDecoder implements decoding of Metrics
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class MetricsDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private int fieldCount;

    
    private EnvelopeDecoder envelopeDecoder;
    private boolean isEnvelopeRecursive = false; // Indicates Envelope field's type is recursive.
    private MetricDecoder metricDecoder;
    private boolean isMetricRecursive = false; // Indicates Metric field's type is recursive.
    private ResourceDecoder resourceDecoder;
    private boolean isResourceRecursive = false; // Indicates Resource field's type is recursive.
    private ScopeDecoder scopeDecoder;
    private boolean isScopeRecursive = false; // Indicates Scope field's type is recursive.
    private AttributesDecoder attributesDecoder;
    private boolean isAttributesRecursive = false; // Indicates Attributes field's type is recursive.
    private PointDecoder pointDecoder;
    private boolean isPointRecursive = false; // Indicates Point field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.MetricsDecoder != null) {
            throw new IllegalStateException("cannot initialize MetricsDecoder: already initialized");
        }
        state.MetricsDecoder = this;

        try {
            fieldCount = state.getStructFieldCounts().getMetricsFieldCount();

            column = columns.getColumn();
            
            if (this.fieldCount <= 0) {
                return; // Envelope and subsequent fields are skipped.
            }
            if (state.EnvelopeDecoder != null) {
                // Recursion detected, use the existing decoder.
                envelopeDecoder = state.EnvelopeDecoder;
                isEnvelopeRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                envelopeDecoder = new EnvelopeDecoder();
                envelopeDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 1) {
                return; // Metric and subsequent fields are skipped.
            }
            if (state.MetricDecoder != null) {
                // Recursion detected, use the existing decoder.
                metricDecoder = state.MetricDecoder;
                isMetricRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                metricDecoder = new MetricDecoder();
                metricDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 2) {
                return; // Resource and subsequent fields are skipped.
            }
            if (state.ResourceDecoder != null) {
                // Recursion detected, use the existing decoder.
                resourceDecoder = state.ResourceDecoder;
                isResourceRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                resourceDecoder = new ResourceDecoder();
                resourceDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 3) {
                return; // Scope and subsequent fields are skipped.
            }
            if (state.ScopeDecoder != null) {
                // Recursion detected, use the existing decoder.
                scopeDecoder = state.ScopeDecoder;
                isScopeRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                scopeDecoder = new ScopeDecoder();
                scopeDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 4) {
                return; // Attributes and subsequent fields are skipped.
            }
            if (state.AttributesDecoder != null) {
                // Recursion detected, use the existing decoder.
                attributesDecoder = state.AttributesDecoder;
                isAttributesRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                attributesDecoder = new AttributesDecoder();
                attributesDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 5) {
                return; // Point and subsequent fields are skipped.
            }
            if (state.PointDecoder != null) {
                // Recursion detected, use the existing decoder.
                pointDecoder = state.PointDecoder;
                isPointRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                pointDecoder = new PointDecoder();
                pointDecoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.MetricsDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Envelope and subsequent fields are skipped.
        }
        
        if (!isEnvelopeRecursive) {
            envelopeDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 1) {
            return; // Metric and subsequent fields are skipped.
        }
        
        if (!isMetricRecursive) {
            metricDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 2) {
            return; // Resource and subsequent fields are skipped.
        }
        
        if (!isResourceRecursive) {
            resourceDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 3) {
            return; // Scope and subsequent fields are skipped.
        }
        
        if (!isScopeRecursive) {
            scopeDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 4) {
            return; // Attributes and subsequent fields are skipped.
        }
        
        if (!isAttributesRecursive) {
            attributesDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 5) {
            return; // Point and subsequent fields are skipped.
        }
        
        if (!isPointRecursive) {
            pointDecoder.continueDecoding();
        }
        
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            // Envelope and all subsequent fields are skipped.
            return;
        }
        if (!isEnvelopeRecursive) {
            envelopeDecoder.reset();
        }
        if (fieldCount <= 1) {
            // Metric and all subsequent fields are skipped.
            return;
        }
        if (!isMetricRecursive) {
            metricDecoder.reset();
        }
        if (fieldCount <= 2) {
            // Resource and all subsequent fields are skipped.
            return;
        }
        if (!isResourceRecursive) {
            resourceDecoder.reset();
        }
        if (fieldCount <= 3) {
            // Scope and all subsequent fields are skipped.
            return;
        }
        if (!isScopeRecursive) {
            scopeDecoder.reset();
        }
        if (fieldCount <= 4) {
            // Attributes and all subsequent fields are skipped.
            return;
        }
        if (!isAttributesRecursive) {
            attributesDecoder.reset();
        }
        if (fieldCount <= 5) {
            // Point and all subsequent fields are skipped.
            return;
        }
        if (!isPointRecursive) {
            pointDecoder.reset();
        }
    }

    public Metrics decode(Metrics dstPtr) throws IOException {
        Metrics val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedEnvelope) != 0) {
            // Field is changed and is present, decode it.
            if (val.envelope == null) {
                val.envelope = new Envelope(val.modifiedFields, Metrics.fieldModifiedEnvelope);
            }
            val.envelope = envelopeDecoder.decode(val.envelope);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedMetric) != 0) {
            // Field is changed and is present, decode it.
            if (val.metric == null) {
                val.metric = new Metric(val.modifiedFields, Metrics.fieldModifiedMetric);
            }
            val.metric = metricDecoder.decode(val.metric);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedResource) != 0) {
            // Field is changed and is present, decode it.
            if (val.resource == null) {
                val.resource = new Resource(val.modifiedFields, Metrics.fieldModifiedResource);
            }
            val.resource = resourceDecoder.decode(val.resource);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedScope) != 0) {
            // Field is changed and is present, decode it.
            if (val.scope == null) {
                val.scope = new Scope(val.modifiedFields, Metrics.fieldModifiedScope);
            }
            val.scope = scopeDecoder.decode(val.scope);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedAttributes) != 0) {
            // Field is changed and is present, decode it.
            if (val.attributes == null) {
                val.attributes = new Attributes(val.modifiedFields, Metrics.fieldModifiedAttributes);
            }
            val.attributes = attributesDecoder.decode(val.attributes);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedPoint) != 0) {
            // Field is changed and is present, decode it.
            if (val.point == null) {
                val.point = new Point(val.modifiedFields, Metrics.fieldModifiedPoint);
            }
            val.point = pointDecoder.decode(val.point);
        }
        
        
        return val;
    }
}

