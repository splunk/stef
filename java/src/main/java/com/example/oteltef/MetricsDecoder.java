// Code generated by stefgen. DO NOT EDIT.
// MetricsDecoder implements decoding of Metrics
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class MetricsDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private Metrics lastVal;
    private int fieldCount;

    
    private EnvelopeDecoder envelopeDecoder = new EnvelopeDecoder();
    private MetricDecoder metricDecoder = new MetricDecoder();
    private ResourceDecoder resourceDecoder = new ResourceDecoder();
    private ScopeDecoder scopeDecoder = new ScopeDecoder();
    private AttributesDecoder attributesDecoder = new AttributesDecoder();
    private PointDecoder pointDecoder = new PointDecoder();
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        state.MetricsDecoder = this;
        if (state.getOverrideSchema() != null) {
            int fieldCount = state.getOverrideSchema().getFieldCount("Metrics");
            fieldCount = fieldCount;
        } else {
            fieldCount = 6;
        }
        column = columns.getColumn();
        
        lastVal = new Metrics();
        
        if (this.fieldCount <= 0) {
            return; // Envelope and subsequent fields are skipped.
        }
        envelopeDecoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 1) {
            return; // Metric and subsequent fields are skipped.
        }
        metricDecoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 2) {
            return; // Resource and subsequent fields are skipped.
        }
        resourceDecoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 3) {
            return; // Scope and subsequent fields are skipped.
        }
        scopeDecoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 4) {
            return; // Attributes and subsequent fields are skipped.
        }
        attributesDecoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 5) {
            return; // Point and subsequent fields are skipped.
        }
        pointDecoder.init(state, columns.addSubColumn());
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Envelope and subsequent fields are skipped.
        }
        this.envelopeDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Metric and subsequent fields are skipped.
        }
        this.metricDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Resource and subsequent fields are skipped.
        }
        this.resourceDecoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // Scope and subsequent fields are skipped.
        }
        this.scopeDecoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // Attributes and subsequent fields are skipped.
        }
        this.attributesDecoder.continueDecoding();
        if (this.fieldCount <= 5) {
            return; // Point and subsequent fields are skipped.
        }
        this.pointDecoder.continueDecoding();
    }

    public void reset() {
        this.envelopeDecoder.reset();
        this.metricDecoder.reset();
        this.resourceDecoder.reset();
        this.scopeDecoder.reset();
        this.attributesDecoder.reset();
        this.pointDecoder.reset();
    }

    public Metrics decode(Metrics dstPtr) throws IOException {
        Metrics val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedEnvelope) != 0) {
            // Field is changed and is present, decode it.
            val.envelope = envelopeDecoder.decode(val.envelope);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedMetric) != 0) {
            // Field is changed and is present, decode it.
            val.metric = metricDecoder.decode(val.metric);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedResource) != 0) {
            // Field is changed and is present, decode it.
            val.resource = resourceDecoder.decode(val.resource);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedScope) != 0) {
            // Field is changed and is present, decode it.
            val.scope = scopeDecoder.decode(val.scope);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedAttributes) != 0) {
            // Field is changed and is present, decode it.
            val.attributes = attributesDecoder.decode(val.attributes);
        }
        
        if ((val.modifiedFields.mask & Metrics.fieldModifiedPoint) != 0) {
            // Field is changed and is present, decode it.
            val.point = pointDecoder.decode(val.point);
        }
        
        
        return val;
    }
}

