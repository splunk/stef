// Code generated by stefgen. DO NOT EDIT.
// ExpHistogramValueDecoder implements decoding of ExpHistogramValue
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class ExpHistogramValueDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private int fieldCount;

    
    private Uint64Decoder countDecoder;
    private boolean isCountRecursive = false; // Indicates Count field's type is recursive.
    private Float64Decoder sumDecoder;
    private boolean isSumRecursive = false; // Indicates Sum field's type is recursive.
    private Float64Decoder minDecoder;
    private boolean isMinRecursive = false; // Indicates Min field's type is recursive.
    private Float64Decoder maxDecoder;
    private boolean isMaxRecursive = false; // Indicates Max field's type is recursive.
    private Int64Decoder scaleDecoder;
    private boolean isScaleRecursive = false; // Indicates Scale field's type is recursive.
    private Uint64Decoder zeroCountDecoder;
    private boolean isZeroCountRecursive = false; // Indicates ZeroCount field's type is recursive.
    private ExpHistogramBucketsDecoder positiveBucketsDecoder;
    private boolean isPositiveBucketsRecursive = false; // Indicates PositiveBuckets field's type is recursive.
    private ExpHistogramBucketsDecoder negativeBucketsDecoder;
    private boolean isNegativeBucketsRecursive = false; // Indicates NegativeBuckets field's type is recursive.
    private Float64Decoder zeroThresholdDecoder;
    private boolean isZeroThresholdRecursive = false; // Indicates ZeroThreshold field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.ExpHistogramValueDecoder != null) {
            throw new IllegalStateException("cannot initialize ExpHistogramValueDecoder: already initialized");
        }
        state.ExpHistogramValueDecoder = this;

        try {
            fieldCount = state.getStructFieldCounts().getExpHistogramValueFieldCount();

            column = columns.getColumn();
            
            if (this.fieldCount <= 0) {
                return; // Count and subsequent fields are skipped.
            }
            countDecoder = new Uint64Decoder();
            countDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Sum and subsequent fields are skipped.
            }
            sumDecoder = new Float64Decoder();
            sumDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // Min and subsequent fields are skipped.
            }
            minDecoder = new Float64Decoder();
            minDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // Max and subsequent fields are skipped.
            }
            maxDecoder = new Float64Decoder();
            maxDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // Scale and subsequent fields are skipped.
            }
            scaleDecoder = new Int64Decoder();
            scaleDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 5) {
                return; // ZeroCount and subsequent fields are skipped.
            }
            zeroCountDecoder = new Uint64Decoder();
            zeroCountDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 6) {
                return; // PositiveBuckets and subsequent fields are skipped.
            }
            if (state.ExpHistogramBucketsDecoder != null) {
                // Recursion detected, use the existing decoder.
                positiveBucketsDecoder = state.ExpHistogramBucketsDecoder;
                isPositiveBucketsRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                positiveBucketsDecoder = new ExpHistogramBucketsDecoder();
                positiveBucketsDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 7) {
                return; // NegativeBuckets and subsequent fields are skipped.
            }
            if (state.ExpHistogramBucketsDecoder != null) {
                // Recursion detected, use the existing decoder.
                negativeBucketsDecoder = state.ExpHistogramBucketsDecoder;
                isNegativeBucketsRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                negativeBucketsDecoder = new ExpHistogramBucketsDecoder();
                negativeBucketsDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 8) {
                return; // ZeroThreshold and subsequent fields are skipped.
            }
            zeroThresholdDecoder = new Float64Decoder();
            zeroThresholdDecoder.init(columns.addSubColumn());
        } finally {
            state.ExpHistogramValueDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Count and subsequent fields are skipped.
        }
        countDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Sum and subsequent fields are skipped.
        }
        sumDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Min and subsequent fields are skipped.
        }
        minDecoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // Max and subsequent fields are skipped.
        }
        maxDecoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // Scale and subsequent fields are skipped.
        }
        scaleDecoder.continueDecoding();
        if (this.fieldCount <= 5) {
            return; // ZeroCount and subsequent fields are skipped.
        }
        zeroCountDecoder.continueDecoding();
        if (this.fieldCount <= 6) {
            return; // PositiveBuckets and subsequent fields are skipped.
        }
        
        if (!isPositiveBucketsRecursive) {
            positiveBucketsDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 7) {
            return; // NegativeBuckets and subsequent fields are skipped.
        }
        
        if (!isNegativeBucketsRecursive) {
            negativeBucketsDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 8) {
            return; // ZeroThreshold and subsequent fields are skipped.
        }
        zeroThresholdDecoder.continueDecoding();
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            // Count and all subsequent fields are skipped.
            return;
        }
        countDecoder.reset();
        if (fieldCount <= 1) {
            // Sum and all subsequent fields are skipped.
            return;
        }
        sumDecoder.reset();
        if (fieldCount <= 2) {
            // Min and all subsequent fields are skipped.
            return;
        }
        minDecoder.reset();
        if (fieldCount <= 3) {
            // Max and all subsequent fields are skipped.
            return;
        }
        maxDecoder.reset();
        if (fieldCount <= 4) {
            // Scale and all subsequent fields are skipped.
            return;
        }
        scaleDecoder.reset();
        if (fieldCount <= 5) {
            // ZeroCount and all subsequent fields are skipped.
            return;
        }
        zeroCountDecoder.reset();
        if (fieldCount <= 6) {
            // PositiveBuckets and all subsequent fields are skipped.
            return;
        }
        if (!isPositiveBucketsRecursive) {
            positiveBucketsDecoder.reset();
        }
        if (fieldCount <= 7) {
            // NegativeBuckets and all subsequent fields are skipped.
            return;
        }
        if (!isNegativeBucketsRecursive) {
            negativeBucketsDecoder.reset();
        }
        if (fieldCount <= 8) {
            // ZeroThreshold and all subsequent fields are skipped.
            return;
        }
        zeroThresholdDecoder.reset();
    }

    public ExpHistogramValue decode(ExpHistogramValue dstPtr) throws IOException {
        ExpHistogramValue val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        // Write bits to indicate which optional fields are set.
        val.optionalFieldsPresent = buf.readBits(3);
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedCount) != 0) {
            // Field is changed and is present, decode it.
            val.count = countDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedSum) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentSum) != 0) {
            // Field is changed and is present, decode it.
            val.sum = sumDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedMin) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentMin) != 0) {
            // Field is changed and is present, decode it.
            val.min = minDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedMax) != 0 && (val.optionalFieldsPresent & ExpHistogramValue.fieldPresentMax) != 0) {
            // Field is changed and is present, decode it.
            val.max = maxDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedScale) != 0) {
            // Field is changed and is present, decode it.
            val.scale = scaleDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedZeroCount) != 0) {
            // Field is changed and is present, decode it.
            val.zeroCount = zeroCountDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedPositiveBuckets) != 0) {
            // Field is changed and is present, decode it.
            if (val.positiveBuckets == null) {
                val.positiveBuckets = new ExpHistogramBuckets(val.modifiedFields, ExpHistogramValue.fieldModifiedPositiveBuckets);
            }
            val.positiveBuckets = positiveBucketsDecoder.decode(val.positiveBuckets);
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedNegativeBuckets) != 0) {
            // Field is changed and is present, decode it.
            if (val.negativeBuckets == null) {
                val.negativeBuckets = new ExpHistogramBuckets(val.modifiedFields, ExpHistogramValue.fieldModifiedNegativeBuckets);
            }
            val.negativeBuckets = negativeBucketsDecoder.decode(val.negativeBuckets);
        }
        
        if ((val.modifiedFields.mask & ExpHistogramValue.fieldModifiedZeroThreshold) != 0) {
            // Field is changed and is present, decode it.
            val.zeroThreshold = zeroThresholdDecoder.decode();
        }
        
        
        return val;
    }
}

