// Code generated by stefgen. DO NOT EDIT.
// ScopeEncoder implements encoding of Scope
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class ScopeEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private StringEncoder nameEncoder = new StringEncoder();
    private StringEncoder versionEncoder = new StringEncoder();
    private StringEncoder schemaURLEncoder = new StringEncoder();
    private AttributesEncoder attributesEncoder = new AttributesEncoder();
    private Uint64Encoder droppedAttributesCountEncoder = new Uint64Encoder();
    
    private ScopeEncoderDict dict;
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.ScopeEncoder != null) {
            throw new IllegalStateException("cannot initialize ScopeEncoder: already initialized");
        }
        state.ScopeEncoder = this;

        try {
            this.limiter = state.getLimiter();
            this.dict = state.Scope;

            if (state.getOverrideSchema() != null) {
                int fieldCount = state.getOverrideSchema().getFieldCount("Scope");
                this.fieldCount = fieldCount;
                this.keepFieldMask = ~((~0L) << this.fieldCount);
            } else {
                this.fieldCount = 5;
                this.keepFieldMask = ~0L;
            }

            
            if (this.fieldCount <= 0) {
                return; // Name and subsequent fields are skipped.
            }
            this.nameEncoder.init(state.ScopeName, this.limiter, columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Version and subsequent fields are skipped.
            }
            this.versionEncoder.init(state.ScopeVersion, this.limiter, columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // SchemaURL and subsequent fields are skipped.
            }
            this.schemaURLEncoder.init(state.SchemaURL, this.limiter, columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // Attributes and subsequent fields are skipped.
            }
            this.attributesEncoder.init(state, columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // DroppedAttributesCount and subsequent fields are skipped.
            }
            this.droppedAttributesCountEncoder.init(this.limiter, columns.addSubColumn());
        } finally {
            state.ScopeEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcedly writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        this.nameEncoder.reset();
        this.versionEncoder.reset();
        this.schemaURLEncoder.reset();
        this.attributesEncoder.reset();
        this.droppedAttributesCountEncoder.reset();
    }

    // encode encodes val into buf
    public void encode(Scope val) throws IOException {
        int oldLen = this.buf.bitCount();

        
        // Check if the Scope exists in the dictionary.
        ScopeEncoderDict.Entry entry = this.dict.get(val);
        if (entry != null) {
            // The Scope exists, we will reference it.
            // Indicate a RefNum follows.
            this.buf.writeBit(0);
            // Encode refNum.
            this.buf.writeUvarintCompact(entry.refNum);
            // Account written bits in the limiter.
            int newLen = this.buf.bitCount();
            this.limiter.addFrameBits(newLen - oldLen);
            // Mark all fields non-modified recursively so that next encode() correctly
            // encodes only fields that change after this.
            val.markUnmodifiedRecursively();
            return;
        }

        // The Scope does not exist in the dictionary. Add it to the dictionary.
        Scope valInDict = val.clone();
        entry = new ScopeEncoderDict.Entry(this.dict.size(), valInDict);
        this.dict.set(valInDict, entry);
        this.limiter.addDictElemSize(valInDict.byteSize());
        // Indicate that an encoded Scope follows.
        this.buf.writeBit(1); // TODO: optimize and merge writeBit with the following writeBits.
        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Scope.fieldModifiedName | 
                Scope.fieldModifiedVersion | 
                Scope.fieldModifiedSchemaURL | 
                Scope.fieldModifiedAttributes | 
                Scope.fieldModifiedDroppedAttributesCount | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Scope.fieldModifiedName) != 0) {
            // Encode Name
            this.nameEncoder.encode(val.name);
        }
        
        if ((fieldMask & Scope.fieldModifiedVersion) != 0) {
            // Encode Version
            this.versionEncoder.encode(val.version);
        }
        
        if ((fieldMask & Scope.fieldModifiedSchemaURL) != 0) {
            // Encode SchemaURL
            this.schemaURLEncoder.encode(val.schemaURL);
        }
        
        if ((fieldMask & Scope.fieldModifiedAttributes) != 0) {
            // Encode Attributes
            this.attributesEncoder.encode(val.attributes);
        }
        
        if ((fieldMask & Scope.fieldModifiedDroppedAttributesCount) != 0) {
            // Encode DroppedAttributesCount
            this.droppedAttributesCountEncoder.encode(val.droppedAttributesCount);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        
        if (this.fieldCount <= 0) {
            return; // Name and subsequent fields are skipped.
        }
        this.nameEncoder.collectColumns(columnSet.at(0));
        if (this.fieldCount <= 1) {
            return; // Version and subsequent fields are skipped.
        }
        this.versionEncoder.collectColumns(columnSet.at(1));
        if (this.fieldCount <= 2) {
            return; // SchemaURL and subsequent fields are skipped.
        }
        this.schemaURLEncoder.collectColumns(columnSet.at(2));
        if (this.fieldCount <= 3) {
            return; // Attributes and subsequent fields are skipped.
        }
        this.attributesEncoder.collectColumns(columnSet.at(3));
        if (this.fieldCount <= 4) {
            return; // DroppedAttributesCount and subsequent fields are skipped.
        }
        this.droppedAttributesCountEncoder.collectColumns(columnSet.at(4));
    }
}

