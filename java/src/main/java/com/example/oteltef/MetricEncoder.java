// Code generated by stefc. DO NOT EDIT.
// MetricEncoder implements encoding of Metric
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.Helper;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class MetricEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private StringDictEncoder nameEncoder;
    private boolean isNameRecursive = false; // Indicates Name field's type is recursive.
    private StringDictEncoder descriptionEncoder;
    private boolean isDescriptionRecursive = false; // Indicates Description field's type is recursive.
    private StringDictEncoder unitEncoder;
    private boolean isUnitRecursive = false; // Indicates Unit field's type is recursive.
    private Uint64Encoder type_Encoder;
    private boolean isTypeRecursive = false; // Indicates Type field's type is recursive.
    private AttributesEncoder metadataEncoder;
    private boolean isMetadataRecursive = false; // Indicates Metadata field's type is recursive.
    private Float64ArrayEncoder histogramBoundsEncoder;
    private boolean isHistogramBoundsRecursive = false; // Indicates HistogramBounds field's type is recursive.
    private Uint64Encoder aggregationTemporalityEncoder;
    private boolean isAggregationTemporalityRecursive = false; // Indicates AggregationTemporality field's type is recursive.
    private BoolEncoder monotonicEncoder;
    private boolean isMonotonicRecursive = false; // Indicates Monotonic field's type is recursive.
    
    private MetricEncoderDict dict;
    

    private long keepFieldMask;
    private int fieldCount;
    

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.MetricEncoder != null) {
            throw new IllegalStateException("cannot initialize MetricEncoder: already initialized");
        }
        state.MetricEncoder = this;

        try {
            limiter = state.getLimiter();
            dict = state.Metric;

            fieldCount = state.getStructFieldCounts().getMetricFieldCount();
            keepFieldMask = ~((~0L) << fieldCount);
            // Init encoder for Name field.
            if (fieldCount <= 0) {
                return; // Name and subsequent fields are skipped.
            }
            nameEncoder = new StringDictEncoder();
            nameEncoder.init(state.MetricName, limiter, columns.addSubColumn());
            // Init encoder for Description field.
            if (fieldCount <= 1) {
                return; // Description and subsequent fields are skipped.
            }
            descriptionEncoder = new StringDictEncoder();
            descriptionEncoder.init(state.MetricDescription, limiter, columns.addSubColumn());
            // Init encoder for Unit field.
            if (fieldCount <= 2) {
                return; // Unit and subsequent fields are skipped.
            }
            unitEncoder = new StringDictEncoder();
            unitEncoder.init(state.MetricUnit, limiter, columns.addSubColumn());
            // Init encoder for Type field.
            if (fieldCount <= 3) {
                return; // Type and subsequent fields are skipped.
            }
            type_Encoder = new Uint64Encoder();
            type_Encoder.init(limiter, columns.addSubColumn());
            // Init encoder for Metadata field.
            if (fieldCount <= 4) {
                return; // Metadata and subsequent fields are skipped.
            }
            if (state.AttributesEncoder != null) {
                // Recursion detected, use the existing encoder.
                metadataEncoder = state.AttributesEncoder;
                isMetadataRecursive = true;
            } else {
                metadataEncoder = new AttributesEncoder();
                metadataEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for HistogramBounds field.
            if (fieldCount <= 5) {
                return; // HistogramBounds and subsequent fields are skipped.
            }
            if (state.Float64ArrayEncoder != null) {
                // Recursion detected, use the existing encoder.
                histogramBoundsEncoder = state.Float64ArrayEncoder;
                isHistogramBoundsRecursive = true;
            } else {
                histogramBoundsEncoder = new Float64ArrayEncoder();
                histogramBoundsEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for AggregationTemporality field.
            if (fieldCount <= 6) {
                return; // AggregationTemporality and subsequent fields are skipped.
            }
            aggregationTemporalityEncoder = new Uint64Encoder();
            aggregationTemporalityEncoder.init(limiter, columns.addSubColumn());
            // Init encoder for Monotonic field.
            if (fieldCount <= 7) {
                return; // Monotonic and subsequent fields are skipped.
            }
            monotonicEncoder = new BoolEncoder();
            monotonicEncoder.init(limiter, columns.addSubColumn());
        } finally {
            state.MetricEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcefully writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        
        if (fieldCount <= 0) {
            return; // Name and all subsequent fields are skipped.
        }
        nameEncoder.reset();
        if (fieldCount <= 1) {
            return; // Description and all subsequent fields are skipped.
        }
        descriptionEncoder.reset();
        if (fieldCount <= 2) {
            return; // Unit and all subsequent fields are skipped.
        }
        unitEncoder.reset();
        if (fieldCount <= 3) {
            return; // Type and all subsequent fields are skipped.
        }
        type_Encoder.reset();
        if (fieldCount <= 4) {
            return; // Metadata and all subsequent fields are skipped.
        }
        
        if (!isMetadataRecursive) {
            metadataEncoder.reset();
        }
        
        if (fieldCount <= 5) {
            return; // HistogramBounds and all subsequent fields are skipped.
        }
        
        if (!isHistogramBoundsRecursive) {
            histogramBoundsEncoder.reset();
        }
        
        if (fieldCount <= 6) {
            return; // AggregationTemporality and all subsequent fields are skipped.
        }
        aggregationTemporalityEncoder.reset();
        if (fieldCount <= 7) {
            return; // Monotonic and all subsequent fields are skipped.
        }
        monotonicEncoder.reset();
    }

    // encode encodes val into buf
    public void encode(Metric val) throws IOException {
        int oldLen = this.buf.bitCount();

        
        // Check if the Metric exists in the dictionary.
        MetricEncoderDict.Entry entry = this.dict.get(val);
        if (entry != null) {
            // The Metric exists, we will reference it.
            // Indicate a RefNum follows.
            this.buf.writeBit(0);
            // Encode refNum.
            this.buf.writeUvarintCompact(entry.refNum);
            // Account written bits in the limiter.
            int newLen = this.buf.bitCount();
            this.limiter.addFrameBits(newLen - oldLen);
            // Mark all fields non-modified recursively so that next encode() correctly
            // encodes only fields that change after this.
            val.markUnmodifiedRecursively();
            return;
        }

        // The Metric does not exist in the dictionary. Add it to the dictionary.
        Metric valInDict = val.clone();
        entry = new MetricEncoderDict.Entry(this.dict.size(), valInDict);
        this.dict.set(valInDict, entry);
        this.limiter.addDictElemSize(valInDict.byteSize());
        // Indicate that an encoded Metric follows.
        this.buf.writeBit(1); // TODO: optimize and merge writeBit with the following writeBits.
        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Metric.fieldModifiedName | 
                Metric.fieldModifiedDescription | 
                Metric.fieldModifiedUnit | 
                Metric.fieldModifiedType | 
                Metric.fieldModifiedMetadata | 
                Metric.fieldModifiedHistogramBounds | 
                Metric.fieldModifiedAggregationTemporality | 
                Metric.fieldModifiedMonotonic | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Metric.fieldModifiedName) != 0) {
            // Encode Name
            this.nameEncoder.encode(val.name);
        }
        
        if ((fieldMask & Metric.fieldModifiedDescription) != 0) {
            // Encode Description
            this.descriptionEncoder.encode(val.description);
        }
        
        if ((fieldMask & Metric.fieldModifiedUnit) != 0) {
            // Encode Unit
            this.unitEncoder.encode(val.unit);
        }
        
        if ((fieldMask & Metric.fieldModifiedType) != 0) {
            // Encode Type
            this.type_Encoder.encode(val.type_);
        }
        
        if ((fieldMask & Metric.fieldModifiedMetadata) != 0) {
            // Encode Metadata
            this.metadataEncoder.encode(val.metadata);
        }
        
        if ((fieldMask & Metric.fieldModifiedHistogramBounds) != 0) {
            // Encode HistogramBounds
            this.histogramBoundsEncoder.encode(val.histogramBounds);
        }
        
        if ((fieldMask & Metric.fieldModifiedAggregationTemporality) != 0) {
            // Encode AggregationTemporality
            this.aggregationTemporalityEncoder.encode(val.aggregationTemporality);
        }
        
        if ((fieldMask & Metric.fieldModifiedMonotonic) != 0) {
            // Encode Monotonic
            this.monotonicEncoder.encode(val.monotonic);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect Name field.
        if (this.fieldCount <= 0) {
            return; // Name and subsequent fields are skipped.
        }
        
        nameEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Description field.
        if (this.fieldCount <= 1) {
            return; // Description and subsequent fields are skipped.
        }
        
        descriptionEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Unit field.
        if (this.fieldCount <= 2) {
            return; // Unit and subsequent fields are skipped.
        }
        
        unitEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Type field.
        if (this.fieldCount <= 3) {
            return; // Type and subsequent fields are skipped.
        }
        
        type_Encoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Metadata field.
        if (this.fieldCount <= 4) {
            return; // Metadata and subsequent fields are skipped.
        }
        if (!isMetadataRecursive) {
            metadataEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect HistogramBounds field.
        if (this.fieldCount <= 5) {
            return; // HistogramBounds and subsequent fields are skipped.
        }
        if (!isHistogramBoundsRecursive) {
            histogramBoundsEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect AggregationTemporality field.
        if (this.fieldCount <= 6) {
            return; // AggregationTemporality and subsequent fields are skipped.
        }
        
        aggregationTemporalityEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Monotonic field.
        if (this.fieldCount <= 7) {
            return; // Monotonic and subsequent fields are skipped.
        }
        
        monotonicEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
    }
}

