// Code generated by stefgen. DO NOT EDIT.
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

// Decoder for Int64Array
class Int64ArrayDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private Int64Decoder elemDecoder;
    private boolean isRecursive = false;
    private long prevLen = 0;

    // init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        column = columns.getColumn();
        elemDecoder = new Int64Decoder();
        elemDecoder.init(columns.addSubColumn());
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        buf.reset(column.getData());
        if (!isRecursive) {
            elemDecoder.continueDecoding();
        }
    }

    public void reset() {
        if (!isRecursive) {
            elemDecoder.reset();
        }
        prevLen = 0;
    }

    public Int64Array decode(Int64Array dst) throws IOException {
        
            long lenDelta = buf.readVarintCompact();
            long newLen = prevLen + lenDelta;
            prevLen = newLen;

            if (newLen < 0) {
                throw new IllegalStateException("Invalid array length: " + newLen);
            }
            if (newLen > Integer.MAX_VALUE) {
                throw new IllegalStateException("Array length exceeds maximum: " + newLen);
            }

            dst.ensureLen((int)newLen);
            for (int i = 0; i < newLen; i++) {
                
                dst.elems[i] = elemDecoder.decode();
                
            }

        return dst;
    }
}

