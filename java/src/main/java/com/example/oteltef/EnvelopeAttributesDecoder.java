// Code generated by stefgen. DO NOT EDIT.
package com.example.oteltef;

import net.stef.BytesReader;
import net.stef.Limits;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

// Decoder for EnvelopeAttributes
class EnvelopeAttributesDecoder {
    private final BytesReader buf = new BytesReader();
    private ReadableColumn column;
    private StringDecoder keyDecoder;
    private BytesDecoder valueDecoder;
    private boolean isKeyRecursive = false;
    private boolean isValueRecursive = false;

    
    private EnvelopeAttributes lastVal = new EnvelopeAttributes();

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        this.column = columns.getColumn();

        // Remember this encoder in the state so that we can detect recursion.
        if (state.EnvelopeAttributesDecoder != null) {
            throw new IllegalStateException("cannot initialize EnvelopeAttributesDecoder: already initialized");
        }
        state.EnvelopeAttributesDecoder = this;
        try {
            keyDecoder = new StringDecoder();
            keyDecoder.init(null, columns.addSubColumn());
            valueDecoder = new BytesDecoder();
            valueDecoder.init(null, columns.addSubColumn());
        } finally {
            state.EnvelopeAttributesDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        buf.reset(column.getData());
        if (!isKeyRecursive) {
            keyDecoder.continueDecoding();
        }
        if (!isValueRecursive) {
            valueDecoder.continueDecoding();
        }
    }

    public void reset() {
        if (!isKeyRecursive) {
            keyDecoder.reset();
        }
        if (!isValueRecursive) {
            valueDecoder.reset();
        }
        lastVal = new EnvelopeAttributes();
    }

    public EnvelopeAttributes decode(EnvelopeAttributes dst) throws IOException {
            long countOrChangedValues = buf.readUvarint();
            if (countOrChangedValues == 0) {
                decodeCopyOfLast(lastVal, dst);
                return dst;
            }
            if ((countOrChangedValues & 0b1) == 0) {
                decodeValuesOnly(lastVal, countOrChangedValues >>> 1, dst);
                return dst;
            }
            if ((countOrChangedValues & 0b1) == 0b1) {
                decodeFull(lastVal, (int)(countOrChangedValues >>> 1), dst);
                return dst;
            }
            throw new RuntimeException("Multimap decode error");
}

    private void decodeCopyOfLast(EnvelopeAttributes lastVal, EnvelopeAttributes dst) {
        dst.ensureLen(lastVal.elemsLen);
        for (int i=0; i < dst.elemsLen; i++) {
            dst.elems[i].key = lastVal.elems[i].key;
            dst.elems[i].value = lastVal.elems[i].value;
        }
    }

    private void decodeValuesOnly(EnvelopeAttributes lastVal, long changedValuesBits, EnvelopeAttributes dst) throws IOException {
        if (lastVal.elemsLen == 0) {
            throw new RuntimeException("Multimap decode error: lastVal empty");
        }
        int count = lastVal.elemsLen;
        dst.ensureLen(count);
        long bitToRead = 1L << (dst.elemsLen - 1);
        for (int i = 0; i < dst.elemsLen; i++) {
            // Copy the key from lastVal. All keys are the same.
            dst.elems[i].key = lastVal.elems[i].key;
            if ((bitToRead & changedValuesBits) == 0) {
                // Value is not changed, copy from lastVal.
                dst.elems[i].value = lastVal.elems[i].value;
            }
            bitToRead >>= 1;
        }

        // Decode changed values
        bitToRead = (long)1 << (dst.elemsLen - 1);
        for (int i = 0; i<dst.elemsLen; i++) {
            if ((bitToRead & changedValuesBits) != 0) {
                // Value is changed, decode it.
                dst.elems[i].value = valueDecoder.decode();

                // Store the values in lastVal.
                lastVal.elems[i].value = dst.elems[i].value;
            }
            bitToRead >>= 1;
        }
    }

    private void decodeFull(EnvelopeAttributes lastVal, int count, EnvelopeAttributes dst) throws IOException {
        if (count < 0 || count >= Limits.MultimapElemCountLimit) {
            throw new RuntimeException("Multimap decode error: invalid count " + count);
        }
        
        dst.ensureLen(count);
        lastVal.ensureLen(count);

        // Decode values first.
        for (int i = 0; i < count; i++) {
            dst.elems[i].key = keyDecoder.decode();
            dst.elems[i].value = valueDecoder.decode();

            // Store decoded values in lastVal.
            lastVal.elems[i].key = dst.elems[i].key;
            lastVal.elems[i].value = dst.elems[i].value;
        }
    }
}
