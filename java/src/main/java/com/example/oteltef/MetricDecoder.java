// Code generated by stefc. DO NOT EDIT.
// MetricDecoder implements decoding of Metric
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class MetricDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private int fieldCount;

    
    private StringDictDecoder nameDecoder;
    private boolean isNameRecursive = false; // Indicates Name field's type is recursive.
    private StringDictDecoder descriptionDecoder;
    private boolean isDescriptionRecursive = false; // Indicates Description field's type is recursive.
    private StringDictDecoder unitDecoder;
    private boolean isUnitRecursive = false; // Indicates Unit field's type is recursive.
    private Uint64Decoder type_Decoder;
    private boolean isTypeRecursive = false; // Indicates Type field's type is recursive.
    private AttributesDecoder metadataDecoder;
    private boolean isMetadataRecursive = false; // Indicates Metadata field's type is recursive.
    private Float64ArrayDecoder histogramBoundsDecoder;
    private boolean isHistogramBoundsRecursive = false; // Indicates HistogramBounds field's type is recursive.
    private Uint64Decoder aggregationTemporalityDecoder;
    private boolean isAggregationTemporalityRecursive = false; // Indicates AggregationTemporality field's type is recursive.
    private BoolDecoder monotonicDecoder;
    private boolean isMonotonicRecursive = false; // Indicates Monotonic field's type is recursive.
    
    private MetricDecoderDict dict;
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.MetricDecoder != null) {
            throw new IllegalStateException("cannot initialize MetricDecoder: already initialized");
        }
        state.MetricDecoder = this;

        try {
            fieldCount = state.getStructFieldCounts().getMetricFieldCount();

            column = columns.getColumn();
            dict = state.Metric;
            
            if (this.fieldCount <= 0) {
                return; // Name and subsequent fields are skipped.
            }
            nameDecoder = new StringDictDecoder();
            nameDecoder.init(state.MetricName, columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Description and subsequent fields are skipped.
            }
            descriptionDecoder = new StringDictDecoder();
            descriptionDecoder.init(state.MetricDescription, columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // Unit and subsequent fields are skipped.
            }
            unitDecoder = new StringDictDecoder();
            unitDecoder.init(state.MetricUnit, columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // Type and subsequent fields are skipped.
            }
            type_Decoder = new Uint64Decoder();
            type_Decoder.init(columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // Metadata and subsequent fields are skipped.
            }
            if (state.AttributesDecoder != null) {
                // Recursion detected, use the existing decoder.
                metadataDecoder = state.AttributesDecoder;
                isMetadataRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                metadataDecoder = new AttributesDecoder();
                metadataDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 5) {
                return; // HistogramBounds and subsequent fields are skipped.
            }
            if (state.Float64ArrayDecoder != null) {
                // Recursion detected, use the existing decoder.
                histogramBoundsDecoder = state.Float64ArrayDecoder;
                isHistogramBoundsRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                histogramBoundsDecoder = new Float64ArrayDecoder();
                histogramBoundsDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 6) {
                return; // AggregationTemporality and subsequent fields are skipped.
            }
            aggregationTemporalityDecoder = new Uint64Decoder();
            aggregationTemporalityDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 7) {
                return; // Monotonic and subsequent fields are skipped.
            }
            monotonicDecoder = new BoolDecoder();
            monotonicDecoder.init(columns.addSubColumn());
        } finally {
            state.MetricDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Name and subsequent fields are skipped.
        }
        nameDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Description and subsequent fields are skipped.
        }
        descriptionDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // Unit and subsequent fields are skipped.
        }
        unitDecoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // Type and subsequent fields are skipped.
        }
        type_Decoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // Metadata and subsequent fields are skipped.
        }
        
        if (!isMetadataRecursive) {
            metadataDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 5) {
            return; // HistogramBounds and subsequent fields are skipped.
        }
        
        if (!isHistogramBoundsRecursive) {
            histogramBoundsDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 6) {
            return; // AggregationTemporality and subsequent fields are skipped.
        }
        aggregationTemporalityDecoder.continueDecoding();
        if (this.fieldCount <= 7) {
            return; // Monotonic and subsequent fields are skipped.
        }
        monotonicDecoder.continueDecoding();
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            // Name and all subsequent fields are skipped.
            return;
        }
        nameDecoder.reset();
        if (fieldCount <= 1) {
            // Description and all subsequent fields are skipped.
            return;
        }
        descriptionDecoder.reset();
        if (fieldCount <= 2) {
            // Unit and all subsequent fields are skipped.
            return;
        }
        unitDecoder.reset();
        if (fieldCount <= 3) {
            // Type and all subsequent fields are skipped.
            return;
        }
        type_Decoder.reset();
        if (fieldCount <= 4) {
            // Metadata and all subsequent fields are skipped.
            return;
        }
        if (!isMetadataRecursive) {
            metadataDecoder.reset();
        }
        if (fieldCount <= 5) {
            // HistogramBounds and all subsequent fields are skipped.
            return;
        }
        if (!isHistogramBoundsRecursive) {
            histogramBoundsDecoder.reset();
        }
        if (fieldCount <= 6) {
            // AggregationTemporality and all subsequent fields are skipped.
            return;
        }
        aggregationTemporalityDecoder.reset();
        if (fieldCount <= 7) {
            // Monotonic and all subsequent fields are skipped.
            return;
        }
        monotonicDecoder.reset();
    }

    public Metric decode(Metric dstPtr) throws IOException {
        // Check if this is a dictionary-based decoding.
        int dictFlag = buf.readBit();
        if (dictFlag == 0) {
            long refNum = buf.readUvarintCompact();
            if (refNum >= dict.size()) {
                throw new IOException("Invalid refNum");
            }
            return dict.getByIndex((int)refNum);
        }

        // dstPtr is pointing to a element in the dictionary. We are not allowed
       	// to modify it. Make a clone of it and decode into the clone.
        Metric val = dstPtr.clone();
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedName) != 0) {
            // Field is changed and is present, decode it.
            val.name = nameDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedDescription) != 0) {
            // Field is changed and is present, decode it.
            val.description = descriptionDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedUnit) != 0) {
            // Field is changed and is present, decode it.
            val.unit = unitDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedType) != 0) {
            // Field is changed and is present, decode it.
            val.type_ = type_Decoder.decode();
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedMetadata) != 0) {
            // Field is changed and is present, decode it.
            if (val.metadata == null) {
                val.metadata = new Attributes(val.modifiedFields, Metric.fieldModifiedMetadata);
            }
            val.metadata = metadataDecoder.decode(val.metadata);
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedHistogramBounds) != 0) {
            // Field is changed and is present, decode it.
            if (val.histogramBounds == null) {
                val.histogramBounds = new Float64Array(val.modifiedFields, Metric.fieldModifiedHistogramBounds);
            }
            val.histogramBounds = histogramBoundsDecoder.decode(val.histogramBounds);
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedAggregationTemporality) != 0) {
            // Field is changed and is present, decode it.
            val.aggregationTemporality = aggregationTemporalityDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Metric.fieldModifiedMonotonic) != 0) {
            // Field is changed and is present, decode it.
            val.monotonic = monotonicDecoder.decode();
        }
        
        
        dict.add(val);
        
        return val;
    }
}

