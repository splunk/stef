// Code generated by stefgen. DO NOT EDIT.
// MetricsEncoder implements encoding of Metrics
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class MetricsEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;

    // forceModifiedFields is set to true if the next encoding operation
    // must write all fields, whether they are modified or not.
    // This is used after frame restarts so that the data can be decoded
    // from the frame start.
    private boolean forceModifiedFields;

    
    private EnvelopeEncoder envelopeEncoder;
    private boolean isEnvelopeRecursive = false; // Indicates Envelope field's type is recursive.
    private MetricEncoder metricEncoder;
    private boolean isMetricRecursive = false; // Indicates Metric field's type is recursive.
    private ResourceEncoder resourceEncoder;
    private boolean isResourceRecursive = false; // Indicates Resource field's type is recursive.
    private ScopeEncoder scopeEncoder;
    private boolean isScopeRecursive = false; // Indicates Scope field's type is recursive.
    private AttributesEncoder attributesEncoder;
    private boolean isAttributesRecursive = false; // Indicates Attributes field's type is recursive.
    private PointEncoder pointEncoder;
    private boolean isPointRecursive = false; // Indicates Point field's type is recursive.
    

    private long keepFieldMask;
    private int fieldCount;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.MetricsEncoder != null) {
            throw new IllegalStateException("cannot initialize MetricsEncoder: already initialized");
        }
        state.MetricsEncoder = this;

        try {
            this.limiter = state.getLimiter();

            this.fieldCount = state.getStructFieldCounts().getMetricsFieldCount();
            this.keepFieldMask = ~((~0L) << this.fieldCount);
            
            // Init encoder for Envelope field.
            if (this.fieldCount <= 0) {
                return; // Envelope and subsequent fields are skipped.
            }
            if (state.EnvelopeEncoder != null) {
                // Recursion detected, use the existing encoder.
                envelopeEncoder = state.EnvelopeEncoder;
                isEnvelopeRecursive = true;
            } else {
                envelopeEncoder = new EnvelopeEncoder();
                envelopeEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Metric field.
            if (this.fieldCount <= 1) {
                return; // Metric and subsequent fields are skipped.
            }
            if (state.MetricEncoder != null) {
                // Recursion detected, use the existing encoder.
                metricEncoder = state.MetricEncoder;
                isMetricRecursive = true;
            } else {
                metricEncoder = new MetricEncoder();
                metricEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Resource field.
            if (this.fieldCount <= 2) {
                return; // Resource and subsequent fields are skipped.
            }
            if (state.ResourceEncoder != null) {
                // Recursion detected, use the existing encoder.
                resourceEncoder = state.ResourceEncoder;
                isResourceRecursive = true;
            } else {
                resourceEncoder = new ResourceEncoder();
                resourceEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Scope field.
            if (this.fieldCount <= 3) {
                return; // Scope and subsequent fields are skipped.
            }
            if (state.ScopeEncoder != null) {
                // Recursion detected, use the existing encoder.
                scopeEncoder = state.ScopeEncoder;
                isScopeRecursive = true;
            } else {
                scopeEncoder = new ScopeEncoder();
                scopeEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Attributes field.
            if (this.fieldCount <= 4) {
                return; // Attributes and subsequent fields are skipped.
            }
            if (state.AttributesEncoder != null) {
                // Recursion detected, use the existing encoder.
                attributesEncoder = state.AttributesEncoder;
                isAttributesRecursive = true;
            } else {
                attributesEncoder = new AttributesEncoder();
                attributesEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Point field.
            if (this.fieldCount <= 5) {
                return; // Point and subsequent fields are skipped.
            }
            if (state.PointEncoder != null) {
                // Recursion detected, use the existing encoder.
                pointEncoder = state.PointEncoder;
                isPointRecursive = true;
            } else {
                pointEncoder = new PointEncoder();
                pointEncoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.MetricsEncoder = null;
        }
    }

    public void reset() {
        // Since we are resetting the state of encoder make sure the next encode()
        // call forcefully writes all fields and does not attempt to skip.
        this.forceModifiedFields = true;
        
        if (fieldCount <= 0) {
            return; // Envelope and all subsequent fields are skipped.
        }
        
        if (!isEnvelopeRecursive) {
            envelopeEncoder.reset();
        }
        
        if (fieldCount <= 1) {
            return; // Metric and all subsequent fields are skipped.
        }
        
        if (!isMetricRecursive) {
            metricEncoder.reset();
        }
        
        if (fieldCount <= 2) {
            return; // Resource and all subsequent fields are skipped.
        }
        
        if (!isResourceRecursive) {
            resourceEncoder.reset();
        }
        
        if (fieldCount <= 3) {
            return; // Scope and all subsequent fields are skipped.
        }
        
        if (!isScopeRecursive) {
            scopeEncoder.reset();
        }
        
        if (fieldCount <= 4) {
            return; // Attributes and all subsequent fields are skipped.
        }
        
        if (!isAttributesRecursive) {
            attributesEncoder.reset();
        }
        
        if (fieldCount <= 5) {
            return; // Point and all subsequent fields are skipped.
        }
        
        if (!isPointRecursive) {
            pointEncoder.reset();
        }
        
    }

    // encode encodes val into buf
    public void encode(Metrics val) throws IOException {
        int oldLen = this.buf.bitCount();

        

        // Mask that describes what fields are encoded. Start with all modified fields.
        long fieldMask = val.modifiedFields.mask;
        // If forceModifiedFields we need to set to 1 all bits so that we
        // force writing of all fields.
        if (this.forceModifiedFields) {
            fieldMask =
                Metrics.fieldModifiedEnvelope | 
                Metrics.fieldModifiedMetric | 
                Metrics.fieldModifiedResource | 
                Metrics.fieldModifiedScope | 
                Metrics.fieldModifiedAttributes | 
                Metrics.fieldModifiedPoint | 0L;
        }

        // Only write fields that we want to write. See init() for keepFieldMask.
        fieldMask &= this.keepFieldMask;

        // Write bits to indicate which fields follow.
        this.buf.writeBits(fieldMask, this.fieldCount);
        
        // Encode modified, present fields.
        
        if ((fieldMask & Metrics.fieldModifiedEnvelope) != 0) {
            // Encode Envelope
            this.envelopeEncoder.encode(val.envelope);
        }
        
        if ((fieldMask & Metrics.fieldModifiedMetric) != 0) {
            // Encode Metric
            this.metricEncoder.encode(val.metric);
        }
        
        if ((fieldMask & Metrics.fieldModifiedResource) != 0) {
            // Encode Resource
            this.resourceEncoder.encode(val.resource);
        }
        
        if ((fieldMask & Metrics.fieldModifiedScope) != 0) {
            // Encode Scope
            this.scopeEncoder.encode(val.scope);
        }
        
        if ((fieldMask & Metrics.fieldModifiedAttributes) != 0) {
            // Encode Attributes
            this.attributesEncoder.encode(val.attributes);
        }
        
        if ((fieldMask & Metrics.fieldModifiedPoint) != 0) {
            // Encode Point
            this.pointEncoder.encode(val.point);
        }
        
        // Account written bits in the limiter.
        int newLen = this.buf.bitCount();
        this.limiter.addFrameBits(newLen - oldLen);

        // Mark all fields non-modified so that next encode() correctly
        // encodes only fields that change after this.
        val.modifiedFields.mask = 0;
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect Envelope field.
        if (this.fieldCount <= 0) {
            return; // Envelope and subsequent fields are skipped.
        }
        if (!isEnvelopeRecursive) {
            envelopeEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Metric field.
        if (this.fieldCount <= 1) {
            return; // Metric and subsequent fields are skipped.
        }
        if (!isMetricRecursive) {
            metricEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Resource field.
        if (this.fieldCount <= 2) {
            return; // Resource and subsequent fields are skipped.
        }
        if (!isResourceRecursive) {
            resourceEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Scope field.
        if (this.fieldCount <= 3) {
            return; // Scope and subsequent fields are skipped.
        }
        if (!isScopeRecursive) {
            scopeEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Attributes field.
        if (this.fieldCount <= 4) {
            return; // Attributes and subsequent fields are skipped.
        }
        if (!isAttributesRecursive) {
            attributesEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Point field.
        if (this.fieldCount <= 5) {
            return; // Point and subsequent fields are skipped.
        }
        if (!isPointRecursive) {
            pointEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
    }
}

