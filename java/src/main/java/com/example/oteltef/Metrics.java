// Code generated by stefgen. DO NOT EDIT.
// Metrics Java class generated from template
package com.example.oteltef;

import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class Metrics {
    // Field values.
    
    Envelope envelope;
    Metric metric;
    Resource resource;
    Scope scope;
    Attributes attributes;
    Point point;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();

    public static final String StructName = "Metrics";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedEnvelope = 1 << 0;
    public static final long fieldModifiedMetric = 1 << 1;
    public static final long fieldModifiedResource = 1 << 2;
    public static final long fieldModifiedScope = 1 << 3;
    public static final long fieldModifiedAttributes = 1 << 4;
    public static final long fieldModifiedPoint = 1 << 5;

    

    public Metrics() {
        init(null, 0);
    }

    Metrics(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        envelope = new Envelope(modifiedFields, fieldModifiedEnvelope);
        metric = new Metric(modifiedFields, fieldModifiedMetric);
        resource = new Resource(modifiedFields, fieldModifiedResource);
        scope = new Scope(modifiedFields, fieldModifiedScope);
        attributes = new Attributes(modifiedFields, fieldModifiedAttributes);
        point = new Point(modifiedFields, fieldModifiedPoint);
    }

    
    public Envelope getEnvelope() {
        return this.envelope;
    }

    // isEnvelopeModified returns true if the value of Envelope field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isEnvelopeModified() {
        return (this.modifiedFields.mask & fieldModifiedEnvelope) != 0;
    }
    
    public Metric getMetric() {
        return this.metric;
    }

    // isMetricModified returns true if the value of Metric field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isMetricModified() {
        return (this.modifiedFields.mask & fieldModifiedMetric) != 0;
    }
    
    public Resource getResource() {
        return this.resource;
    }

    // isResourceModified returns true if the value of Resource field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isResourceModified() {
        return (this.modifiedFields.mask & fieldModifiedResource) != 0;
    }
    
    public Scope getScope() {
        return this.scope;
    }

    // isScopeModified returns true if the value of Scope field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isScopeModified() {
        return (this.modifiedFields.mask & fieldModifiedScope) != 0;
    }
    
    public Attributes getAttributes() {
        return this.attributes;
    }

    // isAttributesModified returns true if the value of Attributes field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isAttributesModified() {
        return (this.modifiedFields.mask & fieldModifiedAttributes) != 0;
    }
    
    public Point getPoint() {
        return this.point;
    }

    // isPointModified returns true if the value of Point field was modified since
    // Metrics was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isPointModified() {
        return (this.modifiedFields.mask & fieldModifiedPoint) != 0;
    }
    

    void markUnmodified() {
        modifiedFields.markUnmodified();
        if (this.isEnvelopeModified()) {
            this.envelope.markUnmodified();
        }
        if (this.isMetricModified()) {
            this.metric.markUnmodified();
        }
        if (this.isResourceModified()) {
            this.resource.markUnmodified();
        }
        if (this.isScopeModified()) {
            this.scope.markUnmodified();
        }
        if (this.isAttributesModified()) {
            this.attributes.markUnmodified();
        }
        if (this.isPointModified()) {
            this.point.markUnmodified();
        }
    }

    void markModifiedRecursively() {
        envelope.markModifiedRecursively();
        metric.markModifiedRecursively();
        resource.markModifiedRecursively();
        scope.markModifiedRecursively();
        attributes.markModifiedRecursively();
        point.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedEnvelope | 
            fieldModifiedMetric | 
            fieldModifiedResource | 
            fieldModifiedScope | 
            fieldModifiedAttributes | 
            fieldModifiedPoint | 0;
    }

    void markUnmodifiedRecursively() {
        if (isEnvelopeModified()) {
            envelope.markUnmodifiedRecursively();
        }
        if (isMetricModified()) {
            metric.markUnmodifiedRecursively();
        }
        if (isResourceModified()) {
            resource.markUnmodifiedRecursively();
        }
        if (isScopeModified()) {
            scope.markUnmodifiedRecursively();
        }
        if (isAttributesModified()) {
            attributes.markUnmodifiedRecursively();
        }
        if (isPointModified()) {
            point.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    // markDiffModified marks fields in this struct modified if they differ from
    // the corresponding fields in v.
    boolean markDiffModified(Metrics v) {
        boolean modified = false;
        if (envelope.markDiffModified(v.envelope)) {
            modifiedFields.markModified(fieldModifiedEnvelope);
            modified = true;
        }
        
        if (metric.markDiffModified(v.metric)) {
            modifiedFields.markModified(fieldModifiedMetric);
            modified = true;
        }
        
        if (resource.markDiffModified(v.resource)) {
            modifiedFields.markModified(fieldModifiedResource);
            modified = true;
        }
        
        if (scope.markDiffModified(v.scope)) {
            modifiedFields.markModified(fieldModifiedScope);
            modified = true;
        }
        
        if (attributes.markDiffModified(v.attributes)) {
            modifiedFields.markModified(fieldModifiedAttributes);
            modified = true;
        }
        
        if (point.markDiffModified(v.point)) {
            modifiedFields.markModified(fieldModifiedPoint);
            modified = true;
        }
        
        return modified;
    }

    public Metrics clone() {
        Metrics cpy = new Metrics();
        cpy.envelope = this.envelope.clone();
        cpy.metric = this.metric.clone();
        cpy.resource = this.resource.clone();
        cpy.scope = this.scope.clone();
        cpy.attributes = this.attributes.clone();
        cpy.point = this.point.clone();
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        size += this.envelope.byteSize();
        size += this.metric.byteSize();
        size += this.resource.byteSize();
        size += this.scope.byteSize();
        size += this.attributes.byteSize();
        size += this.point.byteSize();
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(Metrics src) {
        envelope.copyFrom(src.envelope);
        metric.copyFrom(src.metric);
        resource.copyFrom(src.resource);
        scope.copyFrom(src.scope);
        attributes.copyFrom(src.attributes);
        point.copyFrom(src.point);
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(Metrics right) {
        // Compare Envelope field.
        if (!this.envelope.equals(right.envelope)) {
            return false;
        }
        // Compare Metric field.
        if (!this.metric.equals(right.metric)) {
            return false;
        }
        // Compare Resource field.
        if (!this.resource.equals(right.resource)) {
            return false;
        }
        // Compare Scope field.
        if (!this.scope.equals(right.scope)) {
            return false;
        }
        // Compare Attributes field.
        if (!this.attributes.equals(right.attributes)) {
            return false;
        }
        // Compare Point field.
        if (!this.point.equals(right.point)) {
            return false;
        }
        return true;
    }

    public static boolean equals(Metrics left, Metrics right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(Metrics left, Metrics right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare Envelope field.
        c = Envelope.compare(left.envelope, right.envelope);
        if (c != 0) {
            return c;
        }
        
        // Compare Metric field.
        c = Metric.compare(left.metric, right.metric);
        if (c != 0) {
            return c;
        }
        
        // Compare Resource field.
        c = Resource.compare(left.resource, right.resource);
        if (c != 0) {
            return c;
        }
        
        // Compare Scope field.
        c = Scope.compare(left.scope, right.scope);
        if (c != 0) {
            return c;
        }
        
        // Compare Attributes field.
        c = Attributes.compare(left.attributes, right.attributes);
        if (c != 0) {
            return c;
        }
        
        // Compare Point field.
        c = Point.compare(left.point, right.point);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(6,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.envelope.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.metric.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.resource.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.scope.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.attributes.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.point.mutateRandom(random);
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((Metrics)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            envelope,
            metric,
            resource,
            scope,
            attributes,
            point
        );
    }

    
    static final byte[] wireSchemaBytes = new byte[]{ 0x0D, 0x08, 0x41, 0x6E, 0x79, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x07, 0x08, 0x45, 0x6E, 0x76, 0x65, 0x6C, 0x6F, 0x70, 0x65, 0x01, 0x08, 0x45, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x05, 0x0D, 0x45, 0x78, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x72, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x02, 0x13, 0x45, 0x78, 0x70, 0x48, 0x69, 0x73, 0x74, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x42, 0x75, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x02, 0x11, 0x45, 0x78, 0x70, 0x48, 0x69, 0x73, 0x74, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x09, 0x0E, 0x48, 0x69, 0x73, 0x74, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x05, 0x06, 0x4D, 0x65, 0x74, 0x72, 0x69, 0x63, 0x08, 0x07, 0x4D, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x06, 0x05, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x04, 0x0A, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x04, 0x08, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x03, 0x05, 0x53, 0x63, 0x6F, 0x70, 0x65, 0x05 };

    static WireSchema wireSchema() throws IOException {
        WireSchema w = new WireSchema();
        w.deserialize(new ByteArrayInputStream(wireSchemaBytes));
        return w;
    }
    
}
