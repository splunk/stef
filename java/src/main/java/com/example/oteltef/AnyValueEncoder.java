// Code generated by stefgen. DO NOT EDIT.
// AnyValueEncoder implements encoding of AnyValue
package com.example.oteltef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class AnyValueEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;
    private AnyValue.Type prevType;
    private int fieldCount;

    
    private StringEncoder stringEncoder = new StringEncoder();
    private BoolEncoder boolEncoder = new BoolEncoder();
    private Int64Encoder int64Encoder = new Int64Encoder();
    private Float64Encoder float64Encoder = new Float64Encoder();
    private AnyValueArrayEncoder arrayEncoder = new AnyValueArrayEncoder();
    private KeyValueListEncoder kVListEncoder = new KeyValueListEncoder();
    private BytesEncoder bytesEncoder = new BytesEncoder();
    

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        state.AnyValueEncoder = this;
        prevType = AnyValue.Type.TypeNone;
        this.limiter = state.getLimiter();

        if (state.getOverrideSchema() != null) {
            int fieldCount = state.getOverrideSchema().getFieldCount("AnyValue");
            this.fieldCount = fieldCount;
        } else {
            this.fieldCount = 7;
        }

        
        if (this.fieldCount <= 0) {
            return; // String and subsequent fields are skipped.
        }
        stringEncoder.init(state.AnyValueString, limiter, columns.addSubColumn());
        if (this.fieldCount <= 1) {
            return; // Bool and subsequent fields are skipped.
        }
        boolEncoder.init(limiter, columns.addSubColumn());
        if (this.fieldCount <= 2) {
            return; // Int64 and subsequent fields are skipped.
        }
        int64Encoder.init(limiter, columns.addSubColumn());
        if (this.fieldCount <= 3) {
            return; // Float64 and subsequent fields are skipped.
        }
        float64Encoder.init(limiter, columns.addSubColumn());
        if (this.fieldCount <= 4) {
            return; // Array and subsequent fields are skipped.
        }
        arrayEncoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 5) {
            return; // KVList and subsequent fields are skipped.
        }
        kVListEncoder.init(state, columns.addSubColumn());
        if (this.fieldCount <= 6) {
            return; // Bytes and subsequent fields are skipped.
        }
        bytesEncoder.init(null, limiter, columns.addSubColumn());
    }

    public void reset() {
        prevType = AnyValue.Type.TypeNone;
        this.stringEncoder.reset();
        this.boolEncoder.reset();
        this.int64Encoder.reset();
        this.float64Encoder.reset();
        this.arrayEncoder.reset();
        this.kVListEncoder.reset();
        this.bytesEncoder.reset();
    }

    // Encode encodes val into buf
    public void encode(AnyValue val) throws IOException {
        int oldLen = buf.bitCount();

        AnyValue.Type typ = val.typ;
        if (typ.getValue() > fieldCount) {
            // The current field type is not supported in target schema. Encode the type as None.
            typ = AnyValue.Type.TypeNone;
        }

        // Compute type delta. 0 means the type is the same as the last time.
        int typDelta = typ.getValue() - prevType.getValue();
        prevType = typ;
        buf.writeVarintCompact(typDelta);

        // Account written bits in the limiter.
        int newLen = buf.bitCount();
        limiter.addFrameBits(newLen-oldLen);

        // Encode currently selected field.
        switch (typ) {
        case TypeString:
            // Encode String
            stringEncoder.encode(val.string);
            break;
        case TypeBool:
            // Encode Bool
            boolEncoder.encode(val.bool);
            break;
        case TypeInt64:
            // Encode Int64
            int64Encoder.encode(val.int64);
            break;
        case TypeFloat64:
            // Encode Float64
            float64Encoder.encode(val.float64);
            break;
        case TypeArray:
            // Encode Array
            arrayEncoder.encode(val.array);
            break;
        case TypeKVList:
            // Encode KVList
            kVListEncoder.encode(val.kVList);
            break;
        case TypeBytes:
            // Encode Bytes
            bytesEncoder.encode(val.bytes);
            break;
        }
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        
        if (this.fieldCount <= 0) {
            return; // String and subsequent fields are skipped.
        }
        this.stringEncoder.collectColumns(columnSet.at(0));
        if (this.fieldCount <= 1) {
            return; // Bool and subsequent fields are skipped.
        }
        this.boolEncoder.collectColumns(columnSet.at(1));
        if (this.fieldCount <= 2) {
            return; // Int64 and subsequent fields are skipped.
        }
        this.int64Encoder.collectColumns(columnSet.at(2));
        if (this.fieldCount <= 3) {
            return; // Float64 and subsequent fields are skipped.
        }
        this.float64Encoder.collectColumns(columnSet.at(3));
        if (this.fieldCount <= 4) {
            return; // Array and subsequent fields are skipped.
        }
        this.arrayEncoder.collectColumns(columnSet.at(4));
        if (this.fieldCount <= 5) {
            return; // KVList and subsequent fields are skipped.
        }
        this.kVListEncoder.collectColumns(columnSet.at(5));
        if (this.fieldCount <= 6) {
            return; // Bytes and subsequent fields are skipped.
        }
        this.bytesEncoder.collectColumns(columnSet.at(6));
    }
}

