// Code generated by stefc. DO NOT EDIT.
// ExemplarDecoder implements decoding of Exemplar
package com.example.oteltef;

import net.stef.BitsReader;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class ExemplarDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private int fieldCount;

    
    private Uint64DeltaDeltaDecoder timestampDecoder;
    private boolean isTimestampRecursive = false; // Indicates Timestamp field's type is recursive.
    private ExemplarValueDecoder valueDecoder;
    private boolean isValueRecursive = false; // Indicates Value field's type is recursive.
    private BytesDecoder spanIDDecoder;
    private boolean isSpanIDRecursive = false; // Indicates SpanID field's type is recursive.
    private BytesDecoder traceIDDecoder;
    private boolean isTraceIDRecursive = false; // Indicates TraceID field's type is recursive.
    private AttributesDecoder filteredAttributesDecoder;
    private boolean isFilteredAttributesRecursive = false; // Indicates FilteredAttributes field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.ExemplarDecoder != null) {
            throw new IllegalStateException("cannot initialize ExemplarDecoder: already initialized");
        }
        state.ExemplarDecoder = this;

        try {
            fieldCount = state.getStructFieldCounts().getExemplarFieldCount();

            column = columns.getColumn();
            
            if (this.fieldCount <= 0) {
                return; // Timestamp and subsequent fields are skipped.
            }
            timestampDecoder = new Uint64DeltaDeltaDecoder();
            timestampDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // Value and subsequent fields are skipped.
            }
            if (state.ExemplarValueDecoder != null) {
                // Recursion detected, use the existing decoder.
                valueDecoder = state.ExemplarValueDecoder;
                isValueRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                valueDecoder = new ExemplarValueDecoder();
                valueDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 2) {
                return; // SpanID and subsequent fields are skipped.
            }
            spanIDDecoder = new BytesDecoder();
            spanIDDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // TraceID and subsequent fields are skipped.
            }
            traceIDDecoder = new BytesDecoder();
            traceIDDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // FilteredAttributes and subsequent fields are skipped.
            }
            if (state.AttributesDecoder != null) {
                // Recursion detected, use the existing decoder.
                filteredAttributesDecoder = state.AttributesDecoder;
                isFilteredAttributesRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                filteredAttributesDecoder = new AttributesDecoder();
                filteredAttributesDecoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.ExemplarDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // Timestamp and subsequent fields are skipped.
        }
        timestampDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // Value and subsequent fields are skipped.
        }
        
        if (!isValueRecursive) {
            valueDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 2) {
            return; // SpanID and subsequent fields are skipped.
        }
        spanIDDecoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // TraceID and subsequent fields are skipped.
        }
        traceIDDecoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // FilteredAttributes and subsequent fields are skipped.
        }
        
        if (!isFilteredAttributesRecursive) {
            filteredAttributesDecoder.continueDecoding();
        }
        
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            // Timestamp and all subsequent fields are skipped.
            return;
        }
        timestampDecoder.reset();
        if (fieldCount <= 1) {
            // Value and all subsequent fields are skipped.
            return;
        }
        if (!isValueRecursive) {
            valueDecoder.reset();
        }
        if (fieldCount <= 2) {
            // SpanID and all subsequent fields are skipped.
            return;
        }
        spanIDDecoder.reset();
        if (fieldCount <= 3) {
            // TraceID and all subsequent fields are skipped.
            return;
        }
        traceIDDecoder.reset();
        if (fieldCount <= 4) {
            // FilteredAttributes and all subsequent fields are skipped.
            return;
        }
        if (!isFilteredAttributesRecursive) {
            filteredAttributesDecoder.reset();
        }
    }

    public Exemplar decode(Exemplar dstPtr) throws IOException {
        Exemplar val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Exemplar.fieldModifiedTimestamp) != 0) {
            // Field is changed and is present, decode it.
            val.timestamp = timestampDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Exemplar.fieldModifiedValue) != 0) {
            // Field is changed and is present, decode it.
            if (val.value == null) {
                val.value = new ExemplarValue(val.modifiedFields, Exemplar.fieldModifiedValue);
            }
            val.value = valueDecoder.decode(val.value);
        }
        
        if ((val.modifiedFields.mask & Exemplar.fieldModifiedSpanID) != 0) {
            // Field is changed and is present, decode it.
            val.spanID = spanIDDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Exemplar.fieldModifiedTraceID) != 0) {
            // Field is changed and is present, decode it.
            val.traceID = traceIDDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Exemplar.fieldModifiedFilteredAttributes) != 0) {
            // Field is changed and is present, decode it.
            if (val.filteredAttributes == null) {
                val.filteredAttributes = new Attributes(val.modifiedFields, Exemplar.fieldModifiedFilteredAttributes);
            }
            val.filteredAttributes = filteredAttributesDecoder.decode(val.filteredAttributes);
        }
        
        
        return val;
    }
}

