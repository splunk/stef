// Code generated by stefc. DO NOT EDIT.
// ExpHistogramValue Java class generated from template
package com.example.oteltef;

import net.stef.BytesValue;
import net.stef.StringValue;
import net.stef.Types;
import net.stef.schema.WireSchema;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

public class ExpHistogramValue {
    // Field values.
    
    long count;
    double sum;
    double min;
    double max;
    long scale;
    long zeroCount;
    ExpHistogramBuckets positiveBuckets;
    ExpHistogramBuckets negativeBuckets;
    double zeroThreshold;

    // modifiedFields keeps track of which fields are modified.
    final ModifiedFields modifiedFields = new ModifiedFields();
    // Field presence bits.
    // Fields which are present have the corresponding bit set, see fieldPresent* consts below.
    long optionalFieldsPresent;

    public static final String StructName = "ExpHistogramValue";

    // Bitmasks for "modified" flags for each field.
    
    public static final long fieldModifiedCount = 1 << 0;
    public static final long fieldModifiedSum = 1 << 1;
    public static final long fieldModifiedMin = 1 << 2;
    public static final long fieldModifiedMax = 1 << 3;
    public static final long fieldModifiedScale = 1 << 4;
    public static final long fieldModifiedZeroCount = 1 << 5;
    public static final long fieldModifiedPositiveBuckets = 1 << 6;
    public static final long fieldModifiedNegativeBuckets = 1 << 7;
    public static final long fieldModifiedZeroThreshold = 1 << 8;

    
    // Bitmasks for "present" flags for optional fields.
    
    public static final long fieldPresentSum = 1L << 0;
    public static final long fieldPresentMin = 1L << 1;
    public static final long fieldPresentMax = 1L << 2;
    

    public ExpHistogramValue() {
        init(null, 0);
    }

    ExpHistogramValue(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedFields.parent = parentModifiedFields;
        modifiedFields.parentBit = parentModifiedBit;
        
        count = 0;
        sum = 0.0;
        min = 0.0;
        max = 0.0;
        scale = 0;
        zeroCount = 0;
        positiveBuckets = new ExpHistogramBuckets(modifiedFields, fieldModifiedPositiveBuckets);
        negativeBuckets = new ExpHistogramBuckets(modifiedFields, fieldModifiedNegativeBuckets);
        zeroThreshold = 0.0;
    }

    void reset() {
        
        count = 0;
        sum = 0.0;
        min = 0.0;
        max = 0.0;
        scale = 0;
        zeroCount = 0;
        if (positiveBuckets != null) {
            positiveBuckets.reset();
        }
        if (negativeBuckets != null) {
            negativeBuckets.reset();
        }
        zeroThreshold = 0.0;
    }

    
    public long getCount() {
        return count;
    }

    // setCount sets the value of Count field.
    public void setCount(long v) {
        if (!Types.Uint64Equal(this.count, v)) {
            this.count = v;
            this.markCountModified();
        }
    }

    private void markCountModified() {
        this.modifiedFields.markModified(fieldModifiedCount);
    }

    // isCountModified returns true if the value of Count field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isCountModified() {
        return (this.modifiedFields.mask & fieldModifiedCount) != 0;
    }
    
    public double getSum() {
        return sum;
    }

    // setSum sets the value of Sum field.
    public void setSum(double v) {
        if (!Types.Float64Equal(this.sum, v)|| (this.optionalFieldsPresent & fieldPresentSum) == 0) {
            this.sum = v;
            this.markSumModified();
            this.optionalFieldsPresent |= fieldPresentSum;
        }
    }
    // unsetSum unsets the presence flag of Sum field. A subsequent hasSum() will return false.
    public void unsetSum() {
        if ((this.optionalFieldsPresent & fieldPresentSum) != 0) {
            this.optionalFieldsPresent &= ~fieldPresentSum;
            this.markSumModified();
        }
    }

    // hasSum returns true if the presence flag Sum field is set and false if it is unset.
    public boolean hasSum() {
        return (this.optionalFieldsPresent & fieldPresentSum) != 0;
    }

    private void markSumModified() {
        this.modifiedFields.markModified(fieldModifiedSum);
    }

    // isSumModified returns true if the value of Sum field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isSumModified() {
        return (this.modifiedFields.mask & fieldModifiedSum) != 0;
    }
    
    public double getMin() {
        return min;
    }

    // setMin sets the value of Min field.
    public void setMin(double v) {
        if (!Types.Float64Equal(this.min, v)|| (this.optionalFieldsPresent & fieldPresentMin) == 0) {
            this.min = v;
            this.markMinModified();
            this.optionalFieldsPresent |= fieldPresentMin;
        }
    }
    // unsetMin unsets the presence flag of Min field. A subsequent hasMin() will return false.
    public void unsetMin() {
        if ((this.optionalFieldsPresent & fieldPresentMin) != 0) {
            this.optionalFieldsPresent &= ~fieldPresentMin;
            this.markMinModified();
        }
    }

    // hasMin returns true if the presence flag Min field is set and false if it is unset.
    public boolean hasMin() {
        return (this.optionalFieldsPresent & fieldPresentMin) != 0;
    }

    private void markMinModified() {
        this.modifiedFields.markModified(fieldModifiedMin);
    }

    // isMinModified returns true if the value of Min field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isMinModified() {
        return (this.modifiedFields.mask & fieldModifiedMin) != 0;
    }
    
    public double getMax() {
        return max;
    }

    // setMax sets the value of Max field.
    public void setMax(double v) {
        if (!Types.Float64Equal(this.max, v)|| (this.optionalFieldsPresent & fieldPresentMax) == 0) {
            this.max = v;
            this.markMaxModified();
            this.optionalFieldsPresent |= fieldPresentMax;
        }
    }
    // unsetMax unsets the presence flag of Max field. A subsequent hasMax() will return false.
    public void unsetMax() {
        if ((this.optionalFieldsPresent & fieldPresentMax) != 0) {
            this.optionalFieldsPresent &= ~fieldPresentMax;
            this.markMaxModified();
        }
    }

    // hasMax returns true if the presence flag Max field is set and false if it is unset.
    public boolean hasMax() {
        return (this.optionalFieldsPresent & fieldPresentMax) != 0;
    }

    private void markMaxModified() {
        this.modifiedFields.markModified(fieldModifiedMax);
    }

    // isMaxModified returns true if the value of Max field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isMaxModified() {
        return (this.modifiedFields.mask & fieldModifiedMax) != 0;
    }
    
    public long getScale() {
        return scale;
    }

    // setScale sets the value of Scale field.
    public void setScale(long v) {
        if (!Types.Int64Equal(this.scale, v)) {
            this.scale = v;
            this.markScaleModified();
        }
    }

    private void markScaleModified() {
        this.modifiedFields.markModified(fieldModifiedScale);
    }

    // isScaleModified returns true if the value of Scale field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isScaleModified() {
        return (this.modifiedFields.mask & fieldModifiedScale) != 0;
    }
    
    public long getZeroCount() {
        return zeroCount;
    }

    // setZeroCount sets the value of ZeroCount field.
    public void setZeroCount(long v) {
        if (!Types.Uint64Equal(this.zeroCount, v)) {
            this.zeroCount = v;
            this.markZeroCountModified();
        }
    }

    private void markZeroCountModified() {
        this.modifiedFields.markModified(fieldModifiedZeroCount);
    }

    // isZeroCountModified returns true if the value of ZeroCount field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isZeroCountModified() {
        return (this.modifiedFields.mask & fieldModifiedZeroCount) != 0;
    }
    
    public ExpHistogramBuckets getPositiveBuckets() {
        return this.positiveBuckets;
    }

    private void markPositiveBucketsModified() {
        this.modifiedFields.markModified(fieldModifiedPositiveBuckets);
    }

    // isPositiveBucketsModified returns true if the value of PositiveBuckets field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isPositiveBucketsModified() {
        return (this.modifiedFields.mask & fieldModifiedPositiveBuckets) != 0;
    }
    
    public ExpHistogramBuckets getNegativeBuckets() {
        return this.negativeBuckets;
    }

    private void markNegativeBucketsModified() {
        this.modifiedFields.markModified(fieldModifiedNegativeBuckets);
    }

    // isNegativeBucketsModified returns true if the value of NegativeBuckets field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isNegativeBucketsModified() {
        return (this.modifiedFields.mask & fieldModifiedNegativeBuckets) != 0;
    }
    
    public double getZeroThreshold() {
        return zeroThreshold;
    }

    // setZeroThreshold sets the value of ZeroThreshold field.
    public void setZeroThreshold(double v) {
        if (!Types.Float64Equal(this.zeroThreshold, v)) {
            this.zeroThreshold = v;
            this.markZeroThresholdModified();
        }
    }

    private void markZeroThresholdModified() {
        this.modifiedFields.markModified(fieldModifiedZeroThreshold);
    }

    // isZeroThresholdModified returns true if the value of ZeroThreshold field was modified since
    // ExpHistogramValue was created, encoded or decoded. If the field is modified
    // it will be encoded by the next Write() operation. If the field is decoded by the
    // next Read() operation the modified flag will be set.
    public boolean isZeroThresholdModified() {
        return (this.modifiedFields.mask & fieldModifiedZeroThreshold) != 0;
    }
    

    void markModifiedRecursively() {
        positiveBuckets.markModifiedRecursively();
        negativeBuckets.markModifiedRecursively();
        modifiedFields.mask =
            fieldModifiedCount | 
            fieldModifiedSum | 
            fieldModifiedMin | 
            fieldModifiedMax | 
            fieldModifiedScale | 
            fieldModifiedZeroCount | 
            fieldModifiedPositiveBuckets | 
            fieldModifiedNegativeBuckets | 
            fieldModifiedZeroThreshold | 0;
    }

    void markUnmodifiedRecursively() {
        if (isPositiveBucketsModified()) {
            positiveBuckets.markUnmodifiedRecursively();
        }
        if (isNegativeBucketsModified()) {
            negativeBuckets.markUnmodifiedRecursively();
        }
        modifiedFields.mask = 0;
    }

    public ExpHistogramValue clone() {
        ExpHistogramValue cpy = new ExpHistogramValue();
        cpy.count = this.count;
        cpy.sum = this.sum;
        cpy.min = this.min;
        cpy.max = this.max;
        cpy.scale = this.scale;
        cpy.zeroCount = this.zeroCount;
        cpy.positiveBuckets = this.positiveBuckets.clone();
        cpy.negativeBuckets = this.negativeBuckets.clone();
        cpy.zeroThreshold = this.zeroThreshold;
        return cpy;
    }

    // ByteSize returns approximate memory usage in bytes. Used to calculate memory used by dictionaries.
    int byteSize() {
        int size = 0; // TODO: calculate the size of this object.
        
        
        
        
        
        
        size += this.positiveBuckets.byteSize();
        size += this.negativeBuckets.byteSize();
        
        return size;
    }

    // Performs a deep copy from src to dst.
    public void copyFrom(ExpHistogramValue src) {
        setCount(src.getCount());
        if (src.hasSum()) {
            setSum(src.getSum());
        } else {
            unsetSum();
        }
        if (src.hasMin()) {
            setMin(src.getMin());
        } else {
            unsetMin();
        }
        if (src.hasMax()) {
            setMax(src.getMax());
        } else {
            unsetMax();
        }
        setScale(src.getScale());
        setZeroCount(src.getZeroCount());
        positiveBuckets.copyFrom(src.positiveBuckets);
        negativeBuckets.copyFrom(src.negativeBuckets);
        setZeroThreshold(src.getZeroThreshold());
        this.optionalFieldsPresent = src.optionalFieldsPresent;
    }

    // equals performs deep comparison and returns true if struct is equal to val.
    public boolean equals(ExpHistogramValue right) {
        // Compare Count field.
        if (!Types.Uint64Equal(this.count, right.count)) {
            return false;
        }
        // Compare Sum field.
        boolean thisSumPresent = (this.optionalFieldsPresent & fieldPresentSum) != 0;
        boolean rightSumPresent = (right.optionalFieldsPresent & fieldPresentSum) != 0;
        if (thisSumPresent != rightSumPresent) {
            return false;
        }
        if (thisSumPresent) { // Compare only if Sum field is present
        if (!Types.Float64Equal(this.sum, right.sum)) {
            return false;
        }
        }
        
        // Compare Min field.
        boolean thisMinPresent = (this.optionalFieldsPresent & fieldPresentMin) != 0;
        boolean rightMinPresent = (right.optionalFieldsPresent & fieldPresentMin) != 0;
        if (thisMinPresent != rightMinPresent) {
            return false;
        }
        if (thisMinPresent) { // Compare only if Min field is present
        if (!Types.Float64Equal(this.min, right.min)) {
            return false;
        }
        }
        
        // Compare Max field.
        boolean thisMaxPresent = (this.optionalFieldsPresent & fieldPresentMax) != 0;
        boolean rightMaxPresent = (right.optionalFieldsPresent & fieldPresentMax) != 0;
        if (thisMaxPresent != rightMaxPresent) {
            return false;
        }
        if (thisMaxPresent) { // Compare only if Max field is present
        if (!Types.Float64Equal(this.max, right.max)) {
            return false;
        }
        }
        
        // Compare Scale field.
        if (!Types.Int64Equal(this.scale, right.scale)) {
            return false;
        }
        // Compare ZeroCount field.
        if (!Types.Uint64Equal(this.zeroCount, right.zeroCount)) {
            return false;
        }
        // Compare PositiveBuckets field.
        if (!this.positiveBuckets.equals(right.positiveBuckets)) {
            return false;
        }
        // Compare NegativeBuckets field.
        if (!this.negativeBuckets.equals(right.negativeBuckets)) {
            return false;
        }
        // Compare ZeroThreshold field.
        if (!Types.Float64Equal(this.zeroThreshold, right.zeroThreshold)) {
            return false;
        }
        return true;
    }

    public static boolean equals(ExpHistogramValue left, ExpHistogramValue right) {
        return left.equals(right);
    }

    // compare performs deep comparison and returns an integer that
    // will be 0 if left == right, negative if left < right, positive if left > right.
    public static int compare(ExpHistogramValue left, ExpHistogramValue right) {
        if (left == null) {
            if (right == null) {
                return 0;
            }
            return -1;
        }
        if (right == null) {
            return 1;
        }
        int c;
        
        // Compare Count field.
        c = Types.Uint64Compare(left.count, right.count);
        if (c != 0) {
            return c;
        }
        
        // Compare Sum field.
        boolean leftSumPresent = (left.optionalFieldsPresent & fieldPresentSum) != 0;
        boolean rightSumPresent = (right.optionalFieldsPresent & fieldPresentSum) != 0;
        if (leftSumPresent != rightSumPresent) {
            if (leftSumPresent) {
                return 1;
            }
            return -1;
        }
        c = Types.Float64Compare(left.sum, right.sum);
        if (c != 0) {
            return c;
        }
        
        // Compare Min field.
        boolean leftMinPresent = (left.optionalFieldsPresent & fieldPresentMin) != 0;
        boolean rightMinPresent = (right.optionalFieldsPresent & fieldPresentMin) != 0;
        if (leftMinPresent != rightMinPresent) {
            if (leftMinPresent) {
                return 1;
            }
            return -1;
        }
        c = Types.Float64Compare(left.min, right.min);
        if (c != 0) {
            return c;
        }
        
        // Compare Max field.
        boolean leftMaxPresent = (left.optionalFieldsPresent & fieldPresentMax) != 0;
        boolean rightMaxPresent = (right.optionalFieldsPresent & fieldPresentMax) != 0;
        if (leftMaxPresent != rightMaxPresent) {
            if (leftMaxPresent) {
                return 1;
            }
            return -1;
        }
        c = Types.Float64Compare(left.max, right.max);
        if (c != 0) {
            return c;
        }
        
        // Compare Scale field.
        c = Types.Int64Compare(left.scale, right.scale);
        if (c != 0) {
            return c;
        }
        
        // Compare ZeroCount field.
        c = Types.Uint64Compare(left.zeroCount, right.zeroCount);
        if (c != 0) {
            return c;
        }
        
        // Compare PositiveBuckets field.
        c = ExpHistogramBuckets.compare(left.positiveBuckets, right.positiveBuckets);
        if (c != 0) {
            return c;
        }
        
        // Compare NegativeBuckets field.
        c = ExpHistogramBuckets.compare(left.negativeBuckets, right.negativeBuckets);
        if (c != 0) {
            return c;
        }
        
        // Compare ZeroThreshold field.
        c = Types.Float64Compare(left.zeroThreshold, right.zeroThreshold);
        if (c != 0) {
            return c;
        }
        
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random as a deterministic generator.
    void mutateRandom(Random random) {
        final int fieldCount = Math.max(9,2); // At least 2 to ensure we don't recurse infinitely if there is only 1 field.
        
        if (random.nextInt(fieldCount) == 0) {
            this.setCount(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setSum(Types.Float64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setMin(Types.Float64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setMax(Types.Float64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setScale(Types.Int64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setZeroCount(Types.Uint64Random(random));
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.positiveBuckets.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.negativeBuckets.mutateRandom(random);
        }
        
        if (random.nextInt(fieldCount) == 0) {
            this.setZeroThreshold(Types.Float64Random(random));
        }
        
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return equals((ExpHistogramValue)o);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
            count,
            sum,
            min,
            max,
            scale,
            zeroCount,
            positiveBuckets,
            negativeBuckets,
            zeroThreshold
        );
    }

    
}
