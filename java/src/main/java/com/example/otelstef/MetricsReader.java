// Code generated by stefc. DO NOT EDIT.
package com.example.otelstef;

import net.stef.BaseReader;
import net.stef.FixedHeader;
import net.stef.FrameFlags;
import net.stef.ReadOptions;
import net.stef.ReadResult;
import net.stef.schema.WireSchema;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;

// MetricsReader allows reading records of Metrics
// in STEF format from an input stream.
public class MetricsReader {
    private final BaseReader base;
    private final MetricsDecoder decoder = new MetricsDecoder();
    private final ReaderState state = new ReaderState();

    // Record contains the record that was just read by the last read() operation.
    // The next read() will overwrite the record.
    // Do not modify this field externally. Modifying this field will result in
    // incorrect decoding of subsequent records.
    public final Metrics record = new Metrics();

    public MetricsReader(InputStream source) throws IOException {
        base = new BaseReader(new BufferedInputStream(source, 64 * 1024));
        initSchema();
    }

    private void initSchema() throws IOException {
        WireSchema ownSchema = Metrics.wireSchema();
        base.readVarHeader(ownSchema);
        state.init(base.getSchema());
        decoder.init(state, base.readBufs.columns);

        if (!state.getStructFieldCounts().allFetched()) {
            throw new IOException("override schema iterator is not done, decoded data schema is likely incompatible");
        }
    }

    public FixedHeader getHeader() {
        return base.fixedHeader;
    }

    public Map<String, String> getUserData() {
        return base.varHeader.getUserData();
    }

    public long getRecordCount() {
        return base.recordCount;
    }

    private void nextFrame() throws IOException {
        int frameFlags = base.nextFrame();
        if ((frameFlags & FrameFlags.RestartDictionaries) != 0) {
            // The frame that has just started indicates that the dictionaries
            // must be restarted. Reset all dictionaries.
            state.resetDicts();
        }
        if ((frameFlags & FrameFlags.RestartCodecs) != 0) {
            // The frame that has just started indicates that the decoders
            // must be restarted.
            decoder.reset();
        }
        decoder.continueDecoding();
    }

    // Read the next record. After read() returns successfully the record
    // will be accessible in MetricsReader.record field.
    //
    // If ReadOptions.tillEndOfFrame=true and end of the current
    // frame is reached read() will return EndOfFrame. Calling read()
    // after that with ReadOptions.tillEndOfFrame=false will correctly load
    // the next frame (if any) and read the next record from the frame.
    // The very first read() must use ReadOptions.tillEndOfFrame=false
    // otherwise EndOfFrameException will be thrown since no frames are
    // initially loaded in the Reader. See more details in ReadOptions.
    //
    // If read() encounters a decoding error a IOException will be thrown.
    // If underlying source InputStream throws any error then read() will
    // either throw that error or a decoding error if source InputStream
    // returned an error prematurely while more data was expected in STEF stream.
    //
    // For well-formed streams that don't encounter decoding errors read() will
    // throw EOFException once end of the underlying source InputStream is reached
    // (assuming InputStream throws EOFException itself).
    public ReadResult read(int opts) throws IOException {
        while (base.frameRecordCount == 0) {
            if ((opts&ReadOptions.tillEndOfFrame)!=0) {
                return ReadResult.EndOfFrame;
            }
            nextFrame();
        }
        base.frameRecordCount--;
        base.recordCount++;
        decoder.decode(record);
        return ReadResult.Success;
    }
}
