// Code generated by stefc. DO NOT EDIT.
// AnyValueEncoder implements encoding of AnyValue
package com.example.otelstef;

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

class AnyValueEncoder {
    private BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;
    // fieldCount is the number of fields, i.e. the number of types in this oneof.
    private int fieldCount;
    // Number of bits needed to encode the type (including None type).
    private int typeBitCount;

    // Field encoders.
    
    private StringDictEncoder stringEncoder;
    private boolean isStringRecursive = false; // Indicates String field's type is recursive.
    private BoolEncoder boolEncoder;
    private boolean isBoolRecursive = false; // Indicates Bool field's type is recursive.
    private Int64Encoder int64Encoder;
    private boolean isInt64Recursive = false; // Indicates Int64 field's type is recursive.
    private Float64Encoder float64Encoder;
    private boolean isFloat64Recursive = false; // Indicates Float64 field's type is recursive.
    private AnyValueArrayEncoder arrayEncoder;
    private boolean isArrayRecursive = false; // Indicates Array field's type is recursive.
    private KeyValueListEncoder kVListEncoder;
    private boolean isKVListRecursive = false; // Indicates KVList field's type is recursive.
    private BytesEncoder bytesEncoder;
    private boolean isBytesRecursive = false; // Indicates Bytes field's type is recursive.
    

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.AnyValueEncoder != null) {
            throw new IllegalStateException("cannot initialize AnyValueEncoder: already initialized");
        }
        state.AnyValueEncoder = this;

        try {
            this.limiter = state.getLimiter();

            this.fieldCount = state.getStructFieldCounts().getAnyValueFieldCount();
            this.typeBitCount = Integer.SIZE - Integer.numberOfLeadingZeros(this.fieldCount+1);
            
            // Init encoder for String field.
            if (this.fieldCount <= 0) {
                return; // String and subsequent fields are skipped.
            }
            stringEncoder = new StringDictEncoder();
            stringEncoder.init(state.AnyValueString, this.limiter, columns.addSubColumn());
            // Init encoder for Bool field.
            if (this.fieldCount <= 1) {
                return; // Bool and subsequent fields are skipped.
            }
            boolEncoder = new BoolEncoder();
            boolEncoder.init(this.limiter, columns.addSubColumn());
            // Init encoder for Int64 field.
            if (this.fieldCount <= 2) {
                return; // Int64 and subsequent fields are skipped.
            }
            int64Encoder = new Int64Encoder();
            int64Encoder.init(this.limiter, columns.addSubColumn());
            // Init encoder for Float64 field.
            if (this.fieldCount <= 3) {
                return; // Float64 and subsequent fields are skipped.
            }
            float64Encoder = new Float64Encoder();
            float64Encoder.init(this.limiter, columns.addSubColumn());
            // Init encoder for Array field.
            if (this.fieldCount <= 4) {
                return; // Array and subsequent fields are skipped.
            }
            if (state.AnyValueArrayEncoder != null) {
                // Recursion detected, use the existing encoder.
                arrayEncoder = state.AnyValueArrayEncoder;
                isArrayRecursive = true;
            } else {
                arrayEncoder = new AnyValueArrayEncoder();
                arrayEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for KVList field.
            if (this.fieldCount <= 5) {
                return; // KVList and subsequent fields are skipped.
            }
            if (state.KeyValueListEncoder != null) {
                // Recursion detected, use the existing encoder.
                kVListEncoder = state.KeyValueListEncoder;
                isKVListRecursive = true;
            } else {
                kVListEncoder = new KeyValueListEncoder();
                kVListEncoder.init(state, columns.addSubColumn());
            }
            // Init encoder for Bytes field.
            if (this.fieldCount <= 6) {
                return; // Bytes and subsequent fields are skipped.
            }
            bytesEncoder = new BytesEncoder();
            bytesEncoder.init(this.limiter, columns.addSubColumn());
        } finally {
            state.AnyValueEncoder = null;
        }
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            return; // String and all subsequent fields are skipped.
        }
        stringEncoder.reset();
        if (fieldCount <= 1) {
            return; // Bool and all subsequent fields are skipped.
        }
        boolEncoder.reset();
        if (fieldCount <= 2) {
            return; // Int64 and all subsequent fields are skipped.
        }
        int64Encoder.reset();
        if (fieldCount <= 3) {
            return; // Float64 and all subsequent fields are skipped.
        }
        float64Encoder.reset();
        if (fieldCount <= 4) {
            return; // Array and all subsequent fields are skipped.
        }
        
        if (!isArrayRecursive) {
            arrayEncoder.reset();
        }
        
        if (fieldCount <= 5) {
            return; // KVList and all subsequent fields are skipped.
        }
        
        if (!isKVListRecursive) {
            kVListEncoder.reset();
        }
        
        if (fieldCount <= 6) {
            return; // Bytes and all subsequent fields are skipped.
        }
        bytesEncoder.reset();
    }

    // Encode encodes val into buf
    public void encode(AnyValue val) throws IOException {
        AnyValue.Type typ = val.typ;
        if (typ.getValue() > fieldCount) {
            // The current field type is not supported in target schema. Encode the type as None.
            typ = AnyValue.Type.TypeNone;
        }

        // Compute type delta. 0 means the type is the same as the last time.
        buf.writeBits(typ.getValue(), typeBitCount);

        // Account written bits in the limiter.
        limiter.addFrameBits(typeBitCount);

        // Encode currently selected field.
        switch (typ) {
        case TypeString:
            // Encode String
            stringEncoder.encode(val.string);
            break;
        case TypeBool:
            // Encode Bool
            boolEncoder.encode(val.bool);
            break;
        case TypeInt64:
            // Encode Int64
            int64Encoder.encode(val.int64);
            break;
        case TypeFloat64:
            // Encode Float64
            float64Encoder.encode(val.float64);
            break;
        case TypeArray:
            // Encode Array
            arrayEncoder.encode(val.array);
            break;
        case TypeKVList:
            // Encode KVList
            kVListEncoder.encode(val.kVList);
            break;
        case TypeBytes:
            // Encode Bytes
            bytesEncoder.encode(val.bytes);
            break;
        }
    }

    // collectColumns collects all buffers from all encoders into buf.
    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(this.buf);
        int colIdx = 0;
        
        // Collect String field.
        if (this.fieldCount <= 0) {
            return; // String and subsequent fields are skipped.
        }
        
        stringEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Bool field.
        if (this.fieldCount <= 1) {
            return; // Bool and subsequent fields are skipped.
        }
        
        boolEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Int64 field.
        if (this.fieldCount <= 2) {
            return; // Int64 and subsequent fields are skipped.
        }
        
        int64Encoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Float64 field.
        if (this.fieldCount <= 3) {
            return; // Float64 and subsequent fields are skipped.
        }
        
        float64Encoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
        // Collect Array field.
        if (this.fieldCount <= 4) {
            return; // Array and subsequent fields are skipped.
        }
        if (!isArrayRecursive) {
            arrayEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect KVList field.
        if (this.fieldCount <= 5) {
            return; // KVList and subsequent fields are skipped.
        }
        if (!isKVListRecursive) {
            kVListEncoder.collectColumns(columnSet.at(colIdx));
            colIdx++;
        }
        
        // Collect Bytes field.
        if (this.fieldCount <= 6) {
            return; // Bytes and subsequent fields are skipped.
        }
        
        bytesEncoder.collectColumns(columnSet.at(colIdx));
        colIdx++;
        
    }
}
