// Code generated by stefc. DO NOT EDIT.
// SpanDecoder implements decoding of Span
package com.example.otelstef;

import net.stef.BitsReader;
import net.stef.Helper;
import net.stef.ReadColumnSet;
import net.stef.ReadableColumn;
import net.stef.codecs.*;

import java.io.IOException;

class SpanDecoder {
    private final BitsReader buf = new BitsReader();
    private ReadableColumn column;
    private int fieldCount;
    

    
    private BytesDecoder traceIDDecoder;
    private boolean isTraceIDRecursive = false; // Indicates TraceID field's type is recursive.
    private BytesDecoder spanIDDecoder;
    private boolean isSpanIDRecursive = false; // Indicates SpanID field's type is recursive.
    private StringDecoder traceStateDecoder;
    private boolean isTraceStateRecursive = false; // Indicates TraceState field's type is recursive.
    private BytesDecoder parentSpanIDDecoder;
    private boolean isParentSpanIDRecursive = false; // Indicates ParentSpanID field's type is recursive.
    private Uint64Decoder flagsDecoder;
    private boolean isFlagsRecursive = false; // Indicates Flags field's type is recursive.
    private StringDictDecoder nameDecoder;
    private boolean isNameRecursive = false; // Indicates Name field's type is recursive.
    private Uint64Decoder kindDecoder;
    private boolean isKindRecursive = false; // Indicates Kind field's type is recursive.
    private Uint64Decoder startTimeUnixNanoDecoder;
    private boolean isStartTimeUnixNanoRecursive = false; // Indicates StartTimeUnixNano field's type is recursive.
    private Uint64Decoder endTimeUnixNanoDecoder;
    private boolean isEndTimeUnixNanoRecursive = false; // Indicates EndTimeUnixNano field's type is recursive.
    private AttributesDecoder attributesDecoder;
    private boolean isAttributesRecursive = false; // Indicates Attributes field's type is recursive.
    private Uint64Decoder droppedAttributesCountDecoder;
    private boolean isDroppedAttributesCountRecursive = false; // Indicates DroppedAttributesCount field's type is recursive.
    private EventArrayDecoder eventsDecoder;
    private boolean isEventsRecursive = false; // Indicates Events field's type is recursive.
    private LinkArrayDecoder linksDecoder;
    private boolean isLinksRecursive = false; // Indicates Links field's type is recursive.
    private SpanStatusDecoder statusDecoder;
    private boolean isStatusRecursive = false; // Indicates Status field's type is recursive.
    

    // Init is called once in the lifetime of the stream.
    public void init(ReaderState state, ReadColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.SpanDecoder != null) {
            throw new IllegalStateException("cannot initialize SpanDecoder: already initialized");
        }
        state.SpanDecoder = this;

        try {
            fieldCount = state.getStructFieldCounts().getSpanFieldCount();
            column = columns.getColumn();
            
            if (this.fieldCount <= 0) {
                return; // TraceID and subsequent fields are skipped.
            }
            traceIDDecoder = new BytesDecoder();
            traceIDDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 1) {
                return; // SpanID and subsequent fields are skipped.
            }
            spanIDDecoder = new BytesDecoder();
            spanIDDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 2) {
                return; // TraceState and subsequent fields are skipped.
            }
            traceStateDecoder = new StringDecoder();
            traceStateDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 3) {
                return; // ParentSpanID and subsequent fields are skipped.
            }
            parentSpanIDDecoder = new BytesDecoder();
            parentSpanIDDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 4) {
                return; // Flags and subsequent fields are skipped.
            }
            flagsDecoder = new Uint64Decoder();
            flagsDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 5) {
                return; // Name and subsequent fields are skipped.
            }
            nameDecoder = new StringDictDecoder();
            nameDecoder.init(state.SpanName, columns.addSubColumn());
            if (this.fieldCount <= 6) {
                return; // Kind and subsequent fields are skipped.
            }
            kindDecoder = new Uint64Decoder();
            kindDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 7) {
                return; // StartTimeUnixNano and subsequent fields are skipped.
            }
            startTimeUnixNanoDecoder = new Uint64Decoder();
            startTimeUnixNanoDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 8) {
                return; // EndTimeUnixNano and subsequent fields are skipped.
            }
            endTimeUnixNanoDecoder = new Uint64Decoder();
            endTimeUnixNanoDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 9) {
                return; // Attributes and subsequent fields are skipped.
            }
            if (state.AttributesDecoder != null) {
                // Recursion detected, use the existing decoder.
                attributesDecoder = state.AttributesDecoder;
                isAttributesRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                attributesDecoder = new AttributesDecoder();
                attributesDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 10) {
                return; // DroppedAttributesCount and subsequent fields are skipped.
            }
            droppedAttributesCountDecoder = new Uint64Decoder();
            droppedAttributesCountDecoder.init(columns.addSubColumn());
            if (this.fieldCount <= 11) {
                return; // Events and subsequent fields are skipped.
            }
            if (state.EventArrayDecoder != null) {
                // Recursion detected, use the existing decoder.
                eventsDecoder = state.EventArrayDecoder;
                isEventsRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                eventsDecoder = new EventArrayDecoder();
                eventsDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 12) {
                return; // Links and subsequent fields are skipped.
            }
            if (state.LinkArrayDecoder != null) {
                // Recursion detected, use the existing decoder.
                linksDecoder = state.LinkArrayDecoder;
                isLinksRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                linksDecoder = new LinkArrayDecoder();
                linksDecoder.init(state, columns.addSubColumn());
            }
            if (this.fieldCount <= 13) {
                return; // Status and subsequent fields are skipped.
            }
            if (state.SpanStatusDecoder != null) {
                // Recursion detected, use the existing decoder.
                statusDecoder = state.SpanStatusDecoder;
                isStatusRecursive = true; // Mark that we are using a recursive decoder.
            } else {
                statusDecoder = new SpanStatusDecoder();
                statusDecoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.SpanDecoder = null;
        }
    }

    // continueDecoding is called at the start of the frame to continue decoding column data.
    // This should set the decoder's source buffer, so the new decoding continues from
    // the supplied column data. This should NOT reset the internal state of the decoder,
    // since columns can cross frame boundaries and the new column data is considered
    // continuation of that same column in the previous frame.
    public void continueDecoding() {
        this.buf.reset(this.column.getData());
        
        if (this.fieldCount <= 0) {
            return; // TraceID and subsequent fields are skipped.
        }
        traceIDDecoder.continueDecoding();
        if (this.fieldCount <= 1) {
            return; // SpanID and subsequent fields are skipped.
        }
        spanIDDecoder.continueDecoding();
        if (this.fieldCount <= 2) {
            return; // TraceState and subsequent fields are skipped.
        }
        traceStateDecoder.continueDecoding();
        if (this.fieldCount <= 3) {
            return; // ParentSpanID and subsequent fields are skipped.
        }
        parentSpanIDDecoder.continueDecoding();
        if (this.fieldCount <= 4) {
            return; // Flags and subsequent fields are skipped.
        }
        flagsDecoder.continueDecoding();
        if (this.fieldCount <= 5) {
            return; // Name and subsequent fields are skipped.
        }
        nameDecoder.continueDecoding();
        if (this.fieldCount <= 6) {
            return; // Kind and subsequent fields are skipped.
        }
        kindDecoder.continueDecoding();
        if (this.fieldCount <= 7) {
            return; // StartTimeUnixNano and subsequent fields are skipped.
        }
        startTimeUnixNanoDecoder.continueDecoding();
        if (this.fieldCount <= 8) {
            return; // EndTimeUnixNano and subsequent fields are skipped.
        }
        endTimeUnixNanoDecoder.continueDecoding();
        if (this.fieldCount <= 9) {
            return; // Attributes and subsequent fields are skipped.
        }
        
        if (!isAttributesRecursive) {
            attributesDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 10) {
            return; // DroppedAttributesCount and subsequent fields are skipped.
        }
        droppedAttributesCountDecoder.continueDecoding();
        if (this.fieldCount <= 11) {
            return; // Events and subsequent fields are skipped.
        }
        
        if (!isEventsRecursive) {
            eventsDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 12) {
            return; // Links and subsequent fields are skipped.
        }
        
        if (!isLinksRecursive) {
            linksDecoder.continueDecoding();
        }
        
        if (this.fieldCount <= 13) {
            return; // Status and subsequent fields are skipped.
        }
        
        if (!isStatusRecursive) {
            statusDecoder.continueDecoding();
        }
        
    }

    public void reset() {
        
        if (fieldCount <= 0) {
            // TraceID and all subsequent fields are skipped.
            return;
        }
        traceIDDecoder.reset();
        if (fieldCount <= 1) {
            // SpanID and all subsequent fields are skipped.
            return;
        }
        spanIDDecoder.reset();
        if (fieldCount <= 2) {
            // TraceState and all subsequent fields are skipped.
            return;
        }
        traceStateDecoder.reset();
        if (fieldCount <= 3) {
            // ParentSpanID and all subsequent fields are skipped.
            return;
        }
        parentSpanIDDecoder.reset();
        if (fieldCount <= 4) {
            // Flags and all subsequent fields are skipped.
            return;
        }
        flagsDecoder.reset();
        if (fieldCount <= 5) {
            // Name and all subsequent fields are skipped.
            return;
        }
        nameDecoder.reset();
        if (fieldCount <= 6) {
            // Kind and all subsequent fields are skipped.
            return;
        }
        kindDecoder.reset();
        if (fieldCount <= 7) {
            // StartTimeUnixNano and all subsequent fields are skipped.
            return;
        }
        startTimeUnixNanoDecoder.reset();
        if (fieldCount <= 8) {
            // EndTimeUnixNano and all subsequent fields are skipped.
            return;
        }
        endTimeUnixNanoDecoder.reset();
        if (fieldCount <= 9) {
            // Attributes and all subsequent fields are skipped.
            return;
        }
        if (!isAttributesRecursive) {
            attributesDecoder.reset();
        }
        if (fieldCount <= 10) {
            // DroppedAttributesCount and all subsequent fields are skipped.
            return;
        }
        droppedAttributesCountDecoder.reset();
        if (fieldCount <= 11) {
            // Events and all subsequent fields are skipped.
            return;
        }
        if (!isEventsRecursive) {
            eventsDecoder.reset();
        }
        if (fieldCount <= 12) {
            // Links and all subsequent fields are skipped.
            return;
        }
        if (!isLinksRecursive) {
            linksDecoder.reset();
        }
        if (fieldCount <= 13) {
            // Status and all subsequent fields are skipped.
            return;
        }
        if (!isStatusRecursive) {
            statusDecoder.reset();
        }
    }

    public Span decode(Span dstPtr) throws IOException {
        Span val = dstPtr;
        // Read bits that indicate which fields follow.
        val.modifiedFields.mask = buf.readBits(fieldCount);
        
        
        if ((val.modifiedFields.mask & Span.fieldModifiedTraceID) != 0) {
            // Field is changed.
                val.traceID = traceIDDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedSpanID) != 0) {
            // Field is changed.
                val.spanID = spanIDDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedTraceState) != 0) {
            // Field is changed.
                val.traceState = traceStateDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedParentSpanID) != 0) {
            // Field is changed.
                val.parentSpanID = parentSpanIDDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedFlags) != 0) {
            // Field is changed.
                val.flags = flagsDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedName) != 0) {
            // Field is changed.
                val.name = nameDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedKind) != 0) {
            // Field is changed.
                val.kind = kindDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedStartTimeUnixNano) != 0) {
            // Field is changed.
                val.startTimeUnixNano = startTimeUnixNanoDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedEndTimeUnixNano) != 0) {
            // Field is changed.
                val.endTimeUnixNano = endTimeUnixNanoDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedAttributes) != 0) {
            // Field is changed.
                if (val.attributes == null) {
                    val.attributes = new Attributes(val.modifiedFields, Span.fieldModifiedAttributes);
                }
                val.attributes = attributesDecoder.decode(val.attributes);
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedDroppedAttributesCount) != 0) {
            // Field is changed.
                val.droppedAttributesCount = droppedAttributesCountDecoder.decode();
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedEvents) != 0) {
            // Field is changed.
                if (val.events == null) {
                    val.events = new EventArray(val.modifiedFields, Span.fieldModifiedEvents);
                }
                val.events = eventsDecoder.decode(val.events);
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedLinks) != 0) {
            // Field is changed.
                if (val.links == null) {
                    val.links = new LinkArray(val.modifiedFields, Span.fieldModifiedLinks);
                }
                val.links = linksDecoder.decode(val.links);
        }
        
        if ((val.modifiedFields.mask & Span.fieldModifiedStatus) != 0) {
            // Field is changed.
                if (val.status == null) {
                    val.status = new SpanStatus(val.modifiedFields, Span.fieldModifiedStatus);
                }
                val.status = statusDecoder.decode(val.status);
        }
        
        
        return val;
    }
}

