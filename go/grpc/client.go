package stefgrpc

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/schema"

	"github.com/splunk/stef/go/grpc/internal"
	"github.com/splunk/stef/go/grpc/stef_proto"
	"github.com/splunk/stef/go/grpc/types"
)

type ClientCallbacks struct {
	// OnDisconnect is called when the stream is disconnected.
	OnDisconnect func(err error)

	// Callback when an ack is received from the server.
	// Return error will result in disconnecting the stream.
	OnAck func(ackId uint64) error
}

// Client is a client for communicating over STEF/gRPC protocol.
type Client struct {
	grpcClient   stef_proto.STEFDestinationClient
	stream       stef_proto.STEFDestination_StreamClient
	callbacks    ClientCallbacks
	clientSchema ClientSchema
	logger       types.Logger

	// Running state
	waitCh     chan struct{}
	cancelFunc context.CancelFunc
}

// SendError will be returned by Client's sending functions. It may get wrapped by
// STEF writers, but can be checked via errors.Is(err, stefgrpc.SendError{})
// and is useful for distinguishing gRPC connection (sending) errors that are
// transient and can be retried, from STEF encoding errors which are permanent and
// should not be retried.
type SendError struct {
	err error
}

var _ error = (*SendError)(nil)

func (e SendError) Error() string {
	return "stefgrpc write error: " + e.err.Error()
}

func (e SendError) Unwrap() error { return e.err }

func (e SendError) Is(target error) bool {
	switch target.(type) {
	case SendError:
		return true
	default:
		return false
	}
}

type grpcWriter struct {
	stream  stef_proto.STEFDestination_StreamClient
	request stef_proto.STEFClientMessage
	onAck   func(ackId uint64)
}

func (w *grpcWriter) WriteChunk(header []byte, content []byte) error {
	w.request.StefBytes = w.request.StefBytes[:0]
	w.request.StefBytes = append(w.request.StefBytes, header...)
	w.request.StefBytes = append(w.request.StefBytes, content...)
	w.request.IsEndOfChunk = true

	// TODO: split the chunk into multiple messages if it is too big to fit in one gRPC message.

	if err := w.stream.Send(&w.request); err != nil {
		return SendError{err: err}
	}
	return nil
}

var ErrServerInvalidResponse = errors.New("invalid server response")

// ClientSettings contains configuration settings for creating a Client.
type ClientSettings struct {
	// Logger instance used for logging client operations.
	Logger types.Logger

	// gRPC stream to send data over.
	GrpcClient stef_proto.STEFDestinationClient

	// ClientSchema of the client.
	ClientSchema ClientSchema

	// Callbacks for handling events such as acknowledgments and disconnections.
	Callbacks ClientCallbacks
}

// ClientSchema defines the schema configuration for a STEF gRPC client.
//
// During connection establishment, the client's schema is compared with the server's
// schema to determine compatibility.
type ClientSchema struct {
	// RootStructName specifies the name of the root struct in the STEF schema.
	//
	// This must match the name of the root struct defined in your .stef schema file
	// and is sent to the server during the initial handshake to identify the
	// root struct being transmitted. This is necessary since one schema may contain
	// multiple root structs.
	//
	// Required: This field must not be empty when creating a client.
	RootStructName string

	// WireSchema contains the serialized schema information used for compatibility
	// checking between client and server.
	//
	// The WireSchema is generated by STEF compiler.
	//
	// Required: This field must not be nil when creating a client.
	WireSchema *schema.WireSchema
}

// NewClient creates a new instance of the Client.
//
// Requirements:
// - The `RootStructName` in `ClientSchema` must not be empty.
// - The `WireSchema` in `ClientSchema` must not be nil.
//
// Example:
//
//	clientSettings := stefgrpc.ClientSettings{
//	    GrpcClient:   grpcClient,
//	    ClientSchema: stefgrpc.ClientSchema{RootStructName: "Metrics", WireSchema: &schema},
//	    Callbacks:    stefgrpc.ClientCallbacks{},
//	}
//	client, err := stefgrpc.NewClient(clientSettings)
//	if err != nil {
//	    log.Fatalf("Failed to create client: %v", err)
//	}
func NewClient(settings ClientSettings) (*Client, error) {
	if settings.Logger == nil {
		settings.Logger = internal.NopLogger{}
	}

	if settings.Callbacks.OnDisconnect == nil {
		settings.Callbacks.OnDisconnect = func(err error) {}
	}

	if settings.ClientSchema.RootStructName == "" {
		return nil, fmt.Errorf("client schema root struct name is empty")
	}
	if settings.ClientSchema.WireSchema == nil {
		return nil, fmt.Errorf("client schema wire schema is nil")
	}

	client := &Client{
		grpcClient:   settings.GrpcClient,
		callbacks:    settings.Callbacks,
		clientSchema: settings.ClientSchema,
		logger:       settings.Logger,
		waitCh:       make(chan struct{}),
	}

	return client, nil
}

// Connect establishes a bidirectional gRPC stream connection with the STEF server
// and performs the initial handshake to negotiate protocol capabilities and schema compatibility.
//
// The method performs the following steps:
//  1. Establishes a gRPC stream.
//  2. Sends the initial client message containing the root struct name.
//  3. Receives server capabilities including dictionary limits and server wire schema for specified root struct.
//  4. Performs schema compatibility checks between client and server schemas.
//  5. Configures writer options based on compatibility results. The writer will downgrade to the server schema
//     if client's schema is a superset of server's schema.
//  6. Starts a background goroutine to receive messages from the server. This will result in
//     calling OnAck and OnDisconnect callbacks as appropriate.
//
// Parameters:
//   - ctx: Context for controlling the connection attempt. When cancelled, it will
//     stop connection attempt and return an error.
//
// Returns:
//   - ChunkWriter: A STEF Writer can be created over chunk writer to send STEF data over gRPC connection.
//   - WriterOptions: Configuration options for the writer, including schema settings
//     and dictionary limits determined during the handshake.
//
// The method handles three schema compatibility scenarios:
//   - Exact match: Client and server schemas are identical. No special handling needed.
//   - Server superset: Server schema contains all client fields plus additional ones;
//     client must include its schema descriptor in the STEF header and the server
//     knows how to correctly decode the data based on the client schema.
//   - Client superset: Client schema contains all server fields plus additional ones;
//     client's Writer will downgrade its schema to match server's schema.
//   - Incompatible: client and server schemas are incompatible, connection will fail.
//
// The returned ChunkWriter and the WriterOptions should be used to create a root struct Writer
// and start writing STEF data to it. Writer's Write() calls will send data over the established gRPC stream.
//
// Example:
//
//		chunkWriter, opts, err := client.Connect(ctx)
//		if err != nil {
//		    return fmt.Errorf("failed to connect: %w", err)
//		}
//		defer client.Disconnect(ctx)
//
//		// Optionally adjust writer options, e.g., set compression
//		opts.Compression = pkg.CompressionZstd
//
//		// Use writer with the returned options...
//		stefWriter, err := mystefschema.NewMyRootStructWriter(chunkWriter, opts)
//
//	 stef.Write... (handle errors, etc)
func (c *Client) Connect(ctx context.Context) (pkg.ChunkWriter, pkg.WriterOptions, error) {
	c.logger.Debugf(context.Background(), "Begin connecting (client=%p)", c)

	opts := pkg.WriterOptions{}

	ctx, cancelFunc := context.WithCancel(ctx)
	c.cancelFunc = cancelFunc

	stream, err := c.grpcClient.Stream(ctx)
	if err != nil {
		return nil, opts, fmt.Errorf("failed to gRPC stream: %w", err)
	}

	c.stream = stream

	isError := true
	closeOnErr := func() {
		if isError {
			if err := stream.CloseSend(); err != nil {
				c.logger.Debugf(ctx, "CloseSend failed: %v", err)
			}
		}
	}
	defer closeOnErr()

	// Send the first message to the server, include the root struct name.
	clientMsg := &stef_proto.STEFClientFirstMessage{
		RootStructName: c.clientSchema.RootStructName,
	}
	err = stream.Send(
		&stef_proto.STEFClientMessage{
			FirstMessage: clientMsg,
		},
	)
	if err != nil {
		return nil, opts, fmt.Errorf("failed to send to server: %w", err)
	}

	// The server must send capabilities message.
	message, err := stream.Recv()
	if err != nil {
		return nil, opts, fmt.Errorf("error received from server: %w", err)
	}

	capabilities, ok := message.Message.(*stef_proto.STEFServerMessage_Capabilities)
	if !ok || capabilities == nil || capabilities.Capabilities == nil {
		return nil, opts, ErrServerInvalidResponse
	}

	// Apply dictionary limits.
	if capabilities.Capabilities.DictionaryLimits != nil {
		opts.MaxTotalDictSize = uint(capabilities.Capabilities.DictionaryLimits.MaxDictBytes)
	}

	// Unmarshal server schema.
	var serverSchema schema.WireSchema
	buf := bytes.NewBuffer(capabilities.Capabilities.Schema)
	err = serverSchema.Deserialize(buf)
	if err != nil {
		return nil, opts, fmt.Errorf("failed to unmarshal capabilities schema: %w", err)
	}

	// Check if server schema is backward compatible with client schema.
	compatibility, err := serverSchema.Compatible(c.clientSchema.WireSchema)
	switch compatibility {
	case schema.CompatibilityExact:
		// Schemas match exactly, nothing else is needed, can start sending data.

	case schema.CompatibilitySuperset:
		// ServerStream schema is superset of client schema. The client MUST specify its schema
		// in the STEF header.
		opts.IncludeDescriptor = true
		opts.Schema = c.clientSchema.WireSchema

	case schema.CompatibilityIncompatible:
		// It is neither exact match nor is server schema a superset, but server schema maybe subset.
		// Check the opposite direction: if client schema is backward compatible with server schema.
		compatibility, err = c.clientSchema.WireSchema.Compatible(&serverSchema)

		if err != nil || compatibility == schema.CompatibilityIncompatible {
			return nil, opts, fmt.Errorf("client and server schemas are incompatble: %w", err)
		}

		if compatibility == schema.CompatibilitySuperset {
			// Client schema is superset of server schema. The client MUST downgrade its schema.
			opts.IncludeDescriptor = true
			opts.Schema = c.clientSchema.WireSchema
		}
	}

	isError = false

	writer := &grpcWriter{
		stream: stream,
	}
	go c.receive()

	return writer, opts, nil
}

// Disconnect shuts down the gRPC connection.
//
// It cancels the stream, terminates the background receive goroutine,
// and waits for the goroutine to finish.
//
// Parameters:
//   - ctx: Context for controlling the disconnect timeout. If the context
//     is cancelled or times out before the receive goroutine finishes,
//     the method returns the context error.
//
// Returns:
//   - error: Returns ctx.Err() if the context is cancelled/times out before
//     the disconnect completes, otherwise returns nil on success.
//
// This method should be called to properly clean up resources when the
// client is no longer needed.
func (c *Client) Disconnect(ctx context.Context) error {
	// This will cancel and close the stream and terminate receive() method.
	c.cancelFunc()

	// Wait until receive() ends.
	select {
	case <-c.waitCh:
	case <-ctx.Done():
		return ctx.Err()
	}
	return nil
}

func (c *Client) receive() {
	defer close(c.waitCh)

	c.logger.Debugf(context.Background(), "Begin receiving acks (client=%p)", c)

	for {
		resp, err := c.stream.Recv()
		if err != nil {
			if err == io.EOF {
				c.callbacks.OnDisconnect(nil)
				return
			}
			c.logger.Errorf(context.Background(), "Error receiving acks: %v (client=%p)", err, c)
			c.callbacks.OnDisconnect(err)
			return
		}

		err = c.callbacks.OnAck(resp.Message.(*stef_proto.STEFServerMessage_Response).Response.AckRecordId)
		if err != nil {
			c.callbacks.OnDisconnect(err)
			return
		}
	}
}
