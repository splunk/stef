// Code generated by stefgen. DO NOT EDIT.
package oteltef

import (
	"math/rand/v2"

	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
)

var _ = encoders.StringEncoder{}

// AnyValueArray is a variable size array.
type AnyValueArray struct {
	elems []*AnyValue

	parentModifiedFields *modifiedFields
	parentModifiedBit    uint64
}

func (e *AnyValueArray) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	e.parentModifiedFields = parentModifiedFields
	e.parentModifiedBit = parentModifiedBit
}

// Clone() creates a deep copy of AnyValueArray
func (e *AnyValueArray) Clone() AnyValueArray {
	var clone AnyValueArray
	copyAnyValueArray(&clone, e)
	return clone
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (e *AnyValueArray) byteSize() uint {
	if len(e.elems) == 0 {
		return 0
	}
	// TODO: add size of elements if they are clonable.
	size := uint(unsafe.Sizeof(e.elems[0]))*uint(len(e.elems)) + uint(unsafe.Sizeof(e))

	for i := range e.elems {
		size += e.elems[i].byteSize()
	}
	return size
}

// Append a new element at the end of the array.
func (e *AnyValueArray) Append(val *AnyValue) {
	e.elems = append(e.elems, val)
	e.markModified()
}

func (e *AnyValueArray) markModified() {
	e.parentModifiedFields.markModified(e.parentModifiedBit)
}

func (e *AnyValueArray) markUnmodified() {
	e.parentModifiedFields.markUnmodified()
}

func (e *AnyValueArray) markUnmodifiedRecursively() {
	for i := 0; i < len(e.elems); i++ {
		e.elems[i].markUnmodifiedRecursively()
	}

}

func copyAnyValueArray(dst *AnyValueArray, src *AnyValueArray) {
	if len(dst.elems) != len(src.elems) {
		dst.elems = pkg.EnsureLen(dst.elems, len(src.elems))
		dst.markModified()
	}
	if len(src.elems) > 0 {
		// Allocate all elements at once.
		elems := make([]AnyValue, len(src.elems))
		for i := range src.elems {
			// Init the element.
			elems[i].init(dst.parentModifiedFields, dst.parentModifiedBit)
			// Point to allocated element.
			dst.elems[i] = &elems[i]
			// Copy the element.
			copyAnyValue(dst.elems[i], src.elems[i])
		}
	}
}

// Len returns the number of elements in the array.
func (e *AnyValueArray) Len() int {
	return len(e.elems)
}

// At returns element at index i.
func (m *AnyValueArray) At(i int) *AnyValue {
	return m.elems[i]
}

// EnsureLen ensures the length of the array is equal to newLen.
// It will grow or shrink the array if needed.
func (e *AnyValueArray) EnsureLen(newLen int) {
	oldLen := len(e.elems)
	if newLen > oldLen {
		// Grow the array
		e.elems = append(e.elems, make([]*AnyValue, newLen-oldLen)...)
		e.markModified()
		// Initialize newlly added elements.
		for ; oldLen < newLen; oldLen++ {
			e.elems[oldLen] = new(AnyValue)
			e.elems[oldLen].init(e.parentModifiedFields, e.parentModifiedBit)
		}
	} else if oldLen > newLen {
		// Shrink it
		e.elems = e.elems[:newLen]
		e.markModified()
	}
}

// IsEqual performs deep comparison and returns true if array is equal to val.
func (e *AnyValueArray) IsEqual(val *AnyValueArray) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		if !e.elems[i].IsEqual(val.elems[i]) {
			return false
		}
	}
	return true
}

// CmpAnyValueArray performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func CmpAnyValueArray(left, right *AnyValueArray) int {
	c := len(left.elems) - len(right.elems)
	if c != 0 {
		return c
	}
	for i := range left.elems {
		fc := CmpAnyValue(left.elems[i], right.elems[i])
		if fc < 0 {
			return -1
		}
		if fc > 0 {
			return 1
		}
	}
	return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator.
func (a *AnyValueArray) mutateRandom(random *rand.Rand) {
	if random.IntN(20) == 0 {
		a.EnsureLen(a.Len() + 1)
	}
	if random.IntN(20) == 0 && a.Len() > 0 {
		a.EnsureLen(a.Len() - 1)
	}

	for i := range a.elems {
		_ = i
		if random.IntN(2*len(a.elems)) == 0 {
			a.elems[i].mutateRandom(random)
		}
	}
}

type AnyValueArrayEncoder struct {
	buf     pkg.BitsWriter
	limiter *pkg.SizeLimiter
	encoder *AnyValueEncoder
	prevLen int
	state   *WriterState
	lastVal AnyValue
}

func (e *AnyValueArrayEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	e.state = state
	e.limiter = &state.limiter
	e.encoder = state.AnyValueEncoder

	e.lastVal.init(nil, 0)
	return nil
}

func (e *AnyValueArrayEncoder) Reset() {
	e.prevLen = 0
}

func (e *AnyValueArrayEncoder) Encode(arr *AnyValueArray) {
	newLen := len(arr.elems)
	oldBitLen := e.buf.BitCount()

	lenDelta := newLen - e.prevLen
	e.prevLen = newLen
	e.buf.WriteVarintCompact(int64(lenDelta))

	for i := 0; i < newLen; i++ {
		// Copy into last encoded value. This will correctly set "modified" field flags.
		copyAnyValue(&e.lastVal, arr.elems[i])
		// Encode it.
		e.encoder.Encode(&e.lastVal)
		// Reset modified flags so that next modification attempt correctly sets
		// the modified flags and the next encoding attempt is not skipped.
		// Normally the flags would be reset by encoder.Encode() call above, but
		// since we are passing e.lastVal to it, it will not reset the flags in the elems,
		// so we have to do it explicitly.
		arr.elems[i].markUnmodified()
	}

	// Account written bits in the limiter.
	newBitLen := e.buf.BitCount()
	e.limiter.AddFrameBits(newBitLen - oldBitLen)
}

func (e *AnyValueArrayEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)
}

type AnyValueArrayDecoder struct {
	buf        pkg.BitsReader
	column     *pkg.ReadableColumn
	decoder    *AnyValueDecoder
	prevLen    int
	lastVal    AnyValue
	lastValPtr *AnyValue
}

// Init is called once in the lifetime of the stream.
func (d *AnyValueArrayDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	d.column = columns.Column()
	d.decoder = state.AnyValueDecoder

	d.lastVal.init(nil, 0)
	d.lastValPtr = &d.lastVal

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *AnyValueArrayDecoder) Continue() {
	d.buf.Reset(d.column.Data())
}

func (d *AnyValueArrayDecoder) Reset() {
	d.decoder.Reset()
}

func (d *AnyValueArrayDecoder) Decode(dst *AnyValueArray) error {
	lenDelta, err := d.buf.ReadVarintCompact()
	if err != nil {
		return err
	}

	newLen := d.prevLen + int(lenDelta)

	dst.EnsureLen(newLen)

	d.prevLen = newLen

	for i := 0; i < newLen; i++ {
		err = d.decoder.Decode(d.lastValPtr)
		if err != nil {
			return err
		}
		copyAnyValue(dst.elems[i], d.lastValPtr)
	}

	return nil
}
