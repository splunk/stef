// Code generated by stefgen. DO NOT EDIT.
package oteltef

import (
	"math/rand/v2"
	"strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

// EnvelopeAttributes is a multimap, (aka an associative array or a list) of key value
// pairs from string to Bytes.
type EnvelopeAttributes struct {
	elems       []EnvelopeAttributesElem
	initedCount int

	modifiedElems modifiedFieldsMultimap
}

type EnvelopeAttributesElem struct {
	key   string
	value pkg.Bytes
}

func (e *EnvelopeAttributesElem) Key() string {
	return e.key
}

func (e *EnvelopeAttributesElem) Value() pkg.Bytes {
	return e.value
}

func (m *EnvelopeAttributes) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	m.modifiedElems.init(parentModifiedFields, parentModifiedBit)
}

// reset the multimap to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (m *EnvelopeAttributes) reset() {
	m.elems = m.elems[:0]
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (m *EnvelopeAttributes) fixParent(parentModifiedFields *modifiedFields) {
	m.modifiedElems.fixParent(parentModifiedFields)
}

// Clone() creates a deep copy of EnvelopeAttributes
func (m *EnvelopeAttributes) Clone() EnvelopeAttributes {
	clone := EnvelopeAttributes{}
	copyEnvelopeAttributes(&clone, m)
	return clone
}

// Len returns the number of elements in the multimap.
func (m *EnvelopeAttributes) Len() int {
	return len(m.elems)
}

// At returns element at index i.
func (m *EnvelopeAttributes) At(i int) *EnvelopeAttributesElem {
	return &m.elems[i]
}

// EnsureLen ensures the length of the multimap is equal to newLen.
// It will grow or shrink the multimap if needed.
func (m *EnvelopeAttributes) EnsureLen(newLen int) {
	oldLen := len(m.elems)
	if newLen != oldLen {
		m.modifiedElems.changeLen(oldLen, newLen)

		// Check if the underlying array is reallocated.
		beforePtr := unsafe.SliceData(m.elems)
		m.elems = pkg.EnsureLen(m.elems, newLen)
		if beforePtr != unsafe.SliceData(m.elems) {
			// Underlying array was reallocated, we need to fix parent pointers
			// in all elements.
			for i := 0; i < newLen; i++ {
			}
		}

		// Init elements with pointers to the parent struct.
		for i := m.initedCount; i < newLen; i++ {
		}
		if m.initedCount < newLen {
			m.initedCount = newLen
		}
		for i := min(oldLen, newLen); i < newLen; i++ {
		}
	}
}

func (m *EnvelopeAttributes) markModifiedRecursively() {
	for i := 0; i < len(m.elems); i++ {
	}
}

func (m *EnvelopeAttributes) markUnmodifiedRecursively() {
	for i := 0; i < len(m.elems); i++ {
	}
	m.modifiedElems.markUnmodifiedAll()
}

func (m *EnvelopeAttributes) Append(k string, v pkg.Bytes) {
	l := len(m.elems)
	m.modifiedElems.changeLen(l, l+1)
	m.elems = append(m.elems, EnvelopeAttributesElem{key: k, value: v})
}

// SetKey sets the key of the element at index i.
func (m *EnvelopeAttributes) SetKey(i int, k string) {
	if m.elems[i].key != k {
		m.elems[i].key = k
		m.modifiedElems.markKeyModified(i)
	}
}

// SetValue sets the value of the element at index i.
func (m *EnvelopeAttributes) SetValue(i int, v pkg.Bytes) {
	if !pkg.BytesEqual(m.elems[i].value, v) {
		m.elems[i].value = v
		m.modifiedElems.markValModified(i)
	}
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (m *EnvelopeAttributes) byteSize() uint {
	return uint(unsafe.Sizeof(EnvelopeAttributesElem{}))*uint(len(m.elems)) + uint(unsafe.Sizeof(m.elems))
}

func copyEnvelopeAttributes(dst *EnvelopeAttributes, src *EnvelopeAttributes) {
	if len(dst.elems) != len(src.elems) {
		dst.EnsureLen(len(src.elems))
	}

	for i := 0; i < len(src.elems); i++ {
		if dst.elems[i].key != src.elems[i].key {
			dst.elems[i].key = src.elems[i].key
			dst.modifiedElems.markKeyModified(i)
		}

		if dst.elems[i].value != src.elems[i].value {
			dst.elems[i].value = src.elems[i].value
			dst.modifiedElems.markValModified(i)
		}

	}
}

func (m *EnvelopeAttributes) CopyFrom(src *EnvelopeAttributes) {
	copyEnvelopeAttributes(m, src)
}

func (e *EnvelopeAttributes) IsEqual(val *EnvelopeAttributes) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		if !pkg.StringEqual(e.elems[i].key, val.elems[i].key) {
			return false
		}
		if !pkg.BytesEqual(e.elems[i].value, val.elems[i].value) {
			return false
		}
	}
	return true
}

func EnvelopeAttributesEqual(left, right *EnvelopeAttributes) bool {
	return left.IsEqual(right)
}

func CmpEnvelopeAttributes(left, right *EnvelopeAttributes) int {
	l := min(len(left.elems), len(right.elems))
	for i := 0; i < l; i++ {
		c := strings.Compare(left.elems[i].key, right.elems[i].key)
		if c != 0 {
			return c
		}
	}
	lenDiff := len(left.elems) - len(right.elems)

	if lenDiff != 0 {
		return lenDiff
	}

	for i := 0; i < l; i++ {
		c := pkg.BytesCompare(
			left.elems[i].value,
			right.elems[i].value,
		)
		if c != 0 {
			return c
		}
	}
	return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. If key or value contains structs/oneofs
// only fields that exist in the schema are mutated, allowing to generate data for
// specified schema.
func (m *EnvelopeAttributes) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	if random.IntN(20) == 0 {
		m.EnsureLen(m.Len() + 1)
	}
	if random.IntN(20) == 0 && m.Len() > 0 {
		m.EnsureLen(m.Len() - 1)
	}

	for i := range m.elems {
		_ = i
		if random.IntN(4*len(m.elems)) == 0 {
			m.SetKey(i, pkg.StringRandom(random))
		}
		if random.IntN(4*len(m.elems)) == 0 {
			m.SetValue(i, pkg.BytesRandom(random))
		}
	}
}

// areKeysModified returns true if any key in the multimap was modified
// since the modified flags were last cleared.
func (m *EnvelopeAttributes) areKeysModified() bool {
	return m.modifiedElems.areKeysModified()
}

type EnvelopeAttributesEncoder struct {
	buf     pkg.BytesWriter
	columns pkg.WriteColumnSet
	limiter *pkg.SizeLimiter

	keyEncoder       *encoders.StringEncoder
	isKeyRecursive   bool
	valueEncoder     *encoders.BytesEncoder
	isValueRecursive bool
}

func (e *EnvelopeAttributesEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	// Remember this encoder in the state so that we can detect recursion.
	if state.EnvelopeAttributesEncoder != nil {
		panic("cannot initialize EnvelopeAttributesEncoder: already initialized")
	}
	state.EnvelopeAttributesEncoder = e
	defer func() { state.EnvelopeAttributesEncoder = nil }()

	e.limiter = &state.limiter

	var err error
	e.keyEncoder = new(encoders.StringEncoder)
	err = e.keyEncoder.Init(nil, e.limiter, columns.AddSubColumn())
	if err != nil {
		return nil
	}
	e.valueEncoder = new(encoders.BytesEncoder)
	err = e.valueEncoder.Init(nil, e.limiter, columns.AddSubColumn())

	return err
}

func (e *EnvelopeAttributesEncoder) Reset() {
	if !e.isKeyRecursive {
		e.keyEncoder.Reset()
	}
	if !e.isValueRecursive {
		e.valueEncoder.Reset()
	}
}

func (e *EnvelopeAttributesEncoder) Encode(list *EnvelopeAttributes) {
	oldLen := len(e.buf.Bytes())

	if len(list.elems) == 0 {
		// Zero-length attr list.
		e.buf.WriteUvarint(0b1)

		newLen := len(e.buf.Bytes())
		e.limiter.AddFrameBytes(uint(newLen - oldLen))

		return
	}

	if !list.areKeysModified() && len(list.elems) < 63 {
		e.encodeValuesOnly(list)
	} else {
		e.encodeFull(list)
	}

	newLen := len(e.buf.Bytes())
	e.limiter.AddFrameBytes(uint(newLen - oldLen))

	// Mark all elems non-modified so that next Encode() correctly
	// encodes only elems that change after this.
	list.modifiedElems.markUnmodifiedAll()
}

func (e *EnvelopeAttributesEncoder) encodeValuesOnly(list *EnvelopeAttributes) {
	if len(list.elems) > 62 {
		panic("not allowed to encode values-only for length > 62")
	}

	// The bits that describe the change value are exactly the bits
	// that are set in modifiedElems.
	changedValuesBits := list.modifiedElems.vals.mask

	// Record changedValuesBits (LSB is 0 to indicate values-only encoding).
	e.buf.WriteUvarint(changedValuesBits << 1)

	// Encode changed values only.
	bitToEncode := uint64(1)
	for i := range list.elems {
		if (bitToEncode & changedValuesBits) != 0 {
			e.valueEncoder.Encode(list.elems[i].value)
		}
		bitToEncode <<= 1
	}
}

func (e *EnvelopeAttributesEncoder) encodeFull(list *EnvelopeAttributes) {
	// Record multimap len (LSB is 1 to indicate full encoding).
	e.buf.WriteUvarint(uint64(len(list.elems))<<1 | 0b1)

	// Encode keys and values.
	for i := range list.elems {
		e.keyEncoder.Encode(list.elems[i].key)
		e.valueEncoder.Encode(list.elems[i].value)
	}
}

func (e *EnvelopeAttributesEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBytes(&e.buf)
	if !e.isKeyRecursive {
		e.keyEncoder.CollectColumns(columnSet.At(0))
	}
	if !e.isValueRecursive {
		e.valueEncoder.CollectColumns(columnSet.At(1))
	}
}

type EnvelopeAttributesDecoder struct {
	buf    pkg.BytesReader
	column *pkg.ReadableColumn

	keyDecoder       *encoders.StringDecoder
	isKeyRecursive   bool
	valueDecoder     *encoders.BytesDecoder
	isValueRecursive bool
}

// Init is called once in the lifetime of the stream.
func (d *EnvelopeAttributesDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	// Remember this decoder in the state so that we can detect recursion.
	if state.EnvelopeAttributesDecoder != nil {
		panic("cannot initialize EnvelopeAttributesDecoder: already initialized")
	}
	state.EnvelopeAttributesDecoder = d
	defer func() { state.EnvelopeAttributesDecoder = nil }()

	d.column = columns.Column()

	var err error
	d.keyDecoder = new(encoders.StringDecoder)
	err = d.keyDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return nil
	}
	d.valueDecoder = new(encoders.BytesDecoder)
	err = d.valueDecoder.Init(nil, columns.AddSubColumn())

	return err
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *EnvelopeAttributesDecoder) Continue() {
	d.buf.Reset(d.column.Data())
	if !d.isKeyRecursive {
		d.keyDecoder.Continue()
	}
	if !d.isValueRecursive {
		d.valueDecoder.Continue()
	}
}

func (d *EnvelopeAttributesDecoder) Reset() {
	if !d.isKeyRecursive {
		d.keyDecoder.Reset()
	}
	if !d.isValueRecursive {
		d.valueDecoder.Reset()
	}
}

func (d *EnvelopeAttributesDecoder) Decode(dst *EnvelopeAttributes) error {
	countOrChangedValues, err := d.buf.ReadUvarint()
	if err != nil {
		return err
	}
	if countOrChangedValues == 0 {
		// Nothing changed.
		return nil
	}

	if countOrChangedValues&0b1 == 0 {
		return d.decodeValuesOnly(countOrChangedValues>>1, dst)
	}

	if countOrChangedValues&0b1 == 0b1 {
		return d.decodeFull(int(countOrChangedValues>>1), dst)
	}
	return pkg.ErrMultimap
}

func (d *EnvelopeAttributesDecoder) decodeValuesOnly(changedValuesBits uint64, dst *EnvelopeAttributes) error {
	// Decode changed values
	var err error
	bitToRead := uint64(1)
	for i := range dst.elems {
		if (bitToRead & changedValuesBits) != 0 {
			// Value is changed, decode it.
			err = d.valueDecoder.Decode(&dst.elems[i].value)
			if err != nil {
				return err
			}
		}
		bitToRead <<= 1
	}

	return nil
}

func (d *EnvelopeAttributesDecoder) decodeFull(count int, dst *EnvelopeAttributes) error {
	if count < 0 || count >= pkg.MultimapElemCountLimit {
		return pkg.ErrMultimapCountLimit
	}

	dst.EnsureLen(count)

	var err error
	for i := 0; i < count; i++ {
		err = d.keyDecoder.Decode(&dst.elems[i].key)
		if err != nil {
			return err
		}
		err = d.valueDecoder.Decode(&dst.elems[i].value)
		if err != nil {
			return err
		}
	}

	return nil
}
