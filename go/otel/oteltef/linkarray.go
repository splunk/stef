// Code generated by stefgen. DO NOT EDIT.
package oteltef

import (
	"math/rand/v2"

	"strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

var _ = (*encoders.StringEncoder)(nil)
var _ = (*strings.Builder)(nil)

// LinkArray is a variable size array.
type LinkArray struct {
	elems []*Link

	parentModifiedFields *modifiedFields
	parentModifiedBit    uint64
}

func (e *LinkArray) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	e.parentModifiedFields = parentModifiedFields
	e.parentModifiedBit = parentModifiedBit
}

// Clone() creates a deep copy of LinkArray
func (e *LinkArray) Clone() LinkArray {
	var clone LinkArray
	copyLinkArray(&clone, e)
	return clone
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (e *LinkArray) byteSize() uint {
	if len(e.elems) == 0 {
		return 0
	}
	// TODO: add size of elements if they are clonable.
	size := uint(unsafe.Sizeof(e.elems[0]))*uint(len(e.elems)) + uint(unsafe.Sizeof(e))

	for i := range e.elems {
		size += e.elems[i].byteSize()
	}
	return size
}

// Append a new element at the end of the array.
func (e *LinkArray) Append(val *Link) {
	e.elems = append(e.elems, val)
	e.markModified()
}

func (e *LinkArray) markModified() {
	e.parentModifiedFields.markModified(e.parentModifiedBit)
}

func (e *LinkArray) markUnmodified() {
	e.parentModifiedFields.markUnmodified()
}

func (e *LinkArray) markModifiedRecursively() {
	for i := 0; i < len(e.elems); i++ {
		e.elems[i].markModifiedRecursively()
	}

}

func (e *LinkArray) markUnmodifiedRecursively() {
	for i := 0; i < len(e.elems); i++ {
		e.elems[i].markUnmodifiedRecursively()
	}

}

// markDiffModified marks fields in each element of this array modified if they differ from
// the corresponding fields in v.
func (e *LinkArray) markDiffModified(v *LinkArray) (modified bool) {
	if len(e.elems) != len(v.elems) {
		// Array lengths are different, so they are definitely different.
		modified = true
	}

	// Scan the elements and mark them as modified if they are different.
	minLen := min(len(e.elems), len(v.elems))
	for i := 0; i < minLen; i++ {
		if e.elems[i].markDiffModified(v.elems[i]) {
			modified = true
		}
	}

	// Mark the rest of the elements as modified.
	for i := minLen; i < len(e.elems); i++ {
		e.elems[i].markModifiedRecursively()
	}

	if modified {
		e.markModified()
	}

	return modified
}

func copyLinkArray(dst *LinkArray, src *LinkArray) {
	isModified := false

	minLen := min(len(dst.elems), len(src.elems))
	if len(dst.elems) != len(src.elems) {
		dst.elems = pkg.EnsureLen(dst.elems, len(src.elems))
		isModified = true
	}

	i := 0

	// Copy elements in the part of the array that already had the necessary room.
	for ; i < minLen; i++ {
		copyLink(dst.elems[i], src.elems[i])
		isModified = true
	}
	if minLen < len(dst.elems) {
		isModified = true
		// Need to allocate new elements for the part of the array that has grown.
		// Allocate all new elements at once.
		elems := make([]Link, len(dst.elems)-minLen)
		for j := range elems {
			// Init the element.
			elems[j].init(dst.parentModifiedFields, dst.parentModifiedBit)
			// Point to the allocated element.
			dst.elems[i+j] = &elems[j]
			// Copy the element.
			copyLink(dst.elems[i+j], src.elems[i+j])
		}
	}
	if isModified {
		dst.markModified()
	}
}

// Len returns the number of elements in the array.
func (e *LinkArray) Len() int {
	return len(e.elems)
}

// At returns element at index i.
func (m *LinkArray) At(i int) *Link {
	return m.elems[i]
}

// EnsureLen ensures the length of the array is equal to newLen.
// It will grow or shrink the array if needed.
func (e *LinkArray) EnsureLen(newLen int) {
	oldLen := len(e.elems)
	if newLen > oldLen {
		// Grow the array
		e.elems = append(e.elems, make([]*Link, newLen-oldLen)...)
		e.markModified()
		// Initialize newlly added elements.
		for ; oldLen < newLen; oldLen++ {
			e.elems[oldLen] = new(Link)
			e.elems[oldLen].init(e.parentModifiedFields, e.parentModifiedBit)
		}
	} else if oldLen > newLen {
		// Shrink it
		e.elems = e.elems[:newLen]
		e.markModified()
	}
}

// IsEqual performs deep comparison and returns true if array is equal to val.
func (e *LinkArray) IsEqual(val *LinkArray) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		if !e.elems[i].IsEqual(val.elems[i]) {
			return false
		}
	}
	return true
}

// CmpLinkArray performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func CmpLinkArray(left, right *LinkArray) int {
	c := len(left.elems) - len(right.elems)
	if c != 0 {
		return c
	}
	for i := range left.elems {
		fc := CmpLink(left.elems[i], right.elems[i])
		if fc < 0 {
			return -1
		}
		if fc > 0 {
			return 1
		}
	}
	return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. If array elements contain structs/oneofs
// only fields that exist in the schema are mutated, allowing to generate data for
// specified schema.
func (a *LinkArray) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	if random.IntN(20) == 0 {
		a.EnsureLen(a.Len() + 1)
	}
	if random.IntN(20) == 0 && a.Len() > 0 {
		a.EnsureLen(a.Len() - 1)
	}

	for i := range a.elems {
		_ = i
		if random.IntN(2*len(a.elems)) == 0 {
			a.elems[i].mutateRandom(random, schem)
		}
	}
}

type LinkArrayEncoder struct {
	buf         pkg.BitsWriter
	limiter     *pkg.SizeLimiter
	elemEncoder *LinkEncoder
	isRecursive bool
	state       *WriterState
	// lastValStack are last encoded values stacked by the level of recursion.
	lastValStack LinkArrayEncoderLastValStack
}
type LinkArrayEncoderLastValStack []*LinkArrayEncoderLastValElem

func (s *LinkArrayEncoderLastValStack) init() {
	// We need one top-level element in the stack to store the last value initially.
	s.addOnTop()
}

func (s *LinkArrayEncoderLastValStack) reset() {
	// Reset all elements in the stack.
	t := (*s)[:cap(*s)]
	for i := 0; i < len(t); i++ {
		t[i].reset()
	}
	// Reset the stack to have one element for top-level.
	*s = (*s)[:1]
}

func (s *LinkArrayEncoderLastValStack) top() *LinkArrayEncoderLastValElem {
	return (*s)[len(*s)-1]
}

func (s *LinkArrayEncoderLastValStack) addOnTopSlow() {
	elem := &LinkArrayEncoderLastValElem{}
	elem.init()
	*s = append(*s, elem)
	t := (*s)[0:cap(*s)]
	for i := len(*s); i < len(t); i++ {
		// Ensure that all elements in the stack are initialized.
		t[i] = &LinkArrayEncoderLastValElem{}
		t[i].init()
	}
}

func (s *LinkArrayEncoderLastValStack) addOnTop() {
	if len(*s) < cap(*s) {
		*s = (*s)[:len(*s)+1]
		return
	}
	s.addOnTopSlow()
}

func (s *LinkArrayEncoderLastValStack) removeFromTop() {
	*s = (*s)[:len(*s)-1]
}

type LinkArrayEncoderLastValElem struct {
	prevLen        int
	elem           Link
	modifiedFields modifiedFields
}

func (e *LinkArrayEncoderLastValElem) init() {
	e.elem.init(&e.modifiedFields, 1)
}

func (e *LinkArrayEncoderLastValElem) reset() {
	e.elem = Link{}
	e.prevLen = 0
}

func (e *LinkArrayEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	e.state = state
	e.limiter = &state.limiter

	// Remember this encoder in the state so that we can detect recursion.
	if state.LinkArrayEncoder != nil {
		panic("cannot initialize LinkArrayEncoder: already initialized")
	}
	state.LinkArrayEncoder = e
	defer func() { state.LinkArrayEncoder = nil }()

	if state.LinkEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.elemEncoder = state.LinkEncoder
		e.isRecursive = true
	} else {
		e.elemEncoder = new(LinkEncoder)
		if err := e.elemEncoder.Init(state, columns.AddSubColumn()); err != nil {
			return err
		}
	}
	e.lastValStack.init()

	return nil
}

func (e *LinkArrayEncoder) Reset() {
	if !e.isRecursive {
		e.elemEncoder.Reset()
	}

	e.lastValStack.reset()
}

func (e *LinkArrayEncoder) Encode(arr *LinkArray) {
	lastVal := e.lastValStack.top()
	e.lastValStack.addOnTop()
	defer func() { e.lastValStack.removeFromTop() }()

	newLen := len(arr.elems)
	oldBitLen := e.buf.BitCount()

	lenDelta := newLen - lastVal.prevLen
	lastVal.prevLen = newLen

	e.buf.WriteVarintCompact(int64(lenDelta))

	if newLen > 0 {
		for i := 0; i < newLen; i++ {
			if i == 0 {
				// Compute and mark fields that are modified compared to the last encoded value.
				arr.elems[i].markDiffModified(&lastVal.elem)
			} else {
				// Compute and mark fields that are modified compared to the previous element.
				arr.elems[i].markDiffModified(arr.elems[i-1])
			}

			// Encode the element.
			e.elemEncoder.Encode(arr.elems[i])
		}
		// Remember last encoded element.
		copyLink(&lastVal.elem, arr.elems[len(arr.elems)-1])
	}

	// Account written bits in the limiter.
	newBitLen := e.buf.BitCount()
	e.limiter.AddFrameBits(newBitLen - oldBitLen)
}

func (e *LinkArrayEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)
	if !e.isRecursive {
		e.elemEncoder.CollectColumns(columnSet.At(0))
	}
}

type LinkArrayDecoder struct {
	buf         pkg.BitsReader
	column      *pkg.ReadableColumn
	elemDecoder *LinkDecoder
	isRecursive bool
	// lastValStack are last decoded values stacked by the level of recursion.
	lastValStack LinkArrayDecoderLastValStack
}
type LinkArrayDecoderLastValStack []*LinkArrayDecoderLastValElem

func (s *LinkArrayDecoderLastValStack) init() {
	// We need one top-level element in the stack to store the last value initially.
	s.addOnTop()
}

func (s *LinkArrayDecoderLastValStack) reset() {
	// Reset all elements in the stack.
	t := (*s)[:cap(*s)]
	for i := 0; i < len(t); i++ {
		t[i].reset()
	}
	// Reset the stack to have one element for top-level.
	*s = (*s)[:1]
}

func (s *LinkArrayDecoderLastValStack) top() *LinkArrayDecoderLastValElem {
	return (*s)[len(*s)-1]
}

func (s *LinkArrayDecoderLastValStack) addOnTopSlow() {
	elem := &LinkArrayDecoderLastValElem{}
	elem.init()
	*s = append(*s, elem)
	t := (*s)[0:cap(*s)]
	for i := len(*s); i < len(t); i++ {
		// Ensure that all elements in the stack are initialized.
		t[i] = &LinkArrayDecoderLastValElem{}
		t[i].init()
	}
}

func (s *LinkArrayDecoderLastValStack) addOnTop() {
	if len(*s) < cap(*s) {
		*s = (*s)[:len(*s)+1]
		return
	}
	s.addOnTopSlow()
}

func (s *LinkArrayDecoderLastValStack) removeFromTop() {
	*s = (*s)[:len(*s)-1]
}

type LinkArrayDecoderLastValElem struct {
	prevLen int
	elem    Link
}

func (e *LinkArrayDecoderLastValElem) init() {
}

func (e *LinkArrayDecoderLastValElem) reset() {
	e.prevLen = 0
	e.elem = Link{}
}

// Init is called once in the lifetime of the stream.
func (d *LinkArrayDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	d.column = columns.Column()
	// Remember this encoder in the state so that we can detect recursion.
	if state.LinkArrayDecoder != nil {
		panic("cannot initialize LinkArrayDecoder: already initialized")
	}
	state.LinkArrayDecoder = d
	defer func() { state.LinkArrayDecoder = nil }()

	if state.LinkDecoder != nil {
		d.elemDecoder = state.LinkDecoder
		d.isRecursive = true
	} else {
		d.elemDecoder = new(LinkDecoder)
		if err := d.elemDecoder.Init(state, columns.AddSubColumn()); err != nil {
			return err
		}
	}
	d.lastValStack.init()

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *LinkArrayDecoder) Continue() {
	d.buf.Reset(d.column.Data())
	if !d.isRecursive {
		d.elemDecoder.Continue()
	}
}

func (d *LinkArrayDecoder) Reset() {
	if !d.isRecursive {
		d.elemDecoder.Reset()
	}
	d.lastValStack.reset()
}

func (d *LinkArrayDecoder) Decode(dst *LinkArray) error {
	lastVal := d.lastValStack.top()
	d.lastValStack.addOnTop()
	defer func() { d.lastValStack.removeFromTop() }()

	lenDelta := d.buf.ReadVarintCompact()

	newLen := lastVal.prevLen + int(lenDelta)
	lastVal.prevLen = newLen

	dst.EnsureLen(newLen)

	for i := 0; i < newLen; i++ {
		err := d.elemDecoder.Decode(&lastVal.elem)
		if err != nil {
			return err
		}
		copyLink(dst.elems[i], &lastVal.elem)
	}

	return nil
}
