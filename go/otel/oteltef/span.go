// Code generated by stefgen. DO NOT EDIT.
package oteltef

import (
	"fmt"
	"math/rand/v2"
	"strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
)

var _ = strings.Compare
var _ = encoders.StringEncoder{}

type Span struct {
	traceID                pkg.Bytes
	spanID                 pkg.Bytes
	traceState             string
	parentSpanID           pkg.Bytes
	flags                  uint64
	name                   string
	kind                   uint64
	startTimeUnixNano      uint64
	endTimeUnixNano        uint64
	attributes             Attributes
	droppedAttributesCount uint64
	events                 EventArray
	links                  LinkArray
	status                 SpanStatus

	// modifiedFields keeps track of which fields are modified.
	modifiedFields modifiedFields
}

// Bitmasks for "modified" flags for each field.
const (
	fieldModifiedSpanTraceID = uint64(1 << iota)
	fieldModifiedSpanSpanID
	fieldModifiedSpanTraceState
	fieldModifiedSpanParentSpanID
	fieldModifiedSpanFlags
	fieldModifiedSpanName
	fieldModifiedSpanKind
	fieldModifiedSpanStartTimeUnixNano
	fieldModifiedSpanEndTimeUnixNano
	fieldModifiedSpanAttributes
	fieldModifiedSpanDroppedAttributesCount
	fieldModifiedSpanEvents
	fieldModifiedSpanLinks
	fieldModifiedSpanStatus
)

// Init must be called once, before the Span is used.
func (s *Span) Init() {
	s.init(nil, 0)
}

func NewSpan() *Span {
	var s Span
	s.init(nil, 0)
	return &s
}

func (s *Span) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	s.modifiedFields.parent = parentModifiedFields
	s.modifiedFields.parentBit = parentModifiedBit

	s.attributes.init(&s.modifiedFields, fieldModifiedSpanAttributes)
	s.events.init(&s.modifiedFields, fieldModifiedSpanEvents)
	s.links.init(&s.modifiedFields, fieldModifiedSpanLinks)
	s.status.init(&s.modifiedFields, fieldModifiedSpanStatus)
}

func (s *Span) TraceID() pkg.Bytes {
	return s.traceID
}

// SetTraceID sets the value of TraceID field.
func (s *Span) SetTraceID(v pkg.Bytes) {
	if !pkg.BytesEqual(s.traceID, v) {
		s.traceID = v
		s.markTraceIDModified()
	}
}

func (s *Span) markTraceIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanTraceID)
}

// IsTraceIDModified returns true the value of TraceID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsTraceIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanTraceID != 0
}

func (s *Span) SpanID() pkg.Bytes {
	return s.spanID
}

// SetSpanID sets the value of SpanID field.
func (s *Span) SetSpanID(v pkg.Bytes) {
	if !pkg.BytesEqual(s.spanID, v) {
		s.spanID = v
		s.markSpanIDModified()
	}
}

func (s *Span) markSpanIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanSpanID)
}

// IsSpanIDModified returns true the value of SpanID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsSpanIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanSpanID != 0
}

func (s *Span) TraceState() string {
	return s.traceState
}

// SetTraceState sets the value of TraceState field.
func (s *Span) SetTraceState(v string) {
	if !pkg.StringEqual(s.traceState, v) {
		s.traceState = v
		s.markTraceStateModified()
	}
}

func (s *Span) markTraceStateModified() {
	s.modifiedFields.markModified(fieldModifiedSpanTraceState)
}

// IsTraceStateModified returns true the value of TraceState field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsTraceStateModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanTraceState != 0
}

func (s *Span) ParentSpanID() pkg.Bytes {
	return s.parentSpanID
}

// SetParentSpanID sets the value of ParentSpanID field.
func (s *Span) SetParentSpanID(v pkg.Bytes) {
	if !pkg.BytesEqual(s.parentSpanID, v) {
		s.parentSpanID = v
		s.markParentSpanIDModified()
	}
}

func (s *Span) markParentSpanIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanParentSpanID)
}

// IsParentSpanIDModified returns true the value of ParentSpanID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsParentSpanIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanParentSpanID != 0
}

func (s *Span) Flags() uint64 {
	return s.flags
}

// SetFlags sets the value of Flags field.
func (s *Span) SetFlags(v uint64) {
	if !pkg.Uint64Equal(s.flags, v) {
		s.flags = v
		s.markFlagsModified()
	}
}

func (s *Span) markFlagsModified() {
	s.modifiedFields.markModified(fieldModifiedSpanFlags)
}

// IsFlagsModified returns true the value of Flags field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsFlagsModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanFlags != 0
}

func (s *Span) Name() string {
	return s.name
}

// SetName sets the value of Name field.
func (s *Span) SetName(v string) {
	if !pkg.StringEqual(s.name, v) {
		s.name = v
		s.markNameModified()
	}
}

func (s *Span) markNameModified() {
	s.modifiedFields.markModified(fieldModifiedSpanName)
}

// IsNameModified returns true the value of Name field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsNameModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanName != 0
}

func (s *Span) Kind() uint64 {
	return s.kind
}

// SetKind sets the value of Kind field.
func (s *Span) SetKind(v uint64) {
	if !pkg.Uint64Equal(s.kind, v) {
		s.kind = v
		s.markKindModified()
	}
}

func (s *Span) markKindModified() {
	s.modifiedFields.markModified(fieldModifiedSpanKind)
}

// IsKindModified returns true the value of Kind field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsKindModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanKind != 0
}

func (s *Span) StartTimeUnixNano() uint64 {
	return s.startTimeUnixNano
}

// SetStartTimeUnixNano sets the value of StartTimeUnixNano field.
func (s *Span) SetStartTimeUnixNano(v uint64) {
	if !pkg.Uint64Equal(s.startTimeUnixNano, v) {
		s.startTimeUnixNano = v
		s.markStartTimeUnixNanoModified()
	}
}

func (s *Span) markStartTimeUnixNanoModified() {
	s.modifiedFields.markModified(fieldModifiedSpanStartTimeUnixNano)
}

// IsStartTimeUnixNanoModified returns true the value of StartTimeUnixNano field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsStartTimeUnixNanoModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanStartTimeUnixNano != 0
}

func (s *Span) EndTimeUnixNano() uint64 {
	return s.endTimeUnixNano
}

// SetEndTimeUnixNano sets the value of EndTimeUnixNano field.
func (s *Span) SetEndTimeUnixNano(v uint64) {
	if !pkg.Uint64Equal(s.endTimeUnixNano, v) {
		s.endTimeUnixNano = v
		s.markEndTimeUnixNanoModified()
	}
}

func (s *Span) markEndTimeUnixNanoModified() {
	s.modifiedFields.markModified(fieldModifiedSpanEndTimeUnixNano)
}

// IsEndTimeUnixNanoModified returns true the value of EndTimeUnixNano field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsEndTimeUnixNanoModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanEndTimeUnixNano != 0
}

func (s *Span) Attributes() *Attributes {
	return &s.attributes
}

// IsAttributesModified returns true the value of Attributes field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsAttributesModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanAttributes != 0
}

func (s *Span) DroppedAttributesCount() uint64 {
	return s.droppedAttributesCount
}

// SetDroppedAttributesCount sets the value of DroppedAttributesCount field.
func (s *Span) SetDroppedAttributesCount(v uint64) {
	if !pkg.Uint64Equal(s.droppedAttributesCount, v) {
		s.droppedAttributesCount = v
		s.markDroppedAttributesCountModified()
	}
}

func (s *Span) markDroppedAttributesCountModified() {
	s.modifiedFields.markModified(fieldModifiedSpanDroppedAttributesCount)
}

// IsDroppedAttributesCountModified returns true the value of DroppedAttributesCount field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsDroppedAttributesCountModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanDroppedAttributesCount != 0
}

func (s *Span) Events() *EventArray {
	return &s.events
}

// IsEventsModified returns true the value of Events field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsEventsModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanEvents != 0
}

func (s *Span) Links() *LinkArray {
	return &s.links
}

// IsLinksModified returns true the value of Links field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsLinksModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanLinks != 0
}

func (s *Span) Status() *SpanStatus {
	return &s.status
}

// IsStatusModified returns true the value of Status field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsStatusModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanStatus != 0
}

func (s *Span) markUnmodifiedRecursively() {

	if s.IsTraceIDModified() {
	}

	if s.IsSpanIDModified() {
	}

	if s.IsTraceStateModified() {
	}

	if s.IsParentSpanIDModified() {
	}

	if s.IsFlagsModified() {
	}

	if s.IsNameModified() {
	}

	if s.IsKindModified() {
	}

	if s.IsStartTimeUnixNanoModified() {
	}

	if s.IsEndTimeUnixNanoModified() {
	}

	if s.IsAttributesModified() {
		s.attributes.markUnmodifiedRecursively()
	}

	if s.IsDroppedAttributesCountModified() {
	}

	if s.IsEventsModified() {
		s.events.markUnmodifiedRecursively()
	}

	if s.IsLinksModified() {
		s.links.markUnmodifiedRecursively()
	}

	if s.IsStatusModified() {
		s.status.markUnmodifiedRecursively()
	}

	s.modifiedFields.mask = 0
}

func (s *Span) Clone() Span {
	return Span{
		traceID:                s.traceID,
		spanID:                 s.spanID,
		traceState:             s.traceState,
		parentSpanID:           s.parentSpanID,
		flags:                  s.flags,
		name:                   s.name,
		kind:                   s.kind,
		startTimeUnixNano:      s.startTimeUnixNano,
		endTimeUnixNano:        s.endTimeUnixNano,
		attributes:             s.attributes.Clone(),
		droppedAttributesCount: s.droppedAttributesCount,
		events:                 s.events.Clone(),
		links:                  s.links.Clone(),
		status:                 s.status.Clone(),
	}
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (s *Span) byteSize() uint {
	return uint(unsafe.Sizeof(*s)) +
		s.attributes.byteSize() + s.events.byteSize() + s.links.byteSize() + s.status.byteSize() + 0
}

func copySpan(dst *Span, src *Span) {
	dst.SetTraceID(src.traceID)
	dst.SetSpanID(src.spanID)
	dst.SetTraceState(src.traceState)
	dst.SetParentSpanID(src.parentSpanID)
	dst.SetFlags(src.flags)
	dst.SetName(src.name)
	dst.SetKind(src.kind)
	dst.SetStartTimeUnixNano(src.startTimeUnixNano)
	dst.SetEndTimeUnixNano(src.endTimeUnixNano)
	copyAttributes(&dst.attributes, &src.attributes)
	dst.SetDroppedAttributesCount(src.droppedAttributesCount)
	copyEventArray(&dst.events, &src.events)
	copyLinkArray(&dst.links, &src.links)
	copySpanStatus(&dst.status, &src.status)
}

// CopyFrom() performs a deep copy from src.
func (s *Span) CopyFrom(src *Span) {
	copySpan(s, src)
}

func (s *Span) markParentModified() {
	s.modifiedFields.parent.markModified(s.modifiedFields.parentBit)
}

func (s *Span) markUnmodified() {
	s.modifiedFields.markUnmodified()
	s.attributes.markUnmodified()
	s.events.markUnmodified()
	s.links.markUnmodified()
	s.status.markUnmodified()
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator.
func (s *Span) mutateRandom(random *rand.Rand) {
	const fieldCount = 14
	if random.IntN(fieldCount) == 0 {
		s.SetTraceID(pkg.BytesRandom(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetSpanID(pkg.BytesRandom(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetTraceState(pkg.StringRandom(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetParentSpanID(pkg.BytesRandom(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetFlags(pkg.Uint64Random(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetName(pkg.StringRandom(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetKind(pkg.Uint64Random(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetStartTimeUnixNano(pkg.Uint64Random(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.SetEndTimeUnixNano(pkg.Uint64Random(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.attributes.mutateRandom(random)
	}
	if random.IntN(fieldCount) == 0 {
		s.SetDroppedAttributesCount(pkg.Uint64Random(random))
	}
	if random.IntN(fieldCount) == 0 {
		s.events.mutateRandom(random)
	}
	if random.IntN(fieldCount) == 0 {
		s.links.mutateRandom(random)
	}
	if random.IntN(fieldCount) == 0 {
		s.status.mutateRandom(random)
	}
}

// IsEqual performs deep comparison and returns true if struct is equal to val.
func (e *Span) IsEqual(val *Span) bool {
	if !pkg.BytesEqual(e.traceID, val.traceID) {
		return false
	}
	if !pkg.BytesEqual(e.spanID, val.spanID) {
		return false
	}
	if !pkg.StringEqual(e.traceState, val.traceState) {
		return false
	}
	if !pkg.BytesEqual(e.parentSpanID, val.parentSpanID) {
		return false
	}
	if !pkg.Uint64Equal(e.flags, val.flags) {
		return false
	}
	if !pkg.StringEqual(e.name, val.name) {
		return false
	}
	if !pkg.Uint64Equal(e.kind, val.kind) {
		return false
	}
	if !pkg.Uint64Equal(e.startTimeUnixNano, val.startTimeUnixNano) {
		return false
	}
	if !pkg.Uint64Equal(e.endTimeUnixNano, val.endTimeUnixNano) {
		return false
	}
	if !e.attributes.IsEqual(&val.attributes) {
		return false
	}
	if !pkg.Uint64Equal(e.droppedAttributesCount, val.droppedAttributesCount) {
		return false
	}
	if !e.events.IsEqual(&val.events) {
		return false
	}
	if !e.links.IsEqual(&val.links) {
		return false
	}
	if !e.status.IsEqual(&val.status) {
		return false
	}

	return true
}

func SpanEqual(left, right *Span) bool {
	return left.IsEqual(right)
}

// CmpSpan performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func CmpSpan(left, right *Span) int {
	if left == nil {
		if right == nil {
			return 0
		}
		return -1
	}
	if right == nil {
		return 1
	}

	if c := pkg.BytesCompare(left.traceID, right.traceID); c != 0 {
		return c
	}
	if c := pkg.BytesCompare(left.spanID, right.spanID); c != 0 {
		return c
	}
	if c := strings.Compare(left.traceState, right.traceState); c != 0 {
		return c
	}
	if c := pkg.BytesCompare(left.parentSpanID, right.parentSpanID); c != 0 {
		return c
	}
	if c := pkg.Uint64Compare(left.flags, right.flags); c != 0 {
		return c
	}
	if c := strings.Compare(left.name, right.name); c != 0 {
		return c
	}
	if c := pkg.Uint64Compare(left.kind, right.kind); c != 0 {
		return c
	}
	if c := pkg.Uint64Compare(left.startTimeUnixNano, right.startTimeUnixNano); c != 0 {
		return c
	}
	if c := pkg.Uint64Compare(left.endTimeUnixNano, right.endTimeUnixNano); c != 0 {
		return c
	}
	if c := CmpAttributes(&left.attributes, &right.attributes); c != 0 {
		return c
	}
	if c := pkg.Uint64Compare(left.droppedAttributesCount, right.droppedAttributesCount); c != 0 {
		return c
	}
	if c := CmpEventArray(&left.events, &right.events); c != 0 {
		return c
	}
	if c := CmpLinkArray(&left.links, &right.links); c != 0 {
		return c
	}
	if c := CmpSpanStatus(&left.status, &right.status); c != 0 {
		return c
	}

	return 0
}

// SpanEncoder implements encoding of Span
type SpanEncoder struct {
	buf     pkg.BitsWriter
	limiter *pkg.SizeLimiter

	// forceModifiedFields is set to true if the next encoding operation
	// must write all fields, whether they are modified or no.
	// This is used after frame restarts so that the data can be decoded
	// from the frame start.
	forceModifiedFields bool

	traceIDEncoder                encoders.BytesEncoder
	spanIDEncoder                 encoders.BytesEncoder
	traceStateEncoder             encoders.StringEncoder
	parentSpanIDEncoder           encoders.BytesEncoder
	flagsEncoder                  encoders.Uint64Encoder
	nameEncoder                   encoders.StringEncoder
	kindEncoder                   encoders.Uint64Encoder
	startTimeUnixNanoEncoder      encoders.Uint64Encoder
	endTimeUnixNanoEncoder        encoders.Uint64Encoder
	attributesEncoder             AttributesEncoder
	droppedAttributesCountEncoder encoders.Uint64Encoder
	eventsEncoder                 EventArrayEncoder
	linksEncoder                  LinkArrayEncoder
	statusEncoder                 SpanStatusEncoder

	keepFieldMask uint64
	fieldCount    uint
}

func (e *SpanEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	state.SpanEncoder = e
	e.limiter = &state.limiter

	if state.OverrideSchema != nil {
		fieldCount, ok := state.OverrideSchema.FieldCount("Span")
		if !ok {
			return fmt.Errorf("cannot find struct in override schema: %s", "Span")
		}

		// Number of fields in the target schema.
		e.fieldCount = fieldCount

		// Set that many 1 bits in the keepFieldMask. All fields with higher number
		// will be skipped when encoding.
		e.keepFieldMask = ^(^uint64(0) << e.fieldCount)
	} else {
		// Keep all fields when encoding.
		e.fieldCount = 14
		e.keepFieldMask = ^uint64(0)
	}

	if e.fieldCount <= 0 {
		return nil // TraceID and subsequent fields are skipped.
	}
	if err := e.traceIDEncoder.Init(nil, e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 1 {
		return nil // SpanID and subsequent fields are skipped.
	}
	if err := e.spanIDEncoder.Init(nil, e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 2 {
		return nil // TraceState and subsequent fields are skipped.
	}
	if err := e.traceStateEncoder.Init(nil, e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 3 {
		return nil // ParentSpanID and subsequent fields are skipped.
	}
	if err := e.parentSpanIDEncoder.Init(nil, e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 4 {
		return nil // Flags and subsequent fields are skipped.
	}
	if err := e.flagsEncoder.Init(e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 5 {
		return nil // Name and subsequent fields are skipped.
	}
	if err := e.nameEncoder.Init(&state.SpanName, e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 6 {
		return nil // Kind and subsequent fields are skipped.
	}
	if err := e.kindEncoder.Init(e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 7 {
		return nil // StartTimeUnixNano and subsequent fields are skipped.
	}
	if err := e.startTimeUnixNanoEncoder.Init(e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 8 {
		return nil // EndTimeUnixNano and subsequent fields are skipped.
	}
	if err := e.endTimeUnixNanoEncoder.Init(e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 9 {
		return nil // Attributes and subsequent fields are skipped.
	}
	if err := e.attributesEncoder.Init(state, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 10 {
		return nil // DroppedAttributesCount and subsequent fields are skipped.
	}
	if err := e.droppedAttributesCountEncoder.Init(e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 11 {
		return nil // Events and subsequent fields are skipped.
	}
	if err := e.eventsEncoder.Init(state, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 12 {
		return nil // Links and subsequent fields are skipped.
	}
	if err := e.linksEncoder.Init(state, columns.AddSubColumn()); err != nil {
		return err
	}
	if e.fieldCount <= 13 {
		return nil // Status and subsequent fields are skipped.
	}
	if err := e.statusEncoder.Init(state, columns.AddSubColumn()); err != nil {
		return err
	}

	return nil
}

func (e *SpanEncoder) Reset() {
	// Since we are resetting the state of encoder make sure the next Encode()
	// call forcedly writes all fields and does not attempt to skip.
	e.forceModifiedFields = true
	e.traceIDEncoder.Reset()
	e.spanIDEncoder.Reset()
	e.traceStateEncoder.Reset()
	e.parentSpanIDEncoder.Reset()
	e.flagsEncoder.Reset()
	e.nameEncoder.Reset()
	e.kindEncoder.Reset()
	e.startTimeUnixNanoEncoder.Reset()
	e.endTimeUnixNanoEncoder.Reset()
	e.attributesEncoder.Reset()
	e.droppedAttributesCountEncoder.Reset()
	e.eventsEncoder.Reset()
	e.linksEncoder.Reset()
	e.statusEncoder.Reset()
}

// Encode encodes val into buf
func (e *SpanEncoder) Encode(val *Span) {
	oldLen := e.buf.BitCount()

	// Mask that describes what fields are encoded. Start with all modified fields.
	fieldMask := val.modifiedFields.mask

	// If forceModifiedFields we need to set to 1 all bits so that we
	// force writing of all fields.
	if e.forceModifiedFields {
		fieldMask =
			fieldModifiedSpanTraceID |
				fieldModifiedSpanSpanID |
				fieldModifiedSpanTraceState |
				fieldModifiedSpanParentSpanID |
				fieldModifiedSpanFlags |
				fieldModifiedSpanName |
				fieldModifiedSpanKind |
				fieldModifiedSpanStartTimeUnixNano |
				fieldModifiedSpanEndTimeUnixNano |
				fieldModifiedSpanAttributes |
				fieldModifiedSpanDroppedAttributesCount |
				fieldModifiedSpanEvents |
				fieldModifiedSpanLinks |
				fieldModifiedSpanStatus | 0
	}

	// Only write fields that we want to write. See Init() for keepFieldMask.
	fieldMask &= e.keepFieldMask

	// Write bits to indicate which fields follow.
	e.buf.WriteBits(fieldMask, e.fieldCount)

	// Encode modified, present fields.

	if fieldMask&fieldModifiedSpanTraceID != 0 {
		// Encode TraceID
		e.traceIDEncoder.Encode(val.traceID)
	}

	if fieldMask&fieldModifiedSpanSpanID != 0 {
		// Encode SpanID
		e.spanIDEncoder.Encode(val.spanID)
	}

	if fieldMask&fieldModifiedSpanTraceState != 0 {
		// Encode TraceState
		e.traceStateEncoder.Encode(val.traceState)
	}

	if fieldMask&fieldModifiedSpanParentSpanID != 0 {
		// Encode ParentSpanID
		e.parentSpanIDEncoder.Encode(val.parentSpanID)
	}

	if fieldMask&fieldModifiedSpanFlags != 0 {
		// Encode Flags
		e.flagsEncoder.Encode(val.flags)
	}

	if fieldMask&fieldModifiedSpanName != 0 {
		// Encode Name
		e.nameEncoder.Encode(val.name)
	}

	if fieldMask&fieldModifiedSpanKind != 0 {
		// Encode Kind
		e.kindEncoder.Encode(val.kind)
	}

	if fieldMask&fieldModifiedSpanStartTimeUnixNano != 0 {
		// Encode StartTimeUnixNano
		e.startTimeUnixNanoEncoder.Encode(val.startTimeUnixNano)
	}

	if fieldMask&fieldModifiedSpanEndTimeUnixNano != 0 {
		// Encode EndTimeUnixNano
		e.endTimeUnixNanoEncoder.Encode(val.endTimeUnixNano)
	}

	if fieldMask&fieldModifiedSpanAttributes != 0 {
		// Encode Attributes
		e.attributesEncoder.Encode(&val.attributes)
	}

	if fieldMask&fieldModifiedSpanDroppedAttributesCount != 0 {
		// Encode DroppedAttributesCount
		e.droppedAttributesCountEncoder.Encode(val.droppedAttributesCount)
	}

	if fieldMask&fieldModifiedSpanEvents != 0 {
		// Encode Events
		e.eventsEncoder.Encode(&val.events)
	}

	if fieldMask&fieldModifiedSpanLinks != 0 {
		// Encode Links
		e.linksEncoder.Encode(&val.links)
	}

	if fieldMask&fieldModifiedSpanStatus != 0 {
		// Encode Status
		e.statusEncoder.Encode(&val.status)
	}

	// Account written bits in the limiter.
	newLen := e.buf.BitCount()
	e.limiter.AddFrameBits(newLen - oldLen)

	// Mark all fields non-modified so that next Encode() correctly
	// encodes only fields that change after this.
	val.modifiedFields.mask = 0
}

// CollectColumns collects all buffers from all encoders into buf.
func (e *SpanEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)

	if e.fieldCount <= 0 {
		return // TraceID and subsequent fields are skipped.
	}
	e.traceIDEncoder.CollectColumns(columnSet.At(0))
	if e.fieldCount <= 1 {
		return // SpanID and subsequent fields are skipped.
	}
	e.spanIDEncoder.CollectColumns(columnSet.At(1))
	if e.fieldCount <= 2 {
		return // TraceState and subsequent fields are skipped.
	}
	e.traceStateEncoder.CollectColumns(columnSet.At(2))
	if e.fieldCount <= 3 {
		return // ParentSpanID and subsequent fields are skipped.
	}
	e.parentSpanIDEncoder.CollectColumns(columnSet.At(3))
	if e.fieldCount <= 4 {
		return // Flags and subsequent fields are skipped.
	}
	e.flagsEncoder.CollectColumns(columnSet.At(4))
	if e.fieldCount <= 5 {
		return // Name and subsequent fields are skipped.
	}
	e.nameEncoder.CollectColumns(columnSet.At(5))
	if e.fieldCount <= 6 {
		return // Kind and subsequent fields are skipped.
	}
	e.kindEncoder.CollectColumns(columnSet.At(6))
	if e.fieldCount <= 7 {
		return // StartTimeUnixNano and subsequent fields are skipped.
	}
	e.startTimeUnixNanoEncoder.CollectColumns(columnSet.At(7))
	if e.fieldCount <= 8 {
		return // EndTimeUnixNano and subsequent fields are skipped.
	}
	e.endTimeUnixNanoEncoder.CollectColumns(columnSet.At(8))
	if e.fieldCount <= 9 {
		return // Attributes and subsequent fields are skipped.
	}
	e.attributesEncoder.CollectColumns(columnSet.At(9))
	if e.fieldCount <= 10 {
		return // DroppedAttributesCount and subsequent fields are skipped.
	}
	e.droppedAttributesCountEncoder.CollectColumns(columnSet.At(10))
	if e.fieldCount <= 11 {
		return // Events and subsequent fields are skipped.
	}
	e.eventsEncoder.CollectColumns(columnSet.At(11))
	if e.fieldCount <= 12 {
		return // Links and subsequent fields are skipped.
	}
	e.linksEncoder.CollectColumns(columnSet.At(12))
	if e.fieldCount <= 13 {
		return // Status and subsequent fields are skipped.
	}
	e.statusEncoder.CollectColumns(columnSet.At(13))
}

// SpanDecoder implements decoding of Span
type SpanDecoder struct {
	buf        pkg.BitsReader
	column     *pkg.ReadableColumn
	lastValPtr *Span
	lastVal    Span
	fieldCount uint

	traceIDDecoder                encoders.BytesDecoder
	spanIDDecoder                 encoders.BytesDecoder
	traceStateDecoder             encoders.StringDecoder
	parentSpanIDDecoder           encoders.BytesDecoder
	flagsDecoder                  encoders.Uint64Decoder
	nameDecoder                   encoders.StringDecoder
	kindDecoder                   encoders.Uint64Decoder
	startTimeUnixNanoDecoder      encoders.Uint64Decoder
	endTimeUnixNanoDecoder        encoders.Uint64Decoder
	attributesDecoder             AttributesDecoder
	droppedAttributesCountDecoder encoders.Uint64Decoder
	eventsDecoder                 EventArrayDecoder
	linksDecoder                  LinkArrayDecoder
	statusDecoder                 SpanStatusDecoder
}

// Init is called once in the lifetime of the stream.
func (d *SpanDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	state.SpanDecoder = d

	if state.OverrideSchema != nil {
		fieldCount, ok := state.OverrideSchema.FieldCount("Span")
		if !ok {
			return fmt.Errorf("cannot find struct in override schema: %s", "Span")
		}

		// Number of fields in the target schema.
		d.fieldCount = fieldCount
	} else {
		// Keep all fields when encoding.
		d.fieldCount = 14
	}

	d.column = columns.Column()

	d.lastVal.init(nil, 0)
	d.lastValPtr = &d.lastVal

	var err error

	if d.fieldCount <= 0 {
		return nil // TraceID and subsequent fields are skipped.
	}
	err = d.traceIDDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 1 {
		return nil // SpanID and subsequent fields are skipped.
	}
	err = d.spanIDDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 2 {
		return nil // TraceState and subsequent fields are skipped.
	}
	err = d.traceStateDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 3 {
		return nil // ParentSpanID and subsequent fields are skipped.
	}
	err = d.parentSpanIDDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 4 {
		return nil // Flags and subsequent fields are skipped.
	}
	err = d.flagsDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 5 {
		return nil // Name and subsequent fields are skipped.
	}
	err = d.nameDecoder.Init(&state.SpanName, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 6 {
		return nil // Kind and subsequent fields are skipped.
	}
	err = d.kindDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 7 {
		return nil // StartTimeUnixNano and subsequent fields are skipped.
	}
	err = d.startTimeUnixNanoDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 8 {
		return nil // EndTimeUnixNano and subsequent fields are skipped.
	}
	err = d.endTimeUnixNanoDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 9 {
		return nil // Attributes and subsequent fields are skipped.
	}
	err = d.attributesDecoder.Init(state, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 10 {
		return nil // DroppedAttributesCount and subsequent fields are skipped.
	}
	err = d.droppedAttributesCountDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 11 {
		return nil // Events and subsequent fields are skipped.
	}
	err = d.eventsDecoder.Init(state, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 12 {
		return nil // Links and subsequent fields are skipped.
	}
	err = d.linksDecoder.Init(state, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 13 {
		return nil // Status and subsequent fields are skipped.
	}
	err = d.statusDecoder.Init(state, columns.AddSubColumn())
	if err != nil {
		return err
	}

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *SpanDecoder) Continue() {
	d.buf.Reset(d.column.Data())

	if d.fieldCount <= 0 {
		return // TraceID and subsequent fields are skipped.
	}
	d.traceIDDecoder.Continue()
	if d.fieldCount <= 1 {
		return // SpanID and subsequent fields are skipped.
	}
	d.spanIDDecoder.Continue()
	if d.fieldCount <= 2 {
		return // TraceState and subsequent fields are skipped.
	}
	d.traceStateDecoder.Continue()
	if d.fieldCount <= 3 {
		return // ParentSpanID and subsequent fields are skipped.
	}
	d.parentSpanIDDecoder.Continue()
	if d.fieldCount <= 4 {
		return // Flags and subsequent fields are skipped.
	}
	d.flagsDecoder.Continue()
	if d.fieldCount <= 5 {
		return // Name and subsequent fields are skipped.
	}
	d.nameDecoder.Continue()
	if d.fieldCount <= 6 {
		return // Kind and subsequent fields are skipped.
	}
	d.kindDecoder.Continue()
	if d.fieldCount <= 7 {
		return // StartTimeUnixNano and subsequent fields are skipped.
	}
	d.startTimeUnixNanoDecoder.Continue()
	if d.fieldCount <= 8 {
		return // EndTimeUnixNano and subsequent fields are skipped.
	}
	d.endTimeUnixNanoDecoder.Continue()
	if d.fieldCount <= 9 {
		return // Attributes and subsequent fields are skipped.
	}
	d.attributesDecoder.Continue()
	if d.fieldCount <= 10 {
		return // DroppedAttributesCount and subsequent fields are skipped.
	}
	d.droppedAttributesCountDecoder.Continue()
	if d.fieldCount <= 11 {
		return // Events and subsequent fields are skipped.
	}
	d.eventsDecoder.Continue()
	if d.fieldCount <= 12 {
		return // Links and subsequent fields are skipped.
	}
	d.linksDecoder.Continue()
	if d.fieldCount <= 13 {
		return // Status and subsequent fields are skipped.
	}
	d.statusDecoder.Continue()
}

func (d *SpanDecoder) Reset() {
	d.traceIDDecoder.Reset()
	d.spanIDDecoder.Reset()
	d.traceStateDecoder.Reset()
	d.parentSpanIDDecoder.Reset()
	d.flagsDecoder.Reset()
	d.nameDecoder.Reset()
	d.kindDecoder.Reset()
	d.startTimeUnixNanoDecoder.Reset()
	d.endTimeUnixNanoDecoder.Reset()
	d.attributesDecoder.Reset()
	d.droppedAttributesCountDecoder.Reset()
	d.eventsDecoder.Reset()
	d.linksDecoder.Reset()
	d.statusDecoder.Reset()
}

func (d *SpanDecoder) Decode(dstPtr *Span) error {
	val := dstPtr

	var err error

	// Read bits that indicate which fields follow.
	val.modifiedFields.mask = d.buf.ReadBits(d.fieldCount)

	if val.modifiedFields.mask&fieldModifiedSpanTraceID != 0 {
		// Field is changed and is present, decode it.
		err = d.traceIDDecoder.Decode(&val.traceID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanSpanID != 0 {
		// Field is changed and is present, decode it.
		err = d.spanIDDecoder.Decode(&val.spanID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanTraceState != 0 {
		// Field is changed and is present, decode it.
		err = d.traceStateDecoder.Decode(&val.traceState)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanParentSpanID != 0 {
		// Field is changed and is present, decode it.
		err = d.parentSpanIDDecoder.Decode(&val.parentSpanID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanFlags != 0 {
		// Field is changed and is present, decode it.
		err = d.flagsDecoder.Decode(&val.flags)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanName != 0 {
		// Field is changed and is present, decode it.
		err = d.nameDecoder.Decode(&val.name)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanKind != 0 {
		// Field is changed and is present, decode it.
		err = d.kindDecoder.Decode(&val.kind)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanStartTimeUnixNano != 0 {
		// Field is changed and is present, decode it.
		err = d.startTimeUnixNanoDecoder.Decode(&val.startTimeUnixNano)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanEndTimeUnixNano != 0 {
		// Field is changed and is present, decode it.
		err = d.endTimeUnixNanoDecoder.Decode(&val.endTimeUnixNano)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanAttributes != 0 {
		// Field is changed and is present, decode it.
		err = d.attributesDecoder.Decode(&val.attributes)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanDroppedAttributesCount != 0 {
		// Field is changed and is present, decode it.
		err = d.droppedAttributesCountDecoder.Decode(&val.droppedAttributesCount)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanEvents != 0 {
		// Field is changed and is present, decode it.
		err = d.eventsDecoder.Decode(&val.events)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanLinks != 0 {
		// Field is changed and is present, decode it.
		err = d.linksDecoder.Decode(&val.links)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanStatus != 0 {
		// Field is changed and is present, decode it.
		err = d.statusDecoder.Decode(&val.status)
		if err != nil {
			return err
		}
	}

	return nil
}
