package main

import (
	"fmt"
	"log"
	"math"
	"os"
	"path"
)

var prefixes = []uint64{
	0b1,
	0b01,
	0b001,
	0b0001,
	0b00001,
	0b000001,
	0b0000001,
	0b00000001,
}

var prefixBitCounts = []uint64{
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
}

var payloadBitCounts = []uint64{
	0,
	2,
	5,
	12,
	19,
	26,
	33,
	48,
}

func main() {
	generateBitstreamLUT()

	generateUvar64x4AVX512()
	generateUvar64x4AVX2()
	generateUvar64x2()

	generateUvar32x4ReadLUT()

	generateUvar32x4WriteLUT()
	generateUvar64x2WriteLUT()
}

func generateBitstreamLUT() {
	fmt.Println("Generating lookup tables...")
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "bitstream_lut.go")
	fmt.Printf("Writting file %s...\n", filePath)
	f, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	f = f
	fmt.Fprintf(f, "package pkg\n\n")

	fmt.Fprintf(f, "var writeBitsCountByZeros = [65]uint{\n")
	fmt.Fprintf(f, "\t0,0,0,0,0,0,0,0,\n")
	fmt.Fprintf(f, "\t0,0,0,0,0,0,0,0,\n")
	for i := 2; i <= 7; i++ {
		fmt.Fprintf(f, "\t")
		for j := 0; j <= 7; j++ {
			var bitCount uint64
			zeros := 64 - uint64(i*8+j)
			var prefIdx int
			for prefIdx = 0; prefIdx < len(payloadBitCounts); prefIdx++ {
				bitCount = payloadBitCounts[prefIdx]
				if bitCount >= zeros {
					break
				}
			}
			if bitCount < zeros {
				panic("impossible to represent")
			}
			fmt.Fprintf(f, "%2d,", prefixBitCounts[prefIdx]+payloadBitCounts[prefIdx])
		}
		fmt.Fprintf(f, "\n")
	}
	fmt.Fprintf(f, "\t1,\n}\n\n")

	fmt.Fprintf(f, "var writeMaskByZeros = [65]uint64{\n")
	fmt.Fprintf(f, "\t0,0,0,0,0,0,0,0,\n")
	fmt.Fprintf(f, "\t0,0,0,0,0,0,0,0,\n")
	for i := 2; i <= 7; i++ {
		fmt.Fprintf(f, "\t")
		for j := 0; j <= 7; j++ {
			var bitCount uint64
			zeros := 64 - uint64(i*8+j)
			var prefIdx int
			for prefIdx = 0; prefIdx < len(payloadBitCounts); prefIdx++ {
				bitCount = payloadBitCounts[prefIdx]
				if bitCount >= zeros {
					break
				}
			}
			if bitCount < zeros {
				panic("impossible to represent")
			}
			fmt.Fprintf(f, "0x%X,", prefixes[prefIdx]<<payloadBitCounts[prefIdx])
		}
		fmt.Fprintf(f, "\n")
	}
	fmt.Fprintf(f, "	0x01,\n}\n\n")

	fmt.Fprintf(f, "var readShiftByZeros = [65]uint64{\n")
	fmt.Fprintf(f, "\t0, 0, 0, 0, 0, 0, 0, 0,\n\t")
	for i := 0; i < len(prefixes); i++ {
		prefIdx := i
		fmt.Fprintf(f, "%d,", 56-prefixBitCounts[prefIdx]-payloadBitCounts[prefIdx])
	}
	fmt.Fprintf(f, "1,\n}\n\n")

	fmt.Fprintf(f, "var readMaskByZeros = [65]uint64{\n")
	fmt.Fprintf(f, "\t0, 0, 0, 0, 0, 0, 0, 0,\n\t")
	for i := 0; i < len(prefixes); i++ {
		prefIdx := i
		fmt.Fprintf(f, "0x%X,", uint64(math.MaxUint64>>(64-payloadBitCounts[prefIdx])))
	}
	fmt.Fprintf(f, "\n}\n\n")

	fmt.Fprintf(f, "var readConsumeCountByZeros = [65]uint{\n")
	fmt.Fprintf(f, "\t 0, 0, 0, 0, 0, 0, 0, 0,\n\t")
	for i := 0; i < len(prefixes); i++ {
		prefIdx := i
		fmt.Fprintf(f, "%2d,", prefixBitCounts[prefIdx]+payloadBitCounts[prefIdx])
	}
	fmt.Fprintf(f, "\n}\n\n")
}

// generateUvar64x4AVX512 generates a lookup table for SIMD permutation operations
// for reading 4 variable-length uint64 values
func generateUvar64x4AVX512() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar64x4_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "//go:build amd64 && goexperiment.simd")
	fmt.Fprintln(file, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "package pkg")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x4ReadPermute512 contains SIMD permutation indices for each possible control byte")
	fmt.Fprintln(file, "// The table maps control byte values (0-255) to 32-byte permutation patterns")
	fmt.Fprintln(
		file, "// Each entry describes how to rearrange 32 input bytes to extract 4 variable-length uint64 values",
	)
	fmt.Fprintln(
		file, "// Output layout: [value0:8bytes][value1:8bytes][value2:8bytes][value3:8bytes] (32 bytes total)",
	)
	fmt.Fprintln(file, "var uvar64x4ReadPermute512 = [256][32]byte{")

	// Generate all 256 possible control byte combinations
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 2-bit length codes for each of the 4 values
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		// Convert codes to byte lengths: 0->1, 1->2, 2->4, 3->8
		lengths := [4]int{
			1 << code0,
			1 << code1,
			1 << code2,
			1 << code3,
		}

		// Calculate offsets for each value in the 32-byte input
		offsets := [4]int{
			0,                                    // value0 starts at byte 0
			lengths[0],                           // value1 starts after value0
			lengths[0] + lengths[1],              // value2 starts after value0+value1
			lengths[0] + lengths[1] + lengths[2], // value3 starts after value0+value1+value2
		}

		// Create permutation pattern for 32-byte output
		// Layout: [value0:8bytes][value1:8bytes][value2:8bytes][value3:8bytes]
		var permutation [32]byte

		// Initialize permutation with 0 (will be zero-extended for unused bytes)
		for i := range permutation {
			permutation[i] = 0
		}

		// Set up permutation indices for all 4 values (8 bytes each)
		for valueIdx := 0; valueIdx < 4; valueIdx++ {
			srcOffset := offsets[valueIdx]
			dstOffset := valueIdx * 8 // Each value gets 8 bytes in the output
			length := lengths[valueIdx]

			// Map source bytes to destination bytes (little-endian order)
			for byteIdx := 0; byteIdx < length && byteIdx < 8; byteIdx++ {
				if srcOffset+byteIdx < 32 {
					permutation[dstOffset+byteIdx] = byte(srcOffset + byteIdx)
				}
			}
			// Remaining bytes in the 8-byte slot stay as 0 (zero-extension)
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d,%d,%d] lengths=[%d,%d,%d,%d]\n",
			controlByte, code0, code1, code2, code3, lengths[0], lengths[1], lengths[2], lengths[3],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x4ReadLen512 contains the total byte length for each control byte")
	fmt.Fprintln(file, "var uvar64x4ReadLen512 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		lengths := [4]int{
			1 << code0,
			1 << code1,
			1 << code2,
			1 << code3,
		}

		totalLength := lengths[0] + lengths[1] + lengths[2] + lengths[3]
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
}

// generateUvar64x4AVX2 generates lookup tables for AVX2 permutation operations
// for reading 4 variable-length uint64 values using two 128-bit operations
func generateUvar64x4AVX2() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar64x4_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "")
	fmt.Fprintln(
		file, "// uvar64x4ReadPermute256Part1 contains SIMD permutation indices for the first pair of uint64 values",
	)
	fmt.Fprintln(
		file, "// The table maps control byte values (0-255) to 16-byte permutation patterns for values 0 and 1",
	)
	fmt.Fprintln(file, "// Output layout: [value0:8bytes][value1:8bytes] (16 bytes total)")
	fmt.Fprintln(file, "var uvar64x4ReadPermute256Part1 = [256][16]byte{")

	// Generate all 256 possible control byte combinations for the first pair
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 2-bit length codes for the first two values
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3

		// Convert codes to byte lengths: 0->1, 1->2, 2->4, 3->8
		lengths := [2]int{
			1 << code0,
			1 << code1,
		}

		// Calculate offsets for each value in the input
		offsets := [2]int{
			0,          // value0 starts at byte 0
			lengths[0], // value1 starts after value0
		}

		// Create permutation pattern for 16-byte output
		// Layout: [value0:8bytes][value1:8bytes]
		var permutation [16]byte

		// Initialize permutation with 0x80 (will write zeros for unused bytes)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Set up permutation indices for the first 2 values (8 bytes each)
		for valueIdx := 0; valueIdx < 2; valueIdx++ {
			srcOffset := offsets[valueIdx]
			dstOffset := valueIdx * 8 // Each value gets 8 bytes in the output
			length := lengths[valueIdx]

			// Map source bytes to destination bytes (little-endian order)
			for byteIdx := 0; byteIdx < length && byteIdx < 8; byteIdx++ {
				if srcOffset+byteIdx < 16 {
					permutation[dstOffset+byteIdx] = byte(srcOffset + byteIdx)
				}
			}
			// Remaining bytes in the 8-byte slot stay as 0 (zero-extension)
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d] lengths=[%d,%d]\n",
			controlByte, code0, code1, lengths[0], lengths[1],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(
		file, "// uvar64x4ReadPermute256Part2 contains SIMD permutation indices for the second pair of uint64 values",
	)
	fmt.Fprintln(
		file, "// The table maps control byte values (0-255) to 16-byte permutation patterns for values 2 and 3",
	)
	fmt.Fprintln(file, "// Output layout: [value2:8bytes][value3:8bytes] (16 bytes total)")
	fmt.Fprintln(file, "var uvar64x4ReadPermute256Part2 = [256][16]byte{")

	// Generate all 256 possible control byte combinations for the second pair
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 2-bit length codes for all 4 values
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		// Convert codes to byte lengths: 0->1, 1->2, 2->4, 3->8
		lengths := [4]int{
			1 << code0,
			1 << code1,
			1 << code2,
			1 << code3,
		}

		// Calculate offsets for values 2 and 3 relative to the start of the second chunk
		offsets := [2]int{
			0,          // value2 starts at byte 0 of the second chunk
			lengths[2], // value3 starts after value2
		}

		// Create permutation pattern for 16-byte output
		// Layout: [value2:8bytes][value3:8bytes]
		var permutation [16]byte

		// Initialize permutation with 0x80 (will write zeros for unused bytes)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Set up permutation indices for values 2 and 3 (8 bytes each)
		for valueIdx := 0; valueIdx < 2; valueIdx++ {
			srcOffset := offsets[valueIdx]
			dstOffset := valueIdx * 8     // Each value gets 8 bytes in the output
			length := lengths[valueIdx+2] // lengths[2] or lengths[3]

			// Map source bytes to destination bytes (little-endian order)
			for byteIdx := 0; byteIdx < length && byteIdx < 8; byteIdx++ {
				if srcOffset+byteIdx < 16 {
					permutation[dstOffset+byteIdx] = byte(srcOffset + byteIdx)
				}
			}
			// Remaining bytes in the 8-byte slot stay as 0 (zero-extension)
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d] lengths=[%d,%d]\n",
			controlByte, code2, code3, lengths[2], lengths[3],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x4ReadLen256Part1 contains the byte length for the first pair of values")
	fmt.Fprintln(file, "var uvar64x4ReadLen256Part1 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3

		lengths := [2]int{
			1 << code0,
			1 << code1,
		}

		totalLength := lengths[0] + lengths[1]
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x4ReadLen256Part2 contains the byte length for the second pair of values")
	fmt.Fprintln(file, "var uvar64x4ReadLen256Part2 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		lengths := [2]int{
			1 << code2,
			1 << code3,
		}

		totalLength := lengths[0] + lengths[1]
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
}

// generateUvar64x2 generates lookup tables for reading 2 variable-length uint64 values
// using a single 128-bit operation
func generateUvar64x2() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar64x2_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "//go:build amd64 && goexperiment.simd")
	fmt.Fprintln(file, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "package pkg")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x2ReadPermute128 contains SIMD permutation indices for each possible control byte")
	fmt.Fprintln(file, "// The table maps control byte values (0-255) to 16-byte permutation patterns")
	fmt.Fprintln(
		file, "// Each entry describes how to rearrange 16 input bytes to extract 2 variable-length uint64 values",
	)
	fmt.Fprintln(
		file, "// Output layout: [value0:8bytes][value1:8bytes] (16 bytes total)",
	)
	fmt.Fprintln(file, "var uvar64x2ReadPermute128 = [256][16]byte{")

	// Generate all 256 possible control byte combinations
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 4-bit length codes for each of the 2 values
		code0 := controlByte & 0xF        // bits 0-3 (first value byte length 0-8)
		code1 := (controlByte >> 4) & 0xF // bits 4-7 (second value byte length 0-8)

		// Convert codes to byte lengths: 0->0, 1->1, 2->2, ..., 8->8
		lengths := [2]int{
			int(code0),
			int(code1),
		}

		// Calculate offsets for each value in the 16-byte input (sequential packed format)
		offsets := [2]int{
			0,          // value0 starts at byte 0
			lengths[0], // value1 starts after value0
		}

		// Create permutation pattern for 16-byte output
		// Layout: [value0:8bytes][value1:8bytes]
		var permutation [16]byte

		// Initialize permutation with 0x80 (will write zeros for unused bytes)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Set up permutation indices for the 2 values (8 bytes each)
		for valueIdx := 0; valueIdx < 2; valueIdx++ {
			srcOffset := offsets[valueIdx]
			dstOffset := valueIdx * 8 // Each value gets 8 bytes in the output
			length := lengths[valueIdx]

			// Map source bytes to destination bytes (little-endian order)
			for byteIdx := 0; byteIdx < length && byteIdx < 8; byteIdx++ {
				if srcOffset+byteIdx < 16 {
					permutation[dstOffset+byteIdx] = byte(srcOffset + byteIdx)
				} else {
					// Source index exceeds 16-byte input, use zero-write
					permutation[dstOffset+byteIdx] = 0x80
				}
			}
			// Remaining bytes in the 8-byte slot use zero-write (already set to 0x80)
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d] lengths=[%d,%d]\n",
			controlByte, code0, code1, lengths[0], lengths[1],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar64x2ReadLen128 contains the total byte length for each control byte")
	fmt.Fprintln(file, "var uvar64x2ReadLen128 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code0 := controlByte & 0xF        // bits 0-3
		code1 := (controlByte >> 4) & 0xF // bits 4-7

		lengths := [2]int{
			int(code0),
			int(code1),
		}

		totalLength := lengths[0] + lengths[1]
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
}

// generateUvar32x4ReadLUT generates a lookup table for SIMD permutation operations
// for reading 4 variable-length uint32 values
func generateUvar32x4ReadLUT() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar32x4_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "//go:build amd64 && goexperiment.simd")
	fmt.Fprintln(file, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "package pkg")
	fmt.Fprintln(file, "")
	fmt.Fprintln(
		file, "// uvar32x4ReadPermute256 contains SIMD permutation indices for each possible control byte",
	)
	fmt.Fprintln(file, "// The table maps control byte values (0-255) to 16-byte permutation patterns")
	fmt.Fprintln(
		file, "// Each entry describes how to rearrange 16 input bytes to extract 4 variable-length uint32 values",
	)
	fmt.Fprintln(
		file, "// Output layout: [value0:4bytes][value1:4bytes][value2:4bytes][value3:4bytes] (16 bytes total)",
	)
	fmt.Fprintln(file, "var uvar32x4ReadPermute256 = [256][16]byte{")

	// Generate all 256 possible control byte combinations
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 2-bit length codes for each of the 4 values
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		// Convert codes to byte lengths for 32-bit: 0->0, 1->1, 2->2, 3->4
		lengths := [4]int{
			[]int{0, 1, 2, 4}[code0],
			[]int{0, 1, 2, 4}[code1],
			[]int{0, 1, 2, 4}[code2],
			[]int{0, 1, 2, 4}[code3],
		}

		// Calculate offsets for each value in the 16-byte input
		offsets := [4]int{
			0,                                    // value0 starts at byte 0
			lengths[0],                           // value1 starts after value0
			lengths[0] + lengths[1],              // value2 starts after value0+value1
			lengths[0] + lengths[1] + lengths[2], // value3 starts after value0+value1+value2
		}

		// Create permutation pattern for 16-byte output
		// Layout: [value0:4bytes][value1:4bytes][value2:4bytes][value3:4bytes]
		var permutation [16]byte

		// Initialize all indices to 0x80 (top bit set = zero write)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Set up permutation indices for all 4 values (4 bytes each)
		for valueIdx := 0; valueIdx < 4; valueIdx++ {
			srcOffset := offsets[valueIdx]
			dstOffset := valueIdx * 4 // Each value gets 4 bytes in the output
			length := lengths[valueIdx]

			// Map source bytes to destination bytes (little-endian order)
			for byteIdx := 0; byteIdx < length && byteIdx < 4; byteIdx++ {
				srcIdx := srcOffset + byteIdx
				if srcIdx < 16 {
					// Use the source index directly (top bit clear = copy)
					permutation[dstOffset+byteIdx] = byte(srcIdx)
				} else {
					// Source index exceeds 16-byte input, use zero-write
					permutation[dstOffset+byteIdx] = 0x80
				}
			}
			// Remaining bytes in the 4-byte slot use zero-write (already set to 0x80)
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d,%d,%d] lengths=[%d,%d,%d,%d]\n",
			controlByte, code0, code1, code2, code3, lengths[0], lengths[1], lengths[2], lengths[3],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar32x4ReadLen256 contains the total byte length for each control byte")
	fmt.Fprintln(file, "var uvar32x4ReadLen256 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		lengths := [4]int{
			[]int{0, 1, 2, 4}[code0],
			[]int{0, 1, 2, 4}[code1],
			[]int{0, 1, 2, 4}[code2],
			[]int{0, 1, 2, 4}[code3],
		}

		totalLength := lengths[0] + lengths[1] + lengths[2] + lengths[3]
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
}

// generateUvar32x4WriteLUT generates a lookup table for SIMD permutation operations
// for packing 4 variable-length uint32 values
func generateUvar32x4WriteLUT() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar32x4_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "")
	fmt.Fprintln(
		file,
		"// uvar32x4WritePermute256 contains SIMD permutation indices for packing 4 variable-length uint32 values",
	)
	fmt.Fprintln(file, "// The table maps control byte values (0-255) to 16-byte permutation patterns")
	fmt.Fprintln(
		file, "// Each entry describes how to extract bytes from fixed 4-byte slots and pack them sequentially",
	)
	fmt.Fprintln(
		file, "// Input layout: [value0:4bytes][value1:4bytes][value2:4bytes][value3:4bytes] (16 bytes total)",
	)
	fmt.Fprintln(file, "var uvar32x4WritePermute256 = [256][16]byte{")

	// Generate all 256 possible control byte combinations
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 2-bit length codes for each of the 4 values
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		// Convert codes to byte lengths for 32-bit: 0->0, 1->1, 2->2, 3->4
		lengths := [4]int{
			[]int{0, 1, 2, 4}[code0],
			[]int{0, 1, 2, 4}[code1],
			[]int{0, 1, 2, 4}[code2],
			[]int{0, 1, 2, 4}[code3],
		}

		// Create permutation pattern for 16-byte output
		// We'll pack the needed bytes sequentially at the beginning
		var permutation [16]byte

		// Initialize all indices to 0x80 (top bit set = zero write)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Pack bytes sequentially from the 4 fixed input slots
		outputIdx := 0
		for valueIdx := 0; valueIdx < 4; valueIdx++ {
			inputOffset := valueIdx * 4 // Each input value occupies 4 bytes
			length := lengths[valueIdx]

			// Extract the needed bytes from this value
			for byteIdx := 0; byteIdx < length; byteIdx++ {
				if outputIdx < 16 {
					permutation[outputIdx] = byte(inputOffset + byteIdx)
					outputIdx++
				}
			}
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d,%d,%d] lengths=[%d,%d,%d,%d]\n",
			controlByte, code0, code1, code2, code3, lengths[0], lengths[1], lengths[2], lengths[3],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// uvar32x4WriteLenByControl256 contains the total byte length for each control byte")
	fmt.Fprintln(file, "var uvar32x4WriteLenByControl256 = [256]int{")

	for controlByte := 0; controlByte < 256; controlByte++ {
		code0 := controlByte & 0x3
		code1 := (controlByte >> 2) & 0x3
		code2 := (controlByte >> 4) & 0x3
		code3 := (controlByte >> 6) & 0x3

		lengths := [4]int{
			[]int{0, 1, 2, 4}[code0],
			[]int{0, 1, 2, 4}[code1],
			[]int{0, 1, 2, 4}[code2],
			[]int{0, 1, 2, 4}[code3],
		}

		totalLength := 1 + lengths[0] + lengths[1] + lengths[2] + lengths[3] // +1 for control byte
		if controlByte%16 == 0 {
			fmt.Fprintf(file, "\n\t")
		}
		fmt.Fprintf(file, "%d, ", totalLength)
	}

	fmt.Fprintln(file, "\n}")
}

// generateUvar64x2WriteLUT generates a lookup table for SIMD permutation operations
// for packing 2 variable-length uint64 values
func generateUvar64x2WriteLUT() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	filePath := path.Join(dir, "uvar64x2_lut.go")
	fmt.Printf("Writing file %s...\n", filePath)

	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	fmt.Fprintln(file, "")
	fmt.Fprintln(
		file,
		"// uvar64x2WritePermute128 contains SIMD permutation indices for packing 2 variable-length uint64 values",
	)
	fmt.Fprintln(file, "// The table maps control byte values (0-255) to 16-byte permutation patterns")
	fmt.Fprintln(
		file, "// Each entry describes how to extract bytes from fixed 8-byte slots and pack them sequentially",
	)
	fmt.Fprintln(
		file, "// Input layout: [value0:8bytes][value1:8bytes] (16 bytes total)",
	)
	fmt.Fprintln(file, "var uvar64x2WritePermute128 = [256][16]byte{")

	// Generate all 256 possible control byte combinations
	for controlByte := 0; controlByte < 256; controlByte++ {
		// Extract 4-bit length codes for each of the 2 values
		code0 := controlByte & 0xF        // bits 0-3 (first value byte length 0-8)
		code1 := (controlByte >> 4) & 0xF // bits 4-7 (second value byte length 0-8)

		// Convert codes to byte lengths: 0->0, 1->1, 2->2, ..., 8->8
		lengths := [2]int{
			int(code0),
			int(code1),
		}

		// Create permutation pattern for 16-byte output
		// We'll pack the needed bytes sequentially at the beginning
		var permutation [16]byte

		// Initialize all indices to 0x80 (top bit set = zero write)
		for i := range permutation {
			permutation[i] = 0x80
		}

		// Pack bytes sequentially from the 2 fixed input slots
		outputIdx := 0
		for valueIdx := 0; valueIdx < 2; valueIdx++ {
			inputOffset := valueIdx * 8 // Each input value occupies 8 bytes
			length := lengths[valueIdx]

			// Extract the needed bytes from this value
			for byteIdx := 0; byteIdx < length; byteIdx++ {
				if outputIdx < 16 {
					permutation[outputIdx] = byte(inputOffset + byteIdx)
					outputIdx++
				}
			}
		}

		// Output the permutation table entry
		fmt.Fprintf(file, "\t{")
		for i, idx := range permutation {
			if i > 0 {
				fmt.Fprintf(file, ", ")
			}
			fmt.Fprintf(file, "%d", idx)
		}
		fmt.Fprintf(
			file, "}, // controlByte=0x%02X codes=[%d,%d] lengths=[%d,%d]\n",
			controlByte, code0, code1, lengths[0], lengths[1],
		)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")
}
