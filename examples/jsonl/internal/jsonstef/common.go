// Code generated by stefc. DO NOT EDIT.
package jsonstef

import (
	"fmt"
	"math"

	"github.com/splunk/stef/go/pkg/schema"
)

// The STEF IDL string. Used for testing.
const allSchemaContent = "package jsonstef\n\n// The struct with \"root\" attribute defines the records in a STEF stream.\nstruct Record root {\n  // List fields in this struct, the syntax is: FieldName FieldType.\n  // Each record in this STEF stream is a JsonValue.\n  Value JsonValue\n}\n\n// A oneof can store one of the the listed fields.\n// Empty oneof is the equivalent of \"null\" in JSON.\noneof JsonValue {\n  Object JsonObject\n  Array  []JsonValue\n  String string\n  Number float64\n  Bool   bool\n}\n\n// A multimap is a key-value list.\nmultimap JsonObject {\n  key   string\n  value JsonValue\n}\n"

// StructFieldCounts is used to keep track of the number of fields in each struct
// of an associated schema and to iterate over the fields.
// Field counts will be fetched from the iterator if the struct is encountered
// for the first time and then remembered for subsequent calls (for the case when
// the same struct is used multiple times in the schema).
type StructFieldCounts struct {
	countJsonValue uint // Number of fields in JsonValue struct.
	countRecord    uint // Number of fields in Record struct.

	// OverrideSchema is set if codec should perform a translation from specified schema.
	overrideSchema     bool
	overrideSchemaIter schema.WireSchemaIter
}

func (s *StructFieldCounts) Init(overrideSchema *schema.WireSchema) {
	if overrideSchema != nil {
		s.overrideSchema = true
		s.overrideSchemaIter = schema.NewWireSchemaIter(overrideSchema)
	}

	// Initialize all struct field counts to math.MaxUint, indicating that the field count
	// is not known.
	s.countJsonValue = math.MaxUint
	s.countRecord = math.MaxUint

}

// Get the field count for a specific struct/oneof.
// It is expected that the order in which this function is called matches
// the order in which the WireSchemaIter iterates over the structs (see WireSchema).
func getFieldCount(fieldCount *uint, fieldName string, overrideSchema bool, overrideSchemaIter *schema.WireSchemaIter, defaultCount uint) (uint, error) {
	if *fieldCount == math.MaxUint {
		// Field count is not known, we need to determine it.
		if overrideSchema {
			// Get the field count from the override schema.
			var err error
			*fieldCount, err = overrideSchemaIter.NextFieldCount()
			if err != nil {
				return 0, fmt.Errorf("cannot find struct %s in override schema: %v", fieldName, err)
			}
		} else {
			// Schema is not overridden. Use the compile-time struct field count.
			*fieldCount = defaultCount
		}
	} else {
		// Field count is already known, return it.
	}
	return *fieldCount, nil
}

func (s *StructFieldCounts) JsonValueFieldCount() (uint, error) {
	return getFieldCount(&s.countJsonValue, "JsonValue", s.overrideSchema, &s.overrideSchemaIter, 5)
}

func (s *StructFieldCounts) RecordFieldCount() (uint, error) {
	return getFieldCount(&s.countRecord, "Record", s.overrideSchema, &s.overrideSchemaIter, 1)
}

func (s *StructFieldCounts) AllFetched() bool {
	return s.overrideSchema == false || s.overrideSchemaIter.Done()
}

type Allocators struct {
	JsonValue JsonValueAllocator
	Record    RecordAllocator
}

// Maximum number of objects to create per mutateRandom call.
const mutateRandomMaxObjects = 100

// Maximum number of array or multimap elements to create per mutateRandom call.
const mutateRandomMaxElems = 100

// mutateRandomLimiter is used to track and limit the total number of objects and elements
// created during a mutateRandom call.
type mutateRandomLimiter struct {
	objectCount int
	elemCount   int
}
