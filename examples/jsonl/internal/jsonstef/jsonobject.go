// Code generated by stefgen. DO NOT EDIT.
package jsonstef

import (
	"math/rand/v2"
	"slices"
	"strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

// JsonObject is a multimap, (aka an associative array or a list) of key value
// pairs from string to JsonValue.
type JsonObject struct {
	elems       []JsonObjectElem
	initedCount int

	parentModifiedFields *modifiedFields
	parentModifiedBit    uint64
}

type JsonObjectElem struct {
	key   string
	value JsonValue
}

func (e *JsonObjectElem) Key() string {
	return e.key
}

func (e *JsonObjectElem) Value() *JsonValue {
	return &e.value
}

func (m *JsonObject) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	m.parentModifiedFields = parentModifiedFields
	m.parentModifiedBit = parentModifiedBit
}

// Clone() creates a deep copy of JsonObject
func (m *JsonObject) Clone() JsonObject {
	clone := JsonObject{}
	copyJsonObject(&clone, m)
	return clone
}

// Len returns the number of elements in the multimap.
func (m *JsonObject) Len() int {
	return len(m.elems)
}

// At returns element at index i.
func (m *JsonObject) At(i int) *JsonObjectElem {
	return &m.elems[i]
}

// EnsureLen ensures the length of the multimap is equal to newLen.
// It will grow or shrink the multimap if needed.
func (m *JsonObject) EnsureLen(newLen int) {
	oldLen := len(m.elems)
	if newLen != oldLen {
		m.elems = pkg.EnsureLen(m.elems, newLen)
		// Init elements with pointers to the parent struct.
		for i := m.initedCount; i < newLen; i++ {
			m.elems[i].value.init(m.parentModifiedFields, m.parentModifiedBit)
		}
		if m.initedCount < newLen {
			m.initedCount = newLen
		}
		m.markModified()
	}
}

func (m *JsonObject) markModified() {
	m.parentModifiedFields.markModified(m.parentModifiedBit)
}

func (m *JsonObject) isModified() bool {
	return m.parentModifiedFields.isModified(m.parentModifiedBit)
}

func (m *JsonObject) markUnmodified() {
	m.parentModifiedFields.markUnmodified()
}

func (m *JsonObject) markModifiedRecursively() {
	for i := 0; i < len(m.elems); i++ {
		m.elems[i].value.markModifiedRecursively()
	}
}

func (m *JsonObject) markUnmodifiedRecursively() {
	for i := 0; i < len(m.elems); i++ {
		m.elems[i].value.markUnmodifiedRecursively()
	}
}

// markDiffModified marks fields in each key and value of this multimap modified if they
// differ from the corresponding fields in v.
func (m *JsonObject) markDiffModified(v *JsonObject) (modified bool) {
	if len(m.elems) != len(v.elems) {
		// Array lengths are different, so they are definitely different.
		modified = true
	}

	// Scan the elements and mark them as modified if they are different.
	minLen := min(len(m.elems), len(v.elems))
	for i := 0; i < minLen; i++ {
		if !pkg.StringEqual(m.elems[i].key, v.elems[i].key) {
			modified = true
		}

		if m.elems[i].value.markDiffModified(&v.elems[i].value) {
			modified = true
		}
	}

	// Mark the rest of the elements as modified.
	for i := minLen; i < len(m.elems); i++ {
		m.elems[i].value.markModifiedRecursively()
	}

	if modified {
		m.markModified()
	}

	return modified
}

// markDiffModified marks fields in each value of this multimap modified if they
// differ from the corresponding fields in v.
// This function assumes the keys are the same and the lengths of multimaps are the same.
func (m *JsonObject) markValueDiffModified(v *JsonObject) (modified bool) {
	// Scan the elements and mark them as modified if they are different.
	for i := 0; i < len(m.elems); i++ {
		if m.elems[i].value.markDiffModified(&v.elems[i].value) {
			modified = true
		}
	}

	if modified {
		m.markModified()
	}

	return modified
}

// SetKey sets the key of the element at index i.
func (m *JsonObject) SetKey(i int, k string) {
	if m.elems[i].key != k {
		m.elems[i].key = k
		m.markModified()
	}
}

func (m *JsonObject) Sort() {
	slices.SortFunc(m.elems, func(a, b JsonObjectElem) int {
		return strings.Compare(a.key, b.key)
	})
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (m *JsonObject) byteSize() uint {
	return uint(unsafe.Sizeof(JsonObjectElem{}))*uint(len(m.elems)) + uint(unsafe.Sizeof(m.elems))
}

func copyJsonObject(dst *JsonObject, src *JsonObject) {
	modified := false
	if len(dst.elems) != len(src.elems) {
		dst.EnsureLen(len(src.elems))
		modified = true
	}
	for i := 0; i < len(src.elems); i++ {
		if dst.elems[i].key != src.elems[i].key {
			dst.elems[i].key = src.elems[i].key
			modified = true
		}

		if !JsonValueEqual(&dst.elems[i].value, &src.elems[i].value) {
			copyJsonValue(&dst.elems[i].value, &src.elems[i].value)
			modified = true
		}
	}

	if modified {
		dst.markModified()
	}
}

func (m *JsonObject) CopyFrom(src *JsonObject) {
	copyJsonObject(m, src)
}

func (e *JsonObject) IsEqual(val *JsonObject) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		if !pkg.StringEqual(e.elems[i].key, val.elems[i].key) {
			return false
		}
		if !e.elems[i].value.IsEqual(&val.elems[i].value) {
			return false
		}
	}
	return true
}

func JsonObjectEqual(left, right *JsonObject) bool {
	return left.IsEqual(right)
}

func CmpJsonObject(left, right *JsonObject) int {
	l := min(len(left.elems), len(right.elems))
	for i := 0; i < l; i++ {
		c := strings.Compare(left.elems[i].key, right.elems[i].key)
		if c != 0 {
			return c
		}
	}
	lenDiff := len(left.elems) - len(right.elems)

	if lenDiff != 0 {
		return lenDiff
	}

	for i := 0; i < l; i++ {
		c := CmpJsonValue(
			&left.elems[i].value,
			&right.elems[i].value,
		)
		if c != 0 {
			return c
		}
	}
	return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. If key or value contains structs/oneofs
// only fields that exist in the schema are mutated, allowing to generate data for
// specified schema.
func (m *JsonObject) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	if random.IntN(20) == 0 {
		m.EnsureLen(m.Len() + 1)
	}
	if random.IntN(20) == 0 && m.Len() > 0 {
		m.EnsureLen(m.Len() - 1)
	}

	for i := range m.elems {
		_ = i
		if random.IntN(4*len(m.elems)) == 0 {
			m.SetKey(i, pkg.StringRandom(random))
		}
		if random.IntN(4*len(m.elems)) == 0 {
			m.elems[i].value.mutateRandom(random, schem)
		}
	}
}

type JsonObjectEncoder struct {
	buf     pkg.BytesWriter
	columns pkg.WriteColumnSet
	limiter *pkg.SizeLimiter

	keyEncoder       *encoders.StringEncoder
	isKeyRecursive   bool
	valueEncoder     *JsonValueEncoder
	isValueRecursive bool
	// lastValStack are last encoded values stacked by the level of recursion.
	lastValStack JsonObjectLastValStack
}
type JsonObjectLastValStack []*JsonObjectLastValElem

func (s *JsonObjectLastValStack) init() {
	// We need one top-level element in the stack to store the last value initially.
	s.addOnTop()
}

func (s *JsonObjectLastValStack) reset() {
	// Reset all elements in the stack.
	t := (*s)[:cap(*s)]
	for i := 0; i < len(t); i++ {
		t[i].reset()
	}
	// Reset the stack to have one element for top-level.
	*s = (*s)[:1]
}

func (s *JsonObjectLastValStack) top() *JsonObjectLastValElem {
	return (*s)[len(*s)-1]
}

func (s *JsonObjectLastValStack) addOnTopSlow() {
	elem := &JsonObjectLastValElem{}
	elem.init()
	*s = append(*s, elem)
	t := (*s)[0:cap(*s)]
	for i := len(*s); i < len(t); i++ {
		// Ensure that all elements in the stack are initialized.
		t[i] = &JsonObjectLastValElem{}
		t[i].init()
	}
}

func (s *JsonObjectLastValStack) addOnTop() {
	if len(*s) < cap(*s) {
		*s = (*s)[:len(*s)+1]
		return
	}
	s.addOnTopSlow()
}

func (s *JsonObjectLastValStack) removeFromTop() {
	*s = (*s)[:len(*s)-1]
}

type JsonObjectLastValElem struct {
	val            JsonObject
	modifiedFields modifiedFields
}

func (e *JsonObjectLastValElem) init() {
	e.val.init(&e.modifiedFields, 1)
}

func (e *JsonObjectLastValElem) reset() {
	e.val = JsonObject{}
}

func (e *JsonObjectEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	// Remember this encoder in the state so that we can detect recursion.
	if state.JsonObjectEncoder != nil {
		panic("cannot initialize JsonObjectEncoder: already initialized")
	}
	state.JsonObjectEncoder = e
	defer func() { state.JsonObjectEncoder = nil }()

	e.limiter = &state.limiter

	var err error
	e.keyEncoder = new(encoders.StringEncoder)
	err = e.keyEncoder.Init(nil, e.limiter, columns.AddSubColumn())
	if err != nil {
		return nil
	}
	if state.JsonValueEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.valueEncoder = state.JsonValueEncoder
		e.isValueRecursive = true
	} else {
		e.valueEncoder = new(JsonValueEncoder)
		err = e.valueEncoder.Init(state, columns.AddSubColumn())
	}
	e.lastValStack.init()

	return err
}

func (e *JsonObjectEncoder) Reset() {
	if !e.isKeyRecursive {
		e.keyEncoder.Reset()
	}
	if !e.isValueRecursive {
		e.valueEncoder.Reset()
	}
	e.lastValStack.reset()
}

func (e *JsonObjectEncoder) Encode(list *JsonObject) (changed bool) {
	oldLen := len(e.buf.Bytes())
	lastVal := &e.lastValStack.top().val
	e.lastValStack.addOnTop()
	defer func() { e.lastValStack.removeFromTop() }()

	if len(list.elems) == 0 {
		// Zero-length attr list.
		e.buf.WriteUvarint(0b1)

		changed = len(lastVal.elems) != 0
		lastVal.elems = pkg.EnsureLen(lastVal.elems, 0)

		newLen := len(e.buf.Bytes())
		e.limiter.AddFrameBytes(uint(newLen - oldLen))

		return changed
	}

	if list.isSameKeys(lastVal) && len(lastVal.elems) < 63 {
		list.markValueDiffModified(lastVal)
		changed = e.encodeValuesOnly(lastVal, list)
	} else {
		list.markDiffModified(lastVal)
		e.encodeFull(lastVal, list)
		changed = true
	}

	newLen := len(e.buf.Bytes())
	e.limiter.AddFrameBytes(uint(newLen - oldLen))

	return changed
}

func (e *JsonObjectEncoder) encodeValuesOnly(lastVal *JsonObject, list *JsonObject) (changed bool) {
	if len(list.elems) > 62 {
		// TODO: implement this case.
		panic("not implemented")
	}

	// Calculate changed values.
	changedValuesBits := uint64(0)
	for i := range list.elems {
		changedValuesBits <<= 1
		if !JsonValueEqual(&lastVal.elems[i].value, &list.elems[i].value) {
			changedValuesBits |= 1
		}
	}

	e.buf.WriteUvarint(changedValuesBits << 1)

	// Encode changed values first.
	bitToRead := uint64(1) << (len(list.elems) - 1)
	for i := range list.elems {
		if (bitToRead & changedValuesBits) != 0 {
			e.valueEncoder.Encode(&list.elems[i].value)
		}
		bitToRead >>= 1
		if bitToRead == 0 {
			break
		}
	}

	// Store changed values in lastVal after encoding.
	lastVal.EnsureLen(len(list.elems))
	bitToRead = uint64(1) << (len(list.elems) - 1)
	for i := range list.elems {
		if (bitToRead & changedValuesBits) != 0 {
			copyJsonValue(&lastVal.elems[i].value, &list.elems[i].value)
		}
		bitToRead >>= 1
		if bitToRead == 0 {
			break
		}
	}

	return changedValuesBits != 0
}

func (e *JsonObjectEncoder) encodeFull(lastVal *JsonObject, list *JsonObject) {
	e.buf.WriteUvarint(uint64(len(list.elems))<<1 | 0b1)

	// Encode values first.
	for i := range list.elems {
		e.keyEncoder.Encode(list.elems[i].key)
		e.valueEncoder.Encode(&list.elems[i].value)
	}

	// Store changed values in lastVal.
	lastVal.EnsureLen(len(list.elems))
	for i := range list.elems {
		lastVal.elems[i].key = list.elems[i].key
		copyJsonValue(&lastVal.elems[i].value, &list.elems[i].value)
	}
}

func (val1 *JsonObject) isSameKeys(val2 *JsonObject) bool {
	if len(val1.elems) != len(val2.elems) {
		return false
	}

	for i := range val1.elems {
		// Attribute key.
		if val1.elems[i].key != val2.elems[i].key {
			return false
		}
	}

	return true
}

func (e *JsonObjectEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBytes(&e.buf)
	if !e.isKeyRecursive {
		e.keyEncoder.CollectColumns(columnSet.At(0))
	}
	if !e.isValueRecursive {
		e.valueEncoder.CollectColumns(columnSet.At(1))
	}
}

type JsonObjectDecoder struct {
	buf    pkg.BytesReader
	column *pkg.ReadableColumn

	keyDecoder       *encoders.StringDecoder
	isKeyRecursive   bool
	valueDecoder     *JsonValueDecoder
	isValueRecursive bool
	// lastValStack are last decoded values stacked by the level of recursion.
	lastValStack JsonObjectLastValStack
}

// Init is called once in the lifetime of the stream.
func (d *JsonObjectDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	// Remember this decoder in the state so that we can detect recursion.
	if state.JsonObjectDecoder != nil {
		panic("cannot initialize JsonObjectDecoder: already initialized")
	}
	state.JsonObjectDecoder = d
	defer func() { state.JsonObjectDecoder = nil }()

	d.column = columns.Column()

	var err error
	d.keyDecoder = new(encoders.StringDecoder)
	err = d.keyDecoder.Init(nil, columns.AddSubColumn())
	if err != nil {
		return nil
	}
	if state.JsonValueDecoder != nil {
		// Recursion detected, use the existing decoder.
		d.valueDecoder = state.JsonValueDecoder
		d.isValueRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.valueDecoder = new(JsonValueDecoder)
		err = d.valueDecoder.Init(state, columns.AddSubColumn())
	}
	d.lastValStack.init()

	return err
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *JsonObjectDecoder) Continue() {
	d.buf.Reset(d.column.Data())
	if !d.isKeyRecursive {
		d.keyDecoder.Continue()
	}
	if !d.isValueRecursive {
		d.valueDecoder.Continue()
	}
}

func (d *JsonObjectDecoder) Reset() {
	if !d.isKeyRecursive {
		d.keyDecoder.Reset()
	}
	if !d.isValueRecursive {
		d.valueDecoder.Reset()
	}
	d.lastValStack.reset()
}

func (d *JsonObjectDecoder) Decode(dst *JsonObject) error {
	lastVal := &d.lastValStack.top().val
	d.lastValStack.addOnTop()
	defer func() { d.lastValStack.removeFromTop() }()

	countOrChangedValues, err := d.buf.ReadUvarint()
	if err != nil {
		return err
	}
	if countOrChangedValues == 0 {
		// Nothing changed.
		return d.decodeCopyOfLast(lastVal, dst)
	}

	if countOrChangedValues&0b1 == 0 {
		return d.decodeValuesOnly(lastVal, countOrChangedValues>>1, dst)
	}

	if countOrChangedValues&0b1 == 0b1 {
		return d.decodeFull(lastVal, int(countOrChangedValues>>1), dst)
	}
	return pkg.ErrMultimap
}

func (d *JsonObjectDecoder) decodeCopyOfLast(lastVal *JsonObject, dst *JsonObject) error {
	dst.EnsureLen(len(lastVal.elems))
	for i := range dst.elems {
		dst.elems[i].key = lastVal.elems[i].key
		copyJsonValue(&dst.elems[i].value, &lastVal.elems[i].value)
	}
	return nil
}

func (d *JsonObjectDecoder) decodeValuesOnly(lastVal *JsonObject, changedValuesBits uint64, dst *JsonObject) error {
	if len(lastVal.elems) == 0 {
		// The last attrs empty so value-only encoding does not make sense.
		return pkg.ErrMultimap
	}

	count := len(lastVal.elems)
	dst.EnsureLen(count)

	// Copy unchanged values from lastVal
	bitToRead := uint64(1) << (len(dst.elems) - 1)
	for i := range dst.elems {
		// Copy the key from lastVal. All keys are the same.
		dst.elems[i].key = lastVal.elems[i].key
		if (bitToRead & changedValuesBits) == 0 {
			// Value is not changed, copy from lastVal.
			copyJsonValue(&dst.elems[i].value, &lastVal.elems[i].value)
		}
		bitToRead >>= 1
	}

	// Decode changed values
	var err error
	bitToRead = uint64(1) << (len(dst.elems) - 1)
	for i := range dst.elems {
		if (bitToRead & changedValuesBits) != 0 {
			// Value is changed, decode it.
			err = d.valueDecoder.Decode(&dst.elems[i].value)
			if err != nil {
				return err
			}
			// Store the values in lastVal
			copyJsonValue(&lastVal.elems[i].value, &dst.elems[i].value)
		}
		bitToRead >>= 1
	}

	return nil
}

func (d *JsonObjectDecoder) decodeFull(lastVal *JsonObject, count int, dst *JsonObject) error {
	if count < 0 || count >= pkg.MultimapElemCountLimit {
		return pkg.ErrMultimapCountLimit
	}

	dst.EnsureLen(count)
	lastVal.EnsureLen(count)

	// Decode values first.
	var err error
	for i := 0; i < count; i++ {
		err = d.keyDecoder.Decode(&dst.elems[i].key)
		if err != nil {
			return err
		}
		err = d.valueDecoder.Decode(&dst.elems[i].value)
		if err != nil {
			return err
		}

		// Store decoded values in lastVal.
		lastVal.elems[i].key = dst.elems[i].key
		copyJsonValue(&lastVal.elems[i].value, &dst.elems[i].value)
	}

	return nil
}
