// Code generated by stefgen. DO NOT EDIT.
package jsonstef

import (
	"bytes"
	"fmt"
	"io"
	"math/rand/v2"
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/idl"
	"github.com/splunk/stef/go/pkg/schema"
)

// genRecordRecords generates a number of records pseudo-randomly
// using the supplied Rand generator. Generated records will be always
// the same for the same input state of Rand generator.
// Generated records will only have fields set (mutated) that are defined
// in the supplied schema. This allows testing schema evolution.
func genRecordRecords(random *rand.Rand, schem *schema.Schema) (records []Record) {
	const recCount = 1000
	var record Record
	allocators := &Allocators{}
	record.Init(allocators)

	records = make([]Record, recCount)
	for i := 0; i < recCount; i++ {
		record.mutateRandom(random, schem)
		records[i].Init(allocators)
		records[i].CopyFrom(&record)
	}

	return records
}

func TestRecordWriteRead(t *testing.T) {
	opts := []pkg.WriterOptions{
		{},
		{Compression: pkg.CompressionZstd},
		{MaxUncompressedFrameByteSize: 500},
		{MaxTotalDictSize: 500},
		{
			Compression:                  pkg.CompressionZstd,
			MaxUncompressedFrameByteSize: 500,
			MaxTotalDictSize:             500,
		},
		{FrameRestartFlags: pkg.RestartDictionaries},
		{FrameRestartFlags: pkg.RestartCodecs},
		{FrameRestartFlags: pkg.RestartDictionaries | pkg.RestartCodecs},
		{FrameRestartFlags: pkg.RestartCompression, Compression: pkg.CompressionZstd},
		{
			FrameRestartFlags: pkg.RestartDictionaries | pkg.RestartCodecs | pkg.RestartCompression,
			Compression:       pkg.CompressionZstd,
		},
		{
			FrameRestartFlags:            pkg.RestartCodecs,
			MaxUncompressedFrameByteSize: 500,
		},
	}

	// Choose a seed (non-pseudo) randomly. We will print the seed
	// on failure for easy reproduction.
	seed1 := uint64(time.Now().UnixNano())
	seed1 = 1758059136221252000
	random := rand.New(rand.NewPCG(seed1, 0))

	// Load the schema from the allSchemaContent variable.
	schem, err := idl.Parse([]byte(allSchemaContent), "")
	require.NoError(t, err, "seed %v", seed1)

	schem, err = schem.PrunedForRoot("Record")
	require.NoError(t, err, "seed %v", seed1)

	if random.IntN(2) == 0 {
		// Randomly shrink the schema in approximately half of the test runs.
		// This is to test that the writer/reader can handle schema changes.
		schema.ShrinkRandomly(random, schem)
	}
	wireSchema := schema.NewWireSchema(schem, "Record")

	for j, opt := range opts {
		t.Run(
			"", func(t *testing.T) {
				succeeded := false
				defer func() {
					if !succeeded {
						fmt.Printf("Test failed with seed %v\n", seed1)
					}
				}()

				// Write data according to (possibly modified) schema
				opt.Schema = &wireSchema

				buf := &pkg.MemChunkWriter{}
				writer, err := NewRecordWriter(buf, opt)
				require.NoError(t, err, "seed %v", seed1)

				// Generate records pseudo-randomly
				records := genRecordRecords(random, schem)
				// Write the records
				for i := 0; i < len(records); i++ {
					if j == 0 && i == 26 {
						_ = i
					}
					writer.Record.CopyFrom(&records[i])
					err = writer.Write()
					require.NoError(t, err, "record %d seed %v", i, seed1)
				}
				err = writer.Flush()
				require.NoError(t, err, "seed %v", seed1)

				// Read the records and compare to written.
				reader, err := NewRecordReader(bytes.NewBuffer(buf.Bytes()))
				require.NoError(t, err, "seed %v", seed1)

				for i := 0; i < len(records); i++ {
					if j == 0 && i == 26 {
						_ = i
					}
					err := reader.Read(pkg.ReadOptions{})
					require.NoError(t, err, "record %d seed %v", i, seed1)
					require.NotNil(t, reader.Record, "record %d seed %v", i, seed1)
					require.True(t, reader.Record.IsEqual(&records[i]), "record %d seed %v", i, seed1)
				}
				err = reader.Read(pkg.ReadOptions{})
				require.Error(t, io.EOF, seed1)

				succeeded = true
			},
		)
	}
}
