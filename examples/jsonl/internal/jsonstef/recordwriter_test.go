// Code generated by stefc. DO NOT EDIT.
package jsonstef

import (
	"bytes"
	"fmt"
	"io"
	"math/rand/v2"
	"os"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/idl"
	"github.com/splunk/stef/go/pkg/schema"
)

// genRecordRecords generates a number of records pseudo-randomly
// using the supplied Rand generator. Generated records will be always
// the same for the same input state of Rand generator.
// Generated records will only have fields set (mutated) that are defined
// in the supplied schema. This allows testing schema evolution.
func genRecordRecords(random *rand.Rand, schem *schema.Schema) (records []Record) {
	const recCount = 1000
	var record Record
	record.Init()

	records = make([]Record, recCount)
	for i := 0; i < recCount; i++ {
		limiter := &mutateRandomLimiter{}
		record.mutateRandom(random, schem, limiter)
		records[i].Init()
		records[i].CopyFrom(&record)
	}

	return records
}

func testRecordWriteReadSeed(t *testing.T, seed uint64) (retVal bool) {
	retVal = true

	random := rand.New(rand.NewPCG(seed, 0))

	// Load the schema from the allSchemaContent variable.
	schem, err := idl.Parse([]byte(allSchemaContent), "")
	require.NoError(t, err, "seed %v", seed)

	schem, err = schem.PrunedForRoot("Record")
	require.NoError(t, err, "seed %v", seed)

	if random.IntN(2) == 0 {
		// Randomly shrink the schema in approximately half of the test runs.
		// This is to test that the writer/reader can handle schema changes.
		schema.ShrinkRandomly(random, schem)
	}
	wireSchema := schema.NewWireSchema(schem, "Record")

	for _, opt := range testWriterOpts {
		t.Run(
			"", func(t *testing.T) {
				succeeded := false
				defer func() {
					if !succeeded {
						retVal = false
						fmt.Printf("Test failed with seed %v\n", seed)
					}
				}()

				// Write data according to (possibly modified) schema
				optCpy := opt
				optCpy.Schema = &wireSchema

				buf := &pkg.MemChunkWriter{}
				writer, err := NewRecordWriter(buf, optCpy)
				require.NoError(t, err, "seed %v", seed)
				defer writer.Close()

				// Generate records pseudo-randomly
				records := genRecordRecords(random, schem)
				// Write the records
				for i := 0; i < len(records); i++ {
					writer.Record.CopyFrom(&records[i])
					err = writer.Write()
					require.NoError(t, err, "record %d seed %v", i, seed)
				}
				err = writer.Flush()
				require.NoError(t, err, "seed %v", seed)

				// Read the records and compare to written.
				reader, err := NewRecordReader(bytes.NewBuffer(buf.Bytes()))
				require.NoError(t, err, "seed %v", seed)

				for i := 0; i < len(records); i++ {
					err := reader.Read(pkg.ReadOptions{})
					require.NoError(t, err, "record %d seed %v", i, seed)
					require.True(t, reader.Record.IsEqual(&records[i]), "record %d seed %v", i, seed)
				}
				err = reader.Read(pkg.ReadOptions{})
				require.ErrorIs(t, err, io.EOF, seed)

				succeeded = true
			},
		)
	}
	return retVal
}

func TestRecordWriteRead(t *testing.T) {
	seedFileName := "../../../seeds/jsonstef_Record_seeds.txt"
	seedsBytes, err := os.ReadFile(seedFileName)
	var seeds []string
	if err == nil {
		seeds = strings.Split(strings.TrimSpace(string(seedsBytes)), "\n")
	}

	for _, seedStr := range seeds {
		seed, err := strconv.ParseUint(seedStr, 10, 64)
		fmt.Printf("Testing with seed from file: %v\n", seed)
		require.NoError(t, err, "parsing seed from file "+seedFileName)
		testRecordWriteReadSeed(t, seed)
	}

	// Choose a seed (non-pseudo) randomly. We will print the seed
	// on failure for easy reproduction.
	seed := uint64(time.Now().UnixNano())

	succeeded := false
	defer func() {
		if !succeeded {
			fmt.Printf("Test failed with seed %v, adding to seed file\n", seed)
			err := os.WriteFile(seedFileName,
				[]byte(string(seedsBytes)+fmt.Sprintf("%v\n", seed)), 0644)
			require.NoError(t, err)
		}
	}()

	succeeded = testRecordWriteReadSeed(t, seed)
}

func TestRecordWriteReadLong(t *testing.T) {
	// Tests writing and reading a larger number of records
	// in a single writer/reader session.

	seed := uint64(time.Now().UnixNano())
	random := rand.New(rand.NewPCG(seed, 0))

	schem, err := idl.Parse([]byte(allSchemaContent), "")
	require.NoError(t, err, "seed %v", seed)

	schem, err = schem.PrunedForRoot("Record")
	require.NoError(t, err, "seed %v", seed)

	mem := &pkg.MemReaderWriter{}

	writer, err := NewRecordWriter(mem, pkg.WriterOptions{Compression: pkg.CompressionZstd})
	require.NoError(t, err, "seed %v", seed)
	defer writer.Close()

	reader, err := NewRecordReader(mem)
	require.NoError(t, err, "seed %v", seed)

	iterations := 10
	if os.Getenv("STEF_ENABLE_SLOW_TESTS") == "1" {
		iterations = 100
	}

	var record Record
	record.Init()

	records := make([]Record, 1000)
	for i := 0; i < iterations; i++ {
		recCount := 1 + random.IntN(1000)
		records = records[:recCount]

		// Write some records.
		for recIdx := range records {
			limiter := &mutateRandomLimiter{}
			record.mutateRandom(random, schem, limiter)
			records[recIdx] = Record{}
			records[recIdx].Init()
			records[recIdx].CopyFrom(&record)
			writer.Record.CopyFrom(&record)
			err = writer.Write()
			require.NoError(t, err, "record %d:%d seed %v", i, recIdx, seed)
		}

		// Flush to make sure the records are in the MemReaderWriter and can be
		// read back.
		err = writer.Flush()
		require.NoError(t, err, "iteration %d seed %v", i, seed)

		// Read the records back and compare.
		for recIdx := range records {
			err = reader.Read(pkg.ReadOptions{})
			require.NoError(t, err, "record %d:%d seed %v", i, recIdx, seed)
			require.True(t, reader.Record.IsEqual(&records[recIdx]), "record %d:%d seed %v", i, recIdx, seed)
		}
	}

	err = reader.Read(pkg.ReadOptions{})
	require.ErrorIs(t, err, io.EOF, seed)
}

func FuzzRecordReader(f *testing.F) {
	f.Add([]byte(""))

	random := rand.New(rand.NewPCG(0, 0))
	schem, err := idl.Parse([]byte(allSchemaContent), "")
	require.NoError(f, err)

	for _, opt := range testWriterOpts {
		for i := 0; i <= 3; i++ {
			buf := &pkg.MemChunkWriter{}
			writer, err := NewRecordWriter(buf, opt)
			require.NoError(f, err)
			defer writer.Close()

			recCount := (1 << (2 * i)) - 1
			var record Record
			record.Init()
			for range recCount {
				limiter := &mutateRandomLimiter{}
				record.mutateRandom(random, schem, limiter)
				writer.Record.CopyFrom(&record)
				err = writer.Write()
				require.NoError(f, err)
			}

			err = writer.Flush()
			require.NoError(f, err)

			f.Add(buf.Bytes())
		}
	}

	f.Fuzz(
		func(t *testing.T, data []byte) {
			reader, err := NewRecordReader(bytes.NewBuffer(data))
			if err != nil {
				return
			}
			for {
				err = reader.Read(pkg.ReadOptions{})
				if err != nil {
					break
				}
			}
		},
	)
}
