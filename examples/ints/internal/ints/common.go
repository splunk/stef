// Code generated by stefc. DO NOT EDIT.
package ints

import (
	"fmt"
	"math"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/schema"
)

// The STEF IDL string. Used for testing.
const allSchemaContent = "package ints\n\nstruct Record root {\n  Uint64 uint64\n}\n"

// StructFieldCounts is used to keep track of the number of fields in each struct
// of an associated schema and to iterate over the fields.
// Field counts will be fetched from the iterator if the struct is encountered
// for the first time and then remembered for subsequent calls (for the case when
// the same struct is used multiple times in the schema).
type StructFieldCounts struct {
	countRecord uint // Number of fields in Record struct.

	// OverrideSchema is set if codec should perform a translation from specified schema.
	overrideSchema     bool
	overrideSchemaIter schema.WireSchemaIter
}

func (s *StructFieldCounts) Init(overrideSchema *schema.WireSchema) {
	if overrideSchema != nil {
		s.overrideSchema = true
		s.overrideSchemaIter = schema.NewWireSchemaIter(overrideSchema)
	}

	// Initialize all struct field counts to math.MaxUint, indicating that the field count
	// is not known.
	s.countRecord = math.MaxUint

}

// Get the field count for a specific struct/oneof.
// It is expected that the order in which this function is called matches
// the order in which the WireSchemaIter iterates over the structs (see WireSchema).
func getFieldCount(fieldCount *uint, fieldName string, overrideSchema bool, overrideSchemaIter *schema.WireSchemaIter, defaultCount uint) (uint, error) {
	if *fieldCount == math.MaxUint {
		// Field count is not known, we need to determine it.
		if overrideSchema {
			// Get the field count from the override schema.
			var err error
			*fieldCount, err = overrideSchemaIter.NextFieldCount()
			if err != nil {
				return 0, fmt.Errorf("cannot find struct %s in override schema: %v", fieldName, err)
			}
		} else {
			// Schema is not overridden. Use the compile-time struct field count.
			*fieldCount = defaultCount
		}
	} else {
		// Field count is already known, return it.
	}
	return *fieldCount, nil
}

func (s *StructFieldCounts) RecordFieldCount() (uint, error) {
	return getFieldCount(&s.countRecord, "Record", s.overrideSchema, &s.overrideSchemaIter, 1)
}

func (s *StructFieldCounts) AllFetched() bool {
	return s.overrideSchema == false || s.overrideSchemaIter.Done()
}

type Allocators struct {
	Record RecordAllocator

	// allocatedSize tracks the total allocated size in bytes since last resetAllocSize call.
	// This tracking is independent from the individual allocators above, i.e. calls
	// to Alloc() DO NOT result in allocatedSize being updated automatically.
	allocSizeChecker pkg.AllocSizeChecker
}

// Maximum number of objects to create per mutateRandom call.
const mutateRandomMaxObjects = 100

// Maximum number of array or multimap elements to create per mutateRandom call.
const mutateRandomMaxElems = 100

// mutateRandomLimiter is used to track and limit the total number of objects and elements
// created during a mutateRandom call.
type mutateRandomLimiter struct {
	objectCount int
	elemCount   int
}

var testWriterOpts []pkg.WriterOptions = []pkg.WriterOptions{
	{},
	{Compression: pkg.CompressionZstd},
	{MaxUncompressedFrameByteSize: 500},
	{MaxTotalDictSize: 500},
	{
		Compression:                  pkg.CompressionZstd,
		MaxUncompressedFrameByteSize: 500,
		MaxTotalDictSize:             500,
	},
	{FrameRestartFlags: pkg.RestartDictionaries},
	{FrameRestartFlags: pkg.RestartCodecs},
	{FrameRestartFlags: pkg.RestartDictionaries | pkg.RestartCodecs},
	{FrameRestartFlags: pkg.RestartCompression, Compression: pkg.CompressionZstd},
	{
		FrameRestartFlags: pkg.RestartDictionaries | pkg.RestartCodecs | pkg.RestartCompression,
		Compression:       pkg.CompressionZstd,
	},
	{
		FrameRestartFlags:            pkg.RestartCodecs,
		MaxUncompressedFrameByteSize: 500,
	},
}
