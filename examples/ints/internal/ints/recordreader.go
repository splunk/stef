// Code generated by stefc. DO NOT EDIT.
package ints

import (
	"bufio"
	"errors"
	"fmt"
	"io"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/schema"
)

type RecordReader struct {
	// Record contains the record that was just read by the last Read() operation.
	// Do not modify this field externally. The next Read() will overwrite the Record.
	Record Record

	base      pkg.BaseReader
	decoder   RecordDecoder
	state     ReaderState
	recordPtr *Record
}

func NewRecordReader(source io.Reader) (*RecordReader, error) {
	bufferedSource := bufio.NewReaderSize(source, 64*1024)
	reader := &RecordReader{}

	reader.Record.Init()
	reader.recordPtr = &reader.Record

	if err := reader.base.Init(bufferedSource); err != nil {
		return nil, err
	}

	if err := reader.initSchema(); err != nil {
		return nil, err
	}

	return reader, nil
}

func (r *RecordReader) initSchema() error {
	ownSchema, err := RecordWireSchema()
	if err != nil {
		return err
	}
	if err := r.base.ReadVarHeader(ownSchema); err != nil {
		return err
	}

	r.state.Init(r.base.Schema)
	err = r.decoder.Init(&r.state, &r.base.ReadBufs.Columns)
	if err != nil {
		return fmt.Errorf("schema is not compatible with Reader: %w", err)
	}

	if !r.state.StructFieldCounts.AllFetched() {
		return errors.New("override schema iterator is not done, decoded data schema is likely incompatible")
	}

	return nil
}

func (f *RecordReader) Header() *pkg.FixedHeader {
	return &f.base.FixedHeader
}

func (f *RecordReader) UserData() map[string]string {
	return f.base.VarHeader.UserData
}

// Read the next record. After Read() returns successfully the record
// will be accessible in RecordReader.Record field.
//
// If ReadOptions.TillEndOfFrame=true and end of the current
// frame is reached Read() will return pkg.ErrEndOfFrame. Calling Read()
// after that with ReadOptions.TillEndOfFrame=false will correctly load
// the next frame (if any) and read the next record from the frame.
// The very first Read() must use ReadOptions.TillEndOfFrame=false
// otherwise pkg.ErrEndOfFrame will be returned since no frames are
// initially loaded in the Reader. See more details in pkg.ReadOptions.
//
// If Read() encounters a decoding error one of the pkg.Err values will
// be returned.
// If underlying source io.Reader returns any error then Read() will
// either return that error or a decoding error if source io.Reader
// returned an error prematurely while more data was expected in STEF stream.
//
// For well-formed streams that don't encounter decoding errors Read() will
// return io.EOF once end of the underlying source io.Reader is reached
// (assuming io.Reader returns io.EOF itself).
func (r *RecordReader) Read(opts pkg.ReadOptions) error {
	for r.base.FrameRecordCount == 0 {
		if opts.TillEndOfFrame {
			return pkg.ErrEndOfFrame
		}
		if err := r.nextFrame(); err != nil {
			return err
		}
	}
	r.base.FrameRecordCount--
	r.base.RecordCount++

	// Track new memory allocated during decoding of this record.
	r.state.Allocators.resetAllocSize()

	return r.decoder.Decode(r.recordPtr)
}

func (r *RecordReader) RecordCount() uint64 {
	return r.base.RecordCount
}

func (r *RecordReader) nextFrame() error {
	frameFlags, err := r.base.NextFrame()
	if err != nil {
		return err
	}

	if frameFlags&pkg.RestartDictionaries != 0 {
		// The frame that has just started indicates that the dictionaries
		// must be restarted. Reset all dictionaries.
		r.state.ResetDicts()
	}

	if frameFlags&pkg.RestartCodecs != 0 {
		// The frame that has just started indicates that the decoders
		// must be restarted.
		r.decoder.Reset()
	}

	r.decoder.Continue()
	return nil
}

// Schema returns the schema of the STEF stream being read.
func (r *RecordReader) Schema() *schema.WireSchema {
	return r.base.Schema
}
