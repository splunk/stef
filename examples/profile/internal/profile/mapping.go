// Code generated by stefc. DO NOT EDIT.
package profile

import (
	"bytes"
	"fmt"
	"math/rand/v2"
	"strings"
	"unsafe"

	"modernc.org/b/v2"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

var _ = strings.Compare
var _ = encoders.StringEncoder{}
var _ = schema.WireSchema{}
var _ = bytes.NewBuffer

type Mapping struct {
	memoryStart     uint64
	memoryLimit     uint64
	fileOffset      uint64
	filename        string
	buildId         string
	hasFunctions    bool
	hasFilenames    bool
	hasLineNumbers  bool
	hasInlineFrames bool

	// modifiedFields keeps track of which fields are modified.
	modifiedFields modifiedFields
}

const MappingStructName = "Mapping"

// Bitmasks for "modified" flags for each field.
const (
	fieldModifiedMappingMemoryStart = uint64(1 << iota)
	fieldModifiedMappingMemoryLimit
	fieldModifiedMappingFileOffset
	fieldModifiedMappingFilename
	fieldModifiedMappingBuildId
	fieldModifiedMappingHasFunctions
	fieldModifiedMappingHasFilenames
	fieldModifiedMappingHasLineNumbers
	fieldModifiedMappingHasInlineFrames
)

// Init must be called once, before the Mapping is used.
func (s *Mapping) Init() {
	s.init(nil, 0)
}

func NewMapping() *Mapping {
	var s Mapping
	s.init(nil, 0)
	return &s
}

func (s *Mapping) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	s.modifiedFields.parent = parentModifiedFields
	s.modifiedFields.parentBit = parentModifiedBit

}

func (s *Mapping) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
	s.modifiedFields.parent = parentModifiedFields
	s.modifiedFields.parentBit = parentModifiedBit

}

// reset the struct to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (s *Mapping) reset() {
	s.memoryStart = 0
	s.memoryLimit = 0
	s.fileOffset = 0
	s.filename = ""
	s.buildId = ""
	s.hasFunctions = false
	s.hasFilenames = false
	s.hasLineNumbers = false
	s.hasInlineFrames = false
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (s *Mapping) fixParent(parentModifiedFields *modifiedFields) {
	s.modifiedFields.parent = parentModifiedFields
}

// Freeze the struct. Any attempt to modify it after this will panic.
// This marks the struct as eligible for safely sharing by pointer without cloning,
// which can improve encoding performance.
func (s *Mapping) Freeze() {
	s.modifiedFields.freeze()
}

func (s *Mapping) isFrozen() bool {
	return s.modifiedFields.isFrozen()
}

func (s *Mapping) MemoryStart() uint64 {
	return s.memoryStart
}

// SetMemoryStart sets the value of MemoryStart field.
func (s *Mapping) SetMemoryStart(v uint64) {
	if s.memoryStart != v {
		s.memoryStart = v
		s.modifiedFields.markModified(fieldModifiedMappingMemoryStart)
	}
}

func (s *Mapping) markMemoryStartModified() {
	s.modifiedFields.markModified(fieldModifiedMappingMemoryStart)
}

// IsMemoryStartModified returns true the value of MemoryStart field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsMemoryStartModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingMemoryStart != 0
}

func (s *Mapping) MemoryLimit() uint64 {
	return s.memoryLimit
}

// SetMemoryLimit sets the value of MemoryLimit field.
func (s *Mapping) SetMemoryLimit(v uint64) {
	if s.memoryLimit != v {
		s.memoryLimit = v
		s.modifiedFields.markModified(fieldModifiedMappingMemoryLimit)
	}
}

func (s *Mapping) markMemoryLimitModified() {
	s.modifiedFields.markModified(fieldModifiedMappingMemoryLimit)
}

// IsMemoryLimitModified returns true the value of MemoryLimit field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsMemoryLimitModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingMemoryLimit != 0
}

func (s *Mapping) FileOffset() uint64 {
	return s.fileOffset
}

// SetFileOffset sets the value of FileOffset field.
func (s *Mapping) SetFileOffset(v uint64) {
	if s.fileOffset != v {
		s.fileOffset = v
		s.modifiedFields.markModified(fieldModifiedMappingFileOffset)
	}
}

func (s *Mapping) markFileOffsetModified() {
	s.modifiedFields.markModified(fieldModifiedMappingFileOffset)
}

// IsFileOffsetModified returns true the value of FileOffset field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsFileOffsetModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingFileOffset != 0
}

func (s *Mapping) Filename() string {
	return s.filename
}

// SetFilename sets the value of Filename field.
func (s *Mapping) SetFilename(v string) {
	if s.filename != v {
		s.filename = v
		s.modifiedFields.markModified(fieldModifiedMappingFilename)
	}
}

func (s *Mapping) markFilenameModified() {
	s.modifiedFields.markModified(fieldModifiedMappingFilename)
}

// IsFilenameModified returns true the value of Filename field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsFilenameModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingFilename != 0
}

func (s *Mapping) BuildId() string {
	return s.buildId
}

// SetBuildId sets the value of BuildId field.
func (s *Mapping) SetBuildId(v string) {
	if s.buildId != v {
		s.buildId = v
		s.modifiedFields.markModified(fieldModifiedMappingBuildId)
	}
}

func (s *Mapping) markBuildIdModified() {
	s.modifiedFields.markModified(fieldModifiedMappingBuildId)
}

// IsBuildIdModified returns true the value of BuildId field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsBuildIdModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingBuildId != 0
}

func (s *Mapping) HasFunctions() bool {
	return s.hasFunctions
}

// SetHasFunctions sets the value of HasFunctions field.
func (s *Mapping) SetHasFunctions(v bool) {
	if s.hasFunctions != v {
		s.hasFunctions = v
		s.modifiedFields.markModified(fieldModifiedMappingHasFunctions)
	}
}

func (s *Mapping) markHasFunctionsModified() {
	s.modifiedFields.markModified(fieldModifiedMappingHasFunctions)
}

// IsHasFunctionsModified returns true the value of HasFunctions field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsHasFunctionsModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingHasFunctions != 0
}

func (s *Mapping) HasFilenames() bool {
	return s.hasFilenames
}

// SetHasFilenames sets the value of HasFilenames field.
func (s *Mapping) SetHasFilenames(v bool) {
	if s.hasFilenames != v {
		s.hasFilenames = v
		s.modifiedFields.markModified(fieldModifiedMappingHasFilenames)
	}
}

func (s *Mapping) markHasFilenamesModified() {
	s.modifiedFields.markModified(fieldModifiedMappingHasFilenames)
}

// IsHasFilenamesModified returns true the value of HasFilenames field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsHasFilenamesModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingHasFilenames != 0
}

func (s *Mapping) HasLineNumbers() bool {
	return s.hasLineNumbers
}

// SetHasLineNumbers sets the value of HasLineNumbers field.
func (s *Mapping) SetHasLineNumbers(v bool) {
	if s.hasLineNumbers != v {
		s.hasLineNumbers = v
		s.modifiedFields.markModified(fieldModifiedMappingHasLineNumbers)
	}
}

func (s *Mapping) markHasLineNumbersModified() {
	s.modifiedFields.markModified(fieldModifiedMappingHasLineNumbers)
}

// IsHasLineNumbersModified returns true the value of HasLineNumbers field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsHasLineNumbersModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingHasLineNumbers != 0
}

func (s *Mapping) HasInlineFrames() bool {
	return s.hasInlineFrames
}

// SetHasInlineFrames sets the value of HasInlineFrames field.
func (s *Mapping) SetHasInlineFrames(v bool) {
	if s.hasInlineFrames != v {
		s.hasInlineFrames = v
		s.modifiedFields.markModified(fieldModifiedMappingHasInlineFrames)
	}
}

func (s *Mapping) markHasInlineFramesModified() {
	s.modifiedFields.markModified(fieldModifiedMappingHasInlineFrames)
}

// IsHasInlineFramesModified returns true the value of HasInlineFrames field was modified since
// Mapping was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Mapping) IsHasInlineFramesModified() bool {
	return s.modifiedFields.mask&fieldModifiedMappingHasInlineFrames != 0
}

func (s *Mapping) setModifiedRecursively() {
	s.modifiedFields.mask =
		fieldModifiedMappingMemoryStart |
			fieldModifiedMappingMemoryLimit |
			fieldModifiedMappingFileOffset |
			fieldModifiedMappingFilename |
			fieldModifiedMappingBuildId |
			fieldModifiedMappingHasFunctions |
			fieldModifiedMappingHasFilenames |
			fieldModifiedMappingHasLineNumbers |
			fieldModifiedMappingHasInlineFrames | 0
}

func (s *Mapping) setUnmodifiedRecursively() {
	s.modifiedFields.mask = 0
}

// computeDiff compares s and val and returns true if they differ.
// All fields that are different in s will be marked as modified.
func (s *Mapping) computeDiff(val *Mapping) (ret bool) {
	// Compare MemoryStart field.
	if s.memoryStart != val.memoryStart {
		s.modifiedFields.setModified(fieldModifiedMappingMemoryStart)
		ret = true
	}
	// Compare MemoryLimit field.
	if s.memoryLimit != val.memoryLimit {
		s.modifiedFields.setModified(fieldModifiedMappingMemoryLimit)
		ret = true
	}
	// Compare FileOffset field.
	if s.fileOffset != val.fileOffset {
		s.modifiedFields.setModified(fieldModifiedMappingFileOffset)
		ret = true
	}
	// Compare Filename field.
	if s.filename != val.filename {
		s.modifiedFields.setModified(fieldModifiedMappingFilename)
		ret = true
	}
	// Compare BuildId field.
	if s.buildId != val.buildId {
		s.modifiedFields.setModified(fieldModifiedMappingBuildId)
		ret = true
	}
	// Compare HasFunctions field.
	if s.hasFunctions != val.hasFunctions {
		s.modifiedFields.setModified(fieldModifiedMappingHasFunctions)
		ret = true
	}
	// Compare HasFilenames field.
	if s.hasFilenames != val.hasFilenames {
		s.modifiedFields.setModified(fieldModifiedMappingHasFilenames)
		ret = true
	}
	// Compare HasLineNumbers field.
	if s.hasLineNumbers != val.hasLineNumbers {
		s.modifiedFields.setModified(fieldModifiedMappingHasLineNumbers)
		ret = true
	}
	// Compare HasInlineFrames field.
	if s.hasInlineFrames != val.hasInlineFrames {
		s.modifiedFields.setModified(fieldModifiedMappingHasInlineFrames)
		ret = true
	}
	return ret
}

// canBeShared returns true if s is safe to share by pointer without cloning (for example if s is frozen).
func (s *Mapping) canBeShared() bool {
	return s.isFrozen()
}

// CloneShared returns a clone of s. It may return s if it is safe to share without cloning
// (for example if s is frozen).
func (s *Mapping) CloneShared(allocators *Allocators) *Mapping {
	if s.isFrozen() {
		// If s is frozen it means it is safe to share without cloning.
		return s
	}
	return s.Clone(allocators)
}

func (s *Mapping) Clone(allocators *Allocators) *Mapping {
	c := allocators.Mapping.Alloc()
	*c = Mapping{
		memoryStart:     s.memoryStart,
		memoryLimit:     s.memoryLimit,
		fileOffset:      s.fileOffset,
		filename:        s.filename,
		buildId:         s.buildId,
		hasFunctions:    s.hasFunctions,
		hasFilenames:    s.hasFilenames,
		hasLineNumbers:  s.hasLineNumbers,
		hasInlineFrames: s.hasInlineFrames,
	}
	return c
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (s *Mapping) byteSize() uint {
	return uint(unsafe.Sizeof(*s)) +
		0
}

// Copy from src to dst, overwriting existing data in dst.
func copyMapping(dst *Mapping, src *Mapping) {
	dst.SetMemoryStart(src.memoryStart)
	dst.SetMemoryLimit(src.memoryLimit)
	dst.SetFileOffset(src.fileOffset)
	dst.SetFilename(src.filename)
	dst.SetBuildId(src.buildId)
	dst.SetHasFunctions(src.hasFunctions)
	dst.SetHasFilenames(src.hasFilenames)
	dst.SetHasLineNumbers(src.hasLineNumbers)
	dst.SetHasInlineFrames(src.hasInlineFrames)
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNewMapping(dst *Mapping, src *Mapping, allocators *Allocators) {
	dst.SetMemoryStart(src.memoryStart)
	dst.SetMemoryLimit(src.memoryLimit)
	dst.SetFileOffset(src.fileOffset)
	dst.SetFilename(src.filename)
	dst.SetBuildId(src.buildId)
	dst.SetHasFunctions(src.hasFunctions)
	dst.SetHasFilenames(src.hasFilenames)
	dst.SetHasLineNumbers(src.hasLineNumbers)
	dst.SetHasInlineFrames(src.hasInlineFrames)
}

// CopyFrom() performs a deep copy from src.
func (s *Mapping) CopyFrom(src *Mapping) {
	copyMapping(s, src)
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. Only fields that exist
// in the schem are mutated, allowing to generate data for specified schema.
func (s *Mapping) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	// Get the field count for this struct from the schema. If the schema specifies
	// fewer field count than the one we have in this code then we will not mutate
	// fields that are not in the schema.
	fieldCount, err := schem.FieldCount("Mapping")
	if err != nil {
		panic(fmt.Sprintf("cannot get field count for %s: %v", "Mapping", err))
	}

	const randRange = max(9, 2) // At least 2 to ensure we don't recurse infinitely if there is only 1 field.

	if fieldCount <= 0 {
		return // MemoryStart and all subsequent fields are skipped.
	}
	// Maybe mutate MemoryStart
	if random.IntN(randRange) == 0 {
		s.SetMemoryStart(pkg.Uint64Random(random))
	}
	if fieldCount <= 1 {
		return // MemoryLimit and all subsequent fields are skipped.
	}
	// Maybe mutate MemoryLimit
	if random.IntN(randRange) == 0 {
		s.SetMemoryLimit(pkg.Uint64Random(random))
	}
	if fieldCount <= 2 {
		return // FileOffset and all subsequent fields are skipped.
	}
	// Maybe mutate FileOffset
	if random.IntN(randRange) == 0 {
		s.SetFileOffset(pkg.Uint64Random(random))
	}
	if fieldCount <= 3 {
		return // Filename and all subsequent fields are skipped.
	}
	// Maybe mutate Filename
	if random.IntN(randRange) == 0 {
		s.SetFilename(pkg.StringRandom(random))
	}
	if fieldCount <= 4 {
		return // BuildId and all subsequent fields are skipped.
	}
	// Maybe mutate BuildId
	if random.IntN(randRange) == 0 {
		s.SetBuildId(pkg.StringRandom(random))
	}
	if fieldCount <= 5 {
		return // HasFunctions and all subsequent fields are skipped.
	}
	// Maybe mutate HasFunctions
	if random.IntN(randRange) == 0 {
		s.SetHasFunctions(pkg.BoolRandom(random))
	}
	if fieldCount <= 6 {
		return // HasFilenames and all subsequent fields are skipped.
	}
	// Maybe mutate HasFilenames
	if random.IntN(randRange) == 0 {
		s.SetHasFilenames(pkg.BoolRandom(random))
	}
	if fieldCount <= 7 {
		return // HasLineNumbers and all subsequent fields are skipped.
	}
	// Maybe mutate HasLineNumbers
	if random.IntN(randRange) == 0 {
		s.SetHasLineNumbers(pkg.BoolRandom(random))
	}
	if fieldCount <= 8 {
		return // HasInlineFrames and all subsequent fields are skipped.
	}
	// Maybe mutate HasInlineFrames
	if random.IntN(randRange) == 0 {
		s.SetHasInlineFrames(pkg.BoolRandom(random))
	}
}

// IsEqual performs deep comparison and returns true if struct is equal to right.
func (s *Mapping) IsEqual(right *Mapping) bool {
	// Compare MemoryStart field.
	if !pkg.Uint64Equal(s.memoryStart, right.memoryStart) {
		return false
	}
	// Compare MemoryLimit field.
	if !pkg.Uint64Equal(s.memoryLimit, right.memoryLimit) {
		return false
	}
	// Compare FileOffset field.
	if !pkg.Uint64Equal(s.fileOffset, right.fileOffset) {
		return false
	}
	// Compare Filename field.
	if !pkg.StringEqual(s.filename, right.filename) {
		return false
	}
	// Compare BuildId field.
	if !pkg.StringEqual(s.buildId, right.buildId) {
		return false
	}
	// Compare HasFunctions field.
	if !pkg.BoolEqual(s.hasFunctions, right.hasFunctions) {
		return false
	}
	// Compare HasFilenames field.
	if !pkg.BoolEqual(s.hasFilenames, right.hasFilenames) {
		return false
	}
	// Compare HasLineNumbers field.
	if !pkg.BoolEqual(s.hasLineNumbers, right.hasLineNumbers) {
		return false
	}
	// Compare HasInlineFrames field.
	if !pkg.BoolEqual(s.hasInlineFrames, right.hasInlineFrames) {
		return false
	}

	return true
}

func MappingEqual(left, right *Mapping) bool {
	return left.IsEqual(right)
}

// CmpMapping performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func CmpMapping(left, right *Mapping) int {
	// Dict-based structs may be nil, so check for that first.
	if left == nil {
		if right == nil {
			return 0
		}
		return -1
	}
	if right == nil {
		return 1
	}
	// Compare MemoryStart field.
	if c := pkg.Uint64Compare(left.memoryStart, right.memoryStart); c != 0 {
		return c
	}
	// Compare MemoryLimit field.
	if c := pkg.Uint64Compare(left.memoryLimit, right.memoryLimit); c != 0 {
		return c
	}
	// Compare FileOffset field.
	if c := pkg.Uint64Compare(left.fileOffset, right.fileOffset); c != 0 {
		return c
	}
	// Compare Filename field.
	if c := strings.Compare(left.filename, right.filename); c != 0 {
		return c
	}
	// Compare BuildId field.
	if c := strings.Compare(left.buildId, right.buildId); c != 0 {
		return c
	}
	// Compare HasFunctions field.
	if c := pkg.BoolCompare(left.hasFunctions, right.hasFunctions); c != 0 {
		return c
	}
	// Compare HasFilenames field.
	if c := pkg.BoolCompare(left.hasFilenames, right.hasFilenames); c != 0 {
		return c
	}
	// Compare HasLineNumbers field.
	if c := pkg.BoolCompare(left.hasLineNumbers, right.hasLineNumbers); c != 0 {
		return c
	}
	// Compare HasInlineFrames field.
	if c := pkg.BoolCompare(left.hasInlineFrames, right.hasInlineFrames); c != 0 {
		return c
	}
	return 0
}

// MappingEncoder implements encoding of Mapping
type MappingEncoder struct {
	buf     pkg.BitsWriter
	limiter *pkg.SizeLimiter

	// forceModifiedFields is set to a mask to force the next encoding operation
	// write the fields, whether they are modified or no. This is used after frame
	// restarts so that the data can be decoded from the frame start.
	forceModifiedFields uint64

	memoryStartEncoder     encoders.Uint64Encoder
	memoryLimitEncoder     encoders.Uint64Encoder
	fileOffsetEncoder      encoders.Uint64Encoder
	filenameEncoder        encoders.StringDictEncoder
	buildIdEncoder         encoders.StringDictEncoder
	hasFunctionsEncoder    encoders.BoolEncoder
	hasFilenamesEncoder    encoders.BoolEncoder
	hasLineNumbersEncoder  encoders.BoolEncoder
	hasInlineFramesEncoder encoders.BoolEncoder

	allocators *Allocators
	dict       *MappingEncoderDict

	keepFieldMask uint64
	fieldCount    uint
}

// MappingEncoderDict is the dictionary used by MappingEncoder
type MappingEncoderDict struct {
	dict       b.Tree[*Mapping, uint32] // Searchable map of items seen in the past.
	slice      []*Mapping               // The same items in order of RefNum.
	allocators *Allocators
	limiter    *pkg.SizeLimiter
}

func (d *MappingEncoderDict) Init(limiter *pkg.SizeLimiter) {
	d.dict = *b.TreeNew[*Mapping, uint32](CmpMapping)
	d.slice = make([]*Mapping, 1) // refNum 0 is reserved for nil Mapping
	d.dict.Set(nil, 0)            // nil Mapping is RefNum 0
	d.limiter = limiter
}

func (d *MappingEncoderDict) Get(val *Mapping) (uint32, bool) {
	refNum := val.modifiedFields.refNum
	if refNum != 0 {
		// We have a cached refNum, verify that it is still valid. It may become invalid
		// if for example the dictionaries are reset during encoding and refNums are reused.
		if int(refNum) < len(d.slice) && d.slice[refNum] == val {
			return refNum, true
		}
	}
	return d.dict.Get(val)
}

func (d *MappingEncoderDict) Add(val *Mapping) {
	refNum := uint32(d.dict.Len())     // Obtain a new refNum.
	val.modifiedFields.refNum = refNum // Cache the refNum
	d.slice = append(d.slice, val)     // Remember the value by refNum.

	d.limiter.AddDictElemSize(val.byteSize())
	if val.isFrozen() {
		// If val is frozen it means it is safe to share without cloning.
		d.dict.Set(val, refNum)
		return
	}
	clone := val.Clone(d.allocators) // Clone before adding to dictionary.
	clone.Freeze()                   // Freeze the clone so that it can be safely shared by pointer.
	d.dict.Set(clone, refNum)
}

func (d *MappingEncoderDict) Reset() {
	d.dict.Clear()
	d.dict.Set(nil, 0) // nil Mapping is RefNum 0
	d.slice = d.slice[:1]
}

func (e *MappingEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	// Remember this encoder in the state so that we can detect recursion.
	if state.MappingEncoder != nil {
		panic("cannot initialize MappingEncoder: already initialized")
	}
	state.MappingEncoder = e
	defer func() { state.MappingEncoder = nil }()

	e.limiter = &state.limiter
	e.allocators = &state.Allocators
	e.dict = &state.Mapping
	e.dict.allocators = e.allocators

	// Number of fields in the output data schema.
	var err error
	e.fieldCount, err = state.StructFieldCounts.MappingFieldCount()
	if err != nil {
		return fmt.Errorf("cannot find struct %s in override schema: %v", "Mapping", err)
	}
	// Set that many 1 bits in the keepFieldMask. All fields with higher number
	// will be skipped when encoding.
	e.keepFieldMask = ^(^uint64(0) << e.fieldCount)

	// Init encoder for MemoryStart field.
	if e.fieldCount <= 0 {
		return nil // MemoryStart and all subsequent fields are skipped.
	}
	err = e.memoryStartEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for MemoryLimit field.
	if e.fieldCount <= 1 {
		return nil // MemoryLimit and all subsequent fields are skipped.
	}
	err = e.memoryLimitEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for FileOffset field.
	if e.fieldCount <= 2 {
		return nil // FileOffset and all subsequent fields are skipped.
	}
	err = e.fileOffsetEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Filename field.
	if e.fieldCount <= 3 {
		return nil // Filename and all subsequent fields are skipped.
	}
	err = e.filenameEncoder.Init(&state.Filename, e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for BuildId field.
	if e.fieldCount <= 4 {
		return nil // BuildId and all subsequent fields are skipped.
	}
	err = e.buildIdEncoder.Init(&state.BuildID, e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for HasFunctions field.
	if e.fieldCount <= 5 {
		return nil // HasFunctions and all subsequent fields are skipped.
	}
	err = e.hasFunctionsEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for HasFilenames field.
	if e.fieldCount <= 6 {
		return nil // HasFilenames and all subsequent fields are skipped.
	}
	err = e.hasFilenamesEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for HasLineNumbers field.
	if e.fieldCount <= 7 {
		return nil // HasLineNumbers and all subsequent fields are skipped.
	}
	err = e.hasLineNumbersEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for HasInlineFrames field.
	if e.fieldCount <= 8 {
		return nil // HasInlineFrames and all subsequent fields are skipped.
	}
	err = e.hasInlineFramesEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	return nil
}

func (e *MappingEncoder) Reset() {
	// Since we are resetting the state of encoder make sure the next Encode()
	// call forcedly writes all fields and does not attempt to skip.
	e.forceModifiedFields = e.keepFieldMask

	if e.fieldCount <= 0 {
		return // MemoryStart and all subsequent fields are skipped.
	}
	e.memoryStartEncoder.Reset()
	if e.fieldCount <= 1 {
		return // MemoryLimit and all subsequent fields are skipped.
	}
	e.memoryLimitEncoder.Reset()
	if e.fieldCount <= 2 {
		return // FileOffset and all subsequent fields are skipped.
	}
	e.fileOffsetEncoder.Reset()
	if e.fieldCount <= 3 {
		return // Filename and all subsequent fields are skipped.
	}
	e.filenameEncoder.Reset()
	if e.fieldCount <= 4 {
		return // BuildId and all subsequent fields are skipped.
	}
	e.buildIdEncoder.Reset()
	if e.fieldCount <= 5 {
		return // HasFunctions and all subsequent fields are skipped.
	}
	e.hasFunctionsEncoder.Reset()
	if e.fieldCount <= 6 {
		return // HasFilenames and all subsequent fields are skipped.
	}
	e.hasFilenamesEncoder.Reset()
	if e.fieldCount <= 7 {
		return // HasLineNumbers and all subsequent fields are skipped.
	}
	e.hasLineNumbersEncoder.Reset()
	if e.fieldCount <= 8 {
		return // HasInlineFrames and all subsequent fields are skipped.
	}
	e.hasInlineFramesEncoder.Reset()
}

// Encode encodes val into buf
func (e *MappingEncoder) Encode(val *Mapping) {
	var bitCount uint

	// Check if the Mapping exists in the dictionary.
	if refNum, exists := e.dict.Get(val); exists {
		// The Mapping exists, we will reference it.
		// Indicate a RefNum follows.
		e.buf.WriteBit(0)
		// Encode refNum.
		bitCount = e.buf.WriteUvarintCompact(uint64(refNum))

		// Account written bits in the limiter.
		e.limiter.AddFrameBits(1 + bitCount)

		// Mark all fields non-modified recursively so that next Encode() correctly
		// encodes only fields that change after this.
		val.setUnmodifiedRecursively()
		return
	}

	// The Mapping does not exist in the dictionary. Add it to the dictionary.
	e.dict.Add(val)

	// Indicate that an encoded Mapping follows.
	e.buf.WriteBit(1)
	bitCount += 1
	// TODO: optimize and merge WriteBit with the following WriteBits.
	// Mask that describes what fields are encoded. Start with all modified fields.
	fieldMask := val.modifiedFields.mask

	// If forceModifiedFields we need to set to 1 all bits so that we
	// force writing of all fields.
	fieldMask |= e.forceModifiedFields
	e.forceModifiedFields = 0

	// Only write fields that we want to write. See Init() for keepFieldMask.
	fieldMask &= e.keepFieldMask

	// Write bits to indicate which fields follow.
	e.buf.WriteBits(fieldMask, e.fieldCount)
	bitCount += e.fieldCount

	// Encode modified, present fields.

	if fieldMask&fieldModifiedMappingMemoryStart != 0 {
		// Encode MemoryStart
		e.memoryStartEncoder.Encode(val.memoryStart)
	}

	if fieldMask&fieldModifiedMappingMemoryLimit != 0 {
		// Encode MemoryLimit
		e.memoryLimitEncoder.Encode(val.memoryLimit)
	}

	if fieldMask&fieldModifiedMappingFileOffset != 0 {
		// Encode FileOffset
		e.fileOffsetEncoder.Encode(val.fileOffset)
	}

	if fieldMask&fieldModifiedMappingFilename != 0 {
		// Encode Filename
		e.filenameEncoder.Encode(val.filename)
	}

	if fieldMask&fieldModifiedMappingBuildId != 0 {
		// Encode BuildId
		e.buildIdEncoder.Encode(val.buildId)
	}

	if fieldMask&fieldModifiedMappingHasFunctions != 0 {
		// Encode HasFunctions
		e.hasFunctionsEncoder.Encode(val.hasFunctions)
	}

	if fieldMask&fieldModifiedMappingHasFilenames != 0 {
		// Encode HasFilenames
		e.hasFilenamesEncoder.Encode(val.hasFilenames)
	}

	if fieldMask&fieldModifiedMappingHasLineNumbers != 0 {
		// Encode HasLineNumbers
		e.hasLineNumbersEncoder.Encode(val.hasLineNumbers)
	}

	if fieldMask&fieldModifiedMappingHasInlineFrames != 0 {
		// Encode HasInlineFrames
		e.hasInlineFramesEncoder.Encode(val.hasInlineFrames)
	}

	// Account written bits in the limiter.
	e.limiter.AddFrameBits(bitCount)

	// Mark all fields non-modified so that next Encode() correctly
	// encodes only fields that change after this.
	val.modifiedFields.mask = 0
}

// CollectColumns collects all buffers from all encoders into buf.
func (e *MappingEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)
	colIdx := 0
	// Collect MemoryStart field.
	if e.fieldCount <= 0 {
		return // MemoryStart and subsequent fields are skipped.
	}
	e.memoryStartEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect MemoryLimit field.
	if e.fieldCount <= 1 {
		return // MemoryLimit and subsequent fields are skipped.
	}
	e.memoryLimitEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect FileOffset field.
	if e.fieldCount <= 2 {
		return // FileOffset and subsequent fields are skipped.
	}
	e.fileOffsetEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Filename field.
	if e.fieldCount <= 3 {
		return // Filename and subsequent fields are skipped.
	}
	e.filenameEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect BuildId field.
	if e.fieldCount <= 4 {
		return // BuildId and subsequent fields are skipped.
	}
	e.buildIdEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect HasFunctions field.
	if e.fieldCount <= 5 {
		return // HasFunctions and subsequent fields are skipped.
	}
	e.hasFunctionsEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect HasFilenames field.
	if e.fieldCount <= 6 {
		return // HasFilenames and subsequent fields are skipped.
	}
	e.hasFilenamesEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect HasLineNumbers field.
	if e.fieldCount <= 7 {
		return // HasLineNumbers and subsequent fields are skipped.
	}
	e.hasLineNumbersEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect HasInlineFrames field.
	if e.fieldCount <= 8 {
		return // HasInlineFrames and subsequent fields are skipped.
	}
	e.hasInlineFramesEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
}

// MappingDecoder implements decoding of Mapping
type MappingDecoder struct {
	buf                pkg.BitsReader
	column             *pkg.ReadableColumn
	fieldCount         uint
	memoryStartDecoder encoders.Uint64Decoder

	memoryLimitDecoder encoders.Uint64Decoder

	fileOffsetDecoder encoders.Uint64Decoder

	filenameDecoder encoders.StringDictDecoder

	buildIdDecoder encoders.StringDictDecoder

	hasFunctionsDecoder encoders.BoolDecoder

	hasFilenamesDecoder encoders.BoolDecoder

	hasLineNumbersDecoder encoders.BoolDecoder

	hasInlineFramesDecoder encoders.BoolDecoder

	dict       *MappingDecoderDict
	allocators *Allocators
}

// Init is called once in the lifetime of the stream.
func (d *MappingDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	// Remember this decoder in the state so that we can detect recursion.
	if state.MappingDecoder != nil {
		panic("cannot initialize MappingDecoder: already initialized")
	}
	state.MappingDecoder = d
	defer func() { state.MappingDecoder = nil }()

	d.allocators = &state.Allocators

	// Number of fields in the input data schema.
	var err error
	d.fieldCount, err = state.StructFieldCounts.MappingFieldCount()
	if err != nil {
		return fmt.Errorf("cannot find struct %s in override schema: %v", "Mapping", err)
	}

	d.column = columns.Column()
	d.dict = &state.Mapping

	if d.fieldCount <= 0 {
		return nil // MemoryStart and subsequent fields are skipped.
	}
	err = d.memoryStartDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 1 {
		return nil // MemoryLimit and subsequent fields are skipped.
	}
	err = d.memoryLimitDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 2 {
		return nil // FileOffset and subsequent fields are skipped.
	}
	err = d.fileOffsetDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 3 {
		return nil // Filename and subsequent fields are skipped.
	}
	err = d.filenameDecoder.Init(&state.Filename, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 4 {
		return nil // BuildId and subsequent fields are skipped.
	}
	err = d.buildIdDecoder.Init(&state.BuildID, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 5 {
		return nil // HasFunctions and subsequent fields are skipped.
	}
	err = d.hasFunctionsDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 6 {
		return nil // HasFilenames and subsequent fields are skipped.
	}
	err = d.hasFilenamesDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 7 {
		return nil // HasLineNumbers and subsequent fields are skipped.
	}
	err = d.hasLineNumbersDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 8 {
		return nil // HasInlineFrames and subsequent fields are skipped.
	}
	err = d.hasInlineFramesDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *MappingDecoder) Continue() {
	d.buf.Reset(d.column.Data())

	if d.fieldCount <= 0 {
		return // MemoryStart and subsequent fields are skipped.
	}
	d.memoryStartDecoder.Continue()
	if d.fieldCount <= 1 {
		return // MemoryLimit and subsequent fields are skipped.
	}
	d.memoryLimitDecoder.Continue()
	if d.fieldCount <= 2 {
		return // FileOffset and subsequent fields are skipped.
	}
	d.fileOffsetDecoder.Continue()
	if d.fieldCount <= 3 {
		return // Filename and subsequent fields are skipped.
	}
	d.filenameDecoder.Continue()
	if d.fieldCount <= 4 {
		return // BuildId and subsequent fields are skipped.
	}
	d.buildIdDecoder.Continue()
	if d.fieldCount <= 5 {
		return // HasFunctions and subsequent fields are skipped.
	}
	d.hasFunctionsDecoder.Continue()
	if d.fieldCount <= 6 {
		return // HasFilenames and subsequent fields are skipped.
	}
	d.hasFilenamesDecoder.Continue()
	if d.fieldCount <= 7 {
		return // HasLineNumbers and subsequent fields are skipped.
	}
	d.hasLineNumbersDecoder.Continue()
	if d.fieldCount <= 8 {
		return // HasInlineFrames and subsequent fields are skipped.
	}
	d.hasInlineFramesDecoder.Continue()
}

func (d *MappingDecoder) Reset() {

	if d.fieldCount <= 0 {
		return // MemoryStart and all subsequent fields are skipped.
	}
	d.memoryStartDecoder.Reset()
	if d.fieldCount <= 1 {
		return // MemoryLimit and all subsequent fields are skipped.
	}
	d.memoryLimitDecoder.Reset()
	if d.fieldCount <= 2 {
		return // FileOffset and all subsequent fields are skipped.
	}
	d.fileOffsetDecoder.Reset()
	if d.fieldCount <= 3 {
		return // Filename and all subsequent fields are skipped.
	}
	d.filenameDecoder.Reset()
	if d.fieldCount <= 4 {
		return // BuildId and all subsequent fields are skipped.
	}
	d.buildIdDecoder.Reset()
	if d.fieldCount <= 5 {
		return // HasFunctions and all subsequent fields are skipped.
	}
	d.hasFunctionsDecoder.Reset()
	if d.fieldCount <= 6 {
		return // HasFilenames and all subsequent fields are skipped.
	}
	d.hasFilenamesDecoder.Reset()
	if d.fieldCount <= 7 {
		return // HasLineNumbers and all subsequent fields are skipped.
	}
	d.hasLineNumbersDecoder.Reset()
	if d.fieldCount <= 8 {
		return // HasInlineFrames and all subsequent fields are skipped.
	}
	d.hasInlineFramesDecoder.Reset()
}

func (d *MappingDecoder) Decode(dstPtr **Mapping) error {
	// Check if this is a dictionary-based decoding.
	dictFlag := d.buf.ReadBit()
	if dictFlag == 0 {
		refNum := d.buf.ReadUvarintCompact()
		if refNum >= uint64(len(d.dict.dict)) {
			return pkg.ErrInvalidRefNum
		}
		*dstPtr = d.dict.dict[refNum]
		return nil
	}

	// *dstPtr is pointing to a element in the dictionary. We are not allowed
	// to modify it. Make a clone of it and decode into the clone.
	val := (*dstPtr).Clone(d.allocators)
	*dstPtr = val

	var err error

	// Read bits that indicate which fields follow.
	val.modifiedFields.mask = d.buf.ReadBits(d.fieldCount)

	if val.modifiedFields.mask&fieldModifiedMappingMemoryStart != 0 {
		// Field is changed and is present, decode it.
		err = d.memoryStartDecoder.Decode(&val.memoryStart)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingMemoryLimit != 0 {
		// Field is changed and is present, decode it.
		err = d.memoryLimitDecoder.Decode(&val.memoryLimit)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingFileOffset != 0 {
		// Field is changed and is present, decode it.
		err = d.fileOffsetDecoder.Decode(&val.fileOffset)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingFilename != 0 {
		// Field is changed and is present, decode it.
		err = d.filenameDecoder.Decode(&val.filename)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingBuildId != 0 {
		// Field is changed and is present, decode it.
		err = d.buildIdDecoder.Decode(&val.buildId)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingHasFunctions != 0 {
		// Field is changed and is present, decode it.
		err = d.hasFunctionsDecoder.Decode(&val.hasFunctions)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingHasFilenames != 0 {
		// Field is changed and is present, decode it.
		err = d.hasFilenamesDecoder.Decode(&val.hasFilenames)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingHasLineNumbers != 0 {
		// Field is changed and is present, decode it.
		err = d.hasLineNumbersDecoder.Decode(&val.hasLineNumbers)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedMappingHasInlineFrames != 0 {
		// Field is changed and is present, decode it.
		err = d.hasInlineFramesDecoder.Decode(&val.hasInlineFrames)
		if err != nil {
			return err
		}
	}

	d.dict.dict = append(d.dict.dict, val)
	// Freeze the value. It is now in the dictionary and must not be modified.
	// This also improves performance of any encode operations that use this
	// value as it can be safely shared in encoder's dictionary without cloning.
	val.Freeze()

	return nil
}

// MappingDecoderDict is the dictionary used by MappingDecoder
type MappingDecoderDict struct {
	dict []*Mapping
}

func (d *MappingDecoderDict) Init() {
	d.dict = d.dict[:0]
	d.dict = append(d.dict, nil) // nil Mapping is RefNum 0
}

// Reset the dictionary to initial state. Used when a frame is
// started with RestartDictionaries flag.
func (d *MappingDecoderDict) Reset() {
	d.Init()
}

// MappingAllocator implements a custom allocator for Mapping.
// It maintains a pool of pre-allocated Mapping and grows the pool
// dynamically as needed, up to a maximum size of 64 elements.
type MappingAllocator struct {
	pool []Mapping
	ofs  int
}

// Alloc returns the next available Mapping from the pool.
// If the pool is exhausted, it grows the pool by doubling its size
// up to a maximum of 64 elements.
func (a *MappingAllocator) Alloc() *Mapping {
	if a.ofs < len(a.pool) {
		// Get the next available Mapping from the pool
		a.ofs++
		return &a.pool[a.ofs-1]
	}
	// We've exhausted the current pool, prealloc a new pool.
	return a.prealloc()
}

//go:noinline
func (a *MappingAllocator) prealloc() *Mapping {
	// prealloc expands the pool by doubling its size, up to a maximum of 64 elements.
	// If the pool is empty, it starts with 1 element.
	newLen := min(max(len(a.pool)*2, 1), 64)
	a.pool = make([]Mapping, newLen)
	a.ofs = 1
	return &a.pool[0]
}
