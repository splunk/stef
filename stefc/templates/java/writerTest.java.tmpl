package {{ .PackageName }};

import net.stef.Compression;
import net.stef.FrameFlags;
import net.stef.MemChunkWriter;
import net.stef.ReadOptions;
import net.stef.ReadResult;
import net.stef.WriterOptions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

class {{.StructName}}WriterTest {

    // gen{{.StructName}}Records generates a number of records pseudo-randomly
    // using the supplied Random generator. Generated records will be always
    // the same for the same input state of Random generator.
    static List<{{.StructName}}> gen{{.StructName}}Records(Random random) {
        final int recCount = 1000;
        List<{{.StructName}}> records = new ArrayList<>(recCount);
        {{.StructName}} record = new {{.StructName}}();
        for (int i = 0; i < recCount; i++) {
            CommonMutateRandomLimiter limiter = new CommonMutateRandomLimiter();
            record.mutateRandom(random, limiter);
            {{.StructName}} copy = new {{.StructName}}();
            copy.copyFrom(record);
            records.add(copy);
        }
        return records;
    }

    boolean test{{.StructName}}WriteReadSeed(long seed) {
        boolean retVal = true;

        List<WriterOptions.Builder> opts = Arrays.asList(
            WriterOptions.builder(),
            WriterOptions.builder().compression(Compression.Zstd),
            WriterOptions.builder().maxUncompressedFrameByteSize(500),
            WriterOptions.builder().maxTotalDictSize(500),

            WriterOptions.builder().
                maxUncompressedFrameByteSize(500).
                maxTotalDictSize(500).
                compression(Compression.Zstd),

            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartDictionaries),
            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartCodecs),
            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartDictionaries | FrameFlags.RestartCodecs),

            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartCompression).
                compression(Compression.Zstd),

            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartDictionaries | FrameFlags.RestartCodecs | FrameFlags.RestartCompression).
                compression(Compression.Zstd),

            WriterOptions.builder().frameRestartFlags(FrameFlags.RestartCodecs).maxUncompressedFrameByteSize(500)
        );

        Random random = new Random(seed);

        for (int optIdx = 0; optIdx < opts.size(); optIdx++) {
            WriterOptions.Builder opt = opts.get(optIdx);
            try {
                MemChunkWriter buf = new MemChunkWriter();
                {{.StructName}}Writer writer = new {{.StructName}}Writer(buf, opt.build());

                // Generate records pseudo-randomly
                List<{{.StructName}}> records = gen{{.StructName}}Records(random);
                // Write the records
                for (int i = 0; i < records.size(); i++) {
                    writer.record.copyFrom(records.get(i));
                    writer.write();
                }
                writer.flush();

                // Read the records and compare to written.
                {{.StructName}}Reader reader = new {{.StructName}}Reader(new ByteArrayInputStream(buf.getBytes()));
                for (int i = 0; i < records.size(); i++) {
                    assertEquals(ReadResult.Success, reader.read(ReadOptions.none));
                    assertTrue(reader.record.equals(records.get(i)), "record " + i + " seed " + seed + " optIdx " + optIdx);
                }
                assertThrows(EOFException.class, () -> reader.read(ReadOptions.none));
            } catch (Throwable t) {
                System.out.printf("Test failed with seed %d optIdx %d: %s%n", seed, optIdx, t);
                retVal = false;
            }
        }

        return retVal;
    }

    @Test
    void test{{.StructName}}WriteRead() throws Exception {
        // Seed files are stored in-repo so previously-failing seeds can be replayed to prevent regressions.
        Path seedFilePath = Paths.get("../stefc/generator/testdata/seeds/java/{{ .PackageName }}_{{.StructName}}_seeds.txt");

        if (Files.exists(seedFilePath)) {
            for (String line : Files.readAllLines(seedFilePath)) {
                String s = line.trim();
                if (s.isEmpty()) continue;
                long seed = Long.parseLong(s);
                System.out.printf("Testing with seed from file: %d%n", seed);
                boolean passed = test{{.StructName}}WriteReadSeed(seed);
                if (!passed) {
                    fail("Previously-failing seed " + seed + " still fails");
                }
            }
        }

        long seed = System.nanoTime();
        boolean succeeded = test{{.StructName}}WriteReadSeed(seed);
        if (!succeeded) {
            System.out.printf("Test failed with seed %d, adding to seed file%n", seed);
            Files.createDirectories(seedFilePath.getParent());
            Files.writeString(seedFilePath, seed + "\n", StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            fail("Test failed with seed " + seed);
        }
    }
}