package {{ .PackageName }};

import net.stef.BitsWriter;
import net.stef.SizeLimiter;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

// Encoder for {{ .ArrayName }}
class {{ .ArrayName }}Encoder {
    private final BitsWriter buf = new BitsWriter();
    private SizeLimiter limiter;
    private {{.ElemType.EncoderType}}Encoder elemEncoder;
    private WriterState state;
    private boolean isRecursive = false;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        this.state = state;
        this.limiter = state.getLimiter();

        {{ if .ElemType.IsPrimitive -}}
        elemEncoder = new {{ .ElemType.EncoderType }}Encoder();
        elemEncoder.init({{- if .ElemType.DictName}}state.{{.ElemType.DictName}}, {{end}}this.limiter, columns.addSubColumn());
        {{- else -}}
        // Remember this encoder in the state so that we can detect recursion.
        if (state.{{ .ArrayName }}Encoder != null) {
            throw new IllegalStateException("Cannot initialize {{ .ArrayName }}Encoder: already initialized");
        }
        state.{{ .ArrayName }}Encoder = this;

        try {
            if (state.{{ .ElemType.EncoderType }}Encoder != null) {
                // Recursion detected, use the existing encoder.
                elemEncoder = state.{{ .ElemType.EncoderType }}Encoder;
                this.isRecursive = true;
            } else {
                elemEncoder = new {{ .ElemType.EncoderType }}Encoder();
                elemEncoder.init(state, columns.addSubColumn());
            }
        } finally {
            state.{{ .ArrayName }}Encoder = null;
        }
        {{- end }}
    }

    public void reset() {
        if (!isRecursive) {
            elemEncoder.reset();
        }
    }

    public void encode({{ .ArrayName }} arr) throws IOException {
        int oldBitLen = buf.bitCount();

        // Write the length of the array.
        int newLen = arr.elemsLen;
        buf.writeUvarintCompact(newLen);

        for (int i = 0; i < newLen; i++) {
            elemEncoder.encode(arr.elems[i]);
        }

        // Account written bits in the limiter.
        int newBitLen = buf.bitCount();
        limiter.addFrameBits(newBitLen - oldBitLen);
    }

    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBits(buf);
        if (!isRecursive) {
            elemEncoder.collectColumns(columnSet.at(0));
        }
    }
}

