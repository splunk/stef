{{- /*gotype: github.com/splunk/stef/go/pkg/generator.MultimapTemplateModel*/ -}}
package {{ .PackageName }}

import (
    "math/rand/v2"
    "unsafe"
	"strings"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

var _ = (*encoders.StringEncoder)(nil)
var _ = (*strings.Builder)(nil)

// {{ .MultimapName }} is a multimap, (aka an associative array or a list) of key value
// pairs from {{.Key.Type.TypeName}} to {{.Value.Type.TypeName}}.
type {{ .MultimapName }} struct {
	elems []{{ .MultimapName }}Elem
	initedCount int

    modifiedElems modifiedFieldsMultimap
}

type {{ .MultimapName }}Elem struct {
	key   {{if .KeyStoreByPtr}}*{{end}}{{.Key.Type.Storage}}
	value {{if .ValueStoreByPtr}}*{{end}}{{.Value.Type.Storage}}
}

func (e* {{ .MultimapName }}Elem) Key() {{if.Key.Type.Flags.PassByPtr}}*{{end}}{{.Key.Type.Exported}} {
	return {{if and .Key.Type.Flags.PassByPtr (not .KeyStoreByPtr)}}&{{end}}{{.Key.Type.ToExported ("e.key")}}
}

func (e* {{ .MultimapName }}Elem) Value() {{if.Value.Type.Flags.PassByPtr}}*{{end}}{{.Value.Type.Exported}} {
	return {{if and .Value.Type.Flags.PassByPtr (not .ValueStoreByPtr)}}&{{end}}{{.Value.Type.ToExported ("e.value")}}
}

func (m *{{.MultimapName}}) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	m.modifiedElems.init(parentModifiedFields, parentModifiedBit)
}

func (m *{{.MultimapName}}) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
	m.init(parentModifiedFields, parentModifiedBit)
}

// reset the multimap to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (m *{{.MultimapName}}) reset() {
    m.elems = m.elems[:0]
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (m *{{.MultimapName}}) fixParent(parentModifiedFields *modifiedFields) {
    m.modifiedElems.fixParent(parentModifiedFields)
    // Fix parents in all previously inited elements to point back to this object.
    elems := m.elems[:m.initedCount]
    for i:=0; i < len(elems); i++ {
        {{- if not .Key.Type.IsPrimitive}}
        elems[i].key.fixParent(&m.modifiedElems.keys)
        {{- end}}
        {{- if not .Value.Type.IsPrimitive}}
        elems[i].value.fixParent(&m.modifiedElems.vals)
        {{- end}}
    }
}

func (m *{{.MultimapName}}) canBeShared() bool {
    // Multimap can never be shared.
    return false
}

// Len returns the number of elements in the multimap.
func (m *{{.MultimapName}}) Len() int {
	return len(m.elems)
}

// At returns element at index i.
func (m *{{.MultimapName}}) At(i int) *{{.MultimapName}}Elem {
	return &m.elems[i]
}

// EnsureLen ensures the length of the multimap is equal to newLen.
// It will grow or shrink the multimap if needed.
func (m *{{.MultimapName}}) EnsureLen(newLen int) {
	oldLen :=len(m.elems)
	if newLen!=oldLen {
	    m.modifiedElems.changeLen(oldLen, newLen)

        // Check if the underlying array is reallocated.
        beforePtr := unsafe.SliceData(m.elems)
		m.elems = pkg.EnsureLen(m.elems, newLen)

		// Init elements with pointers to the parent struct.
		for i:=m.initedCount; i < newLen; i++ {
			{{- if not .Key.Type.IsPrimitive}}
			{{if .KeyStoreByPtr}}m.elems[i].key = new({{.Key.Type.Storage}}){{end}}
			m.elems[i].key.init(&m.modifiedElems.keys, m.modifiedElems.maskForIndex(i))
			{{- end}}
			{{- if not .Value.Type.IsPrimitive}}
			{{if .ValueStoreByPtr}}m.elems[i].value = new({{.Value.Type.Storage}}){{end}}
			m.elems[i].value.init(&m.modifiedElems.vals, m.modifiedElems.maskForIndex(i))
			{{- end}}
		}
		if m.initedCount < newLen {
			m.initedCount = newLen
		}

		if beforePtr != unsafe.SliceData(m.elems) {
		    // Underlying array was reallocated, we need to fix parent pointers
		    // in all elements.
		    for i:=0; i < newLen; i++ {
		        {{- if not .Key.Type.IsPrimitive}}
		        m.elems[i].key.fixParent(&m.modifiedElems.keys)
		        {{- end}}
		        {{- if not .Value.Type.IsPrimitive}}
		        m.elems[i].value.fixParent(&m.modifiedElems.vals)
		        {{- end}}
		    }
		}

		for i:=min(oldLen, newLen); i < newLen; i++ {
			{{- if not .Key.Type.IsPrimitive}}
			// Reset newly created keys to initial state.
			m.elems[i].key.reset()
			{{- end}}
			{{- if not .Value.Type.IsPrimitive}}
			// Reset newly added values keys to initial state.
			m.elems[i].value.reset()
			{{- end}}
        }
	}
}

func (m* {{.MultimapName}}) setModifiedRecursively() {
	for i:=0; i < len(m.elems); i++ {
		{{- if not .Key.Type.IsPrimitive}}
		m.elems[i].key.setModifiedRecursively()
		{{- end}}
		{{- if not .Value.Type.IsPrimitive}}
		m.elems[i].value.setModifiedRecursively()
		{{- end}}
	}
}

func (m* {{.MultimapName}}) setUnmodifiedRecursively() {
	for i:=0; i < len(m.elems); i++ {
		{{- if not .Key.Type.IsPrimitive}}
		m.elems[i].key.setUnmodifiedRecursively()
		{{- end}}
		{{- if not .Value.Type.IsPrimitive}}
		m.elems[i].value.setUnmodifiedRecursively()
		{{- end}}
	}
	m.modifiedElems.setUnmodifiedAll()
}

// computeDiff compares m to val and returns true if they differ.
// All fields that are different in m will be marked as modified.
func (m *{{.MultimapName}}) computeDiff(val *{{.MultimapName}}) (ret bool) {
	if len(m.elems) != len(val.elems) {
	    m.modifiedElems.modifiedLen = true
		ret = true
	}
	minLen := min(len(m.elems), len(val.elems))
	i := 0
	for ; i < minLen; i++ {
		{{- if .Key.Type.IsPrimitive }}
		if m.elems[i].key != val.elems[i].key {
		{{- else }}
		if m.elems[i].key.computeDiff({{if not .KeyStoreByPtr}}&{{end}}val.elems[i].key) {
		{{- end}}
			ret = true
		    m.modifiedElems.setKeyModified(i)
		}
		{{- if .Value.Type.IsPrimitive }}
		if m.elems[i].value != val.elems[i].value {
		{{- else }}
		if m.elems[i].value.computeDiff({{if not .ValueStoreByPtr}}&{{end}}val.elems[i].value) {
		{{- end}}
			ret = true
			m.modifiedElems.setValModified(i)
		}
	}
	for ; i < len(m.elems); i++ {
        m.modifiedElems.setKeyModified(i)
        m.modifiedElems.setValModified(i)
        {{- if not .Key.Type.IsPrimitive }}
        m.elems[i].key.setModifiedRecursively()
        {{- end}}
        {{- if not .Value.Type.IsPrimitive }}
        m.elems[i].value.setModifiedRecursively()
        {{- end}}
	}
	return ret
}

{{if and (not .Key.Type.MustClone) (not .Value.Type.MustClone)}}
func (m *{{.MultimapName}}) Append(k {{.Key.Type.Exported}}, v {{.Value.Type.Exported}}) {
    l := len(m.elems)
    m.modifiedElems.changeLen(l, l+1)
	m.elems = append(m.elems, {{.MultimapName}}Elem{key: {{.Key.Type.ToStorage "k"}}, value: {{.Value.Type.ToStorage "v"}}})
}
{{end}}

{{if not .Key.Type.MustClone}}
// SetKey sets the key of the element at index i.
func (m *{{.MultimapName}}) SetKey(i int, k {{.Key.Type.Exported}}) {
	if m.elems[i].key != {{.Key.Type.ToStorage "k"}} {
		m.elems[i].key = {{.Key.Type.ToStorage "k"}}
		m.modifiedElems.markKeyModified(i)
	}
}

{{if .Value.Type.IsPrimitive}}
// SetValue sets the value of the element at index i.
func (m *{{.MultimapName}}) SetValue(i int, v {{.Value.Type.Exported}}) {
	if !{{.Value.Type.EqualFunc}}(m.elems[i].value, {{.Value.Type.ToStorage "v"}}) {
		m.elems[i].value = {{.Value.Type.ToStorage "v"}}
		m.modifiedElems.markValModified(i)
	}
}
{{end}}
{{end}}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (m *{{.MultimapName}}) byteSize() uint {
	return uint(unsafe.Sizeof({{.MultimapName}}Elem{}))*uint(len(m.elems))+uint(unsafe.Sizeof(m.elems))
}

// Copy from src to dst, overwriting existing data in dst.
func copy{{.MultimapName}}(dst *{{.MultimapName}}, src *{{.MultimapName}}) {
	if len(dst.elems)!=len(src.elems) {
		dst.EnsureLen(len(src.elems))
	}

	for i:=0; i < len(src.elems); i++ {
		{{- if .Key.Type.IsPrimitive}}
		if dst.elems[i].key != src.elems[i].key {
			dst.elems[i].key = src.elems[i].key
			dst.modifiedElems.markKeyModified(i)
		}
		{{else}}
		if !{{.Key.Type.EqualFunc}}({{if not .KeyStoreByPtr}}&{{end}}dst.elems[i].key, {{if not .KeyStoreByPtr}}&{{end}}src.elems[i].key) {
			copy{{.Key.Type.TypeName}}({{if not .KeyStoreByPtr}}&{{end}}dst.elems[i].key, {{if not .KeyStoreByPtr}}&{{end}}src.elems[i].key)
		}
		{{end}}

		{{- if .Value.Type.IsPrimitive}}
		if dst.elems[i].value != src.elems[i].value {
			dst.elems[i].value = src.elems[i].value
			dst.modifiedElems.markValModified(i)
		}
		{{else}}
		if !{{.Value.Type.EqualFunc}}({{if not .ValueStoreByPtr}}&{{end}}dst.elems[i].value, {{if not .ValueStoreByPtr}}&{{end}}src.elems[i].value) {
			copy{{.Value.Type.TypeName}}({{if not .ValueStoreByPtr}}&{{end}}dst.elems[i].value, {{if not .ValueStoreByPtr}}&{{end}}src.elems[i].value)
		}
		{{- end}}
	}
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNew{{.MultimapName}}(dst *{{.MultimapName}}, src *{{.MultimapName}}, allocators *Allocators) {
	if len(src.elems) == 0 {
        return
	}

	dst.EnsureLen(len(src.elems))

	{{- if and .Key.Type.IsPrimitive .Value.Type.IsPrimitive}}
	copy(dst.elems, src.elems)
	{{else}}
	for i:=0; i < len(src.elems); i++ {
		{{- if .Key.Type.IsPrimitive}}
		dst.elems[i].key = src.elems[i].key
		{{else}}
		copyToNew{{.Key.Type.TypeName}}({{if not .KeyStoreByPtr}}&{{end}}dst.elems[i].key, {{if not .KeyStoreByPtr}}&{{end}}src.elems[i].key, allocators)
		{{end}}
		{{- if .Value.Type.IsPrimitive}}
		dst.elems[i].value = src.elems[i].value
		{{else}}
		copyToNew{{.Value.Type.TypeName}}({{if not .ValueStoreByPtr}}&{{end}}dst.elems[i].value, {{if not .ValueStoreByPtr}}&{{end}}src.elems[i].value, allocators)
		{{- end}}
	}
	{{end}}
}

func (m *{{.MultimapName}}) CopyFrom(src *{{.MultimapName}}) {
    copy{{.MultimapName}}(m, src)
}

func (e *{{.MultimapName}}) IsEqual(val *{{.MultimapName}}) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		{{- if .Key.Type.IsPrimitive }}
		if !{{ .Key.Type.EqualFunc }}(e.elems[i].key,val.elems[i].key) {
			return false
		}
		{{- else }}
		if !e.elems[i].key.IsEqual({{if not .KeyStoreByPtr}}&{{end}}val.elems[i].key) {
			return false
		}
		{{- end}}
		{{- if .Value.Type.IsPrimitive }}
		if !{{ .Value.Type.EqualFunc }}(e.elems[i].value,val.elems[i].value) {
			return false
		}
		{{- else }}
		if !e.elems[i].value.IsEqual({{if not .ValueStoreByPtr}}&{{end}}val.elems[i].value) {
			return false
		}
		{{- end}}
	}
	return true
}

func {{.MultimapName}}Equal(left, right *{{.MultimapName}}) bool {
	return left.IsEqual(right)
}

func Cmp{{.MultimapName}}(left, right *{{.MultimapName}}) int {
    l := min(len(left.elems), len(right.elems))
    for i := 0; i < l; i++ {
        c := {{.Key.Type.CompareFunc}}(
            {{if and (not .Key.Type.IsPrimitive) (not .Key.Type.DictName)}}&{{end}}left.elems[i].key,
            {{if and (not .Key.Type.IsPrimitive) (not .Key.Type.DictName)}}&{{end}}right.elems[i].key)
        if c != 0 {
            return c
        }
    }
    lenDiff := len(left.elems) - len(right.elems)

    if lenDiff != 0 {
        return lenDiff
    }

    for i := 0; i < l; i++ {
        c := {{.Value.Type.CompareFunc}}(
			{{if and (not .Value.Type.IsPrimitive) (not .Value.Type.DictName)}}&{{end}}left.elems[i].value,
			{{if and (not .Value.Type.IsPrimitive) (not .Value.Type.DictName)}}&{{end}}right.elems[i].value,
		)
        if c != 0 {
            return c
        }
    }
    return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. If key or value contains structs/oneofs
// only fields that exist in the schema are mutated, allowing to generate data for
// specified schema.
func (m *{{ .MultimapName }}) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	if random.IntN(20)==0 {
		m.EnsureLen(m.Len()+1)
	}
	if random.IntN(20)==0 && m.Len()>0 {
		m.EnsureLen(m.Len()-1)
	}

	for i := range m.elems {
		_ = i
		if random.IntN(4*len(m.elems))==0 {
		{{- if not .Key.Type.IsPrimitive }}
			m.elems[i].key.mutateRandom(random, schem)
		{{- else }}
			m.SetKey(i, {{ .Key.Type.RandomFunc }})
		{{- end}}
		}
		if random.IntN(4*len(m.elems))==0 {
		{{- if not .Value.Type.IsPrimitive }}
			m.elems[i].value.mutateRandom(random, schem)
		{{- else }}
			m.SetValue(i, {{ .Value.Type.RandomFunc }})
		{{- end}}
		}
	}
}

// areKeysModified returns true if any key in the multimap was modified
// since the modified flags were last cleared.
func (m *{{ .MultimapName }}) areKeysModified() bool {
	return m.modifiedElems.areKeysModified()
}

type {{ .MultimapName }}Encoder struct {
    buf pkg.BytesWriter
	columns pkg.WriteColumnSet
	limiter *pkg.SizeLimiter

	keyEncoder   *{{.Key.Type.EncoderType}}Encoder
	isKeyRecursive bool
	valueEncoder *{{.Value.Type.EncoderType}}Encoder
	isValueRecursive bool
}

func (e *{{ .MultimapName }}Encoder) Init(state* WriterState, columns *pkg.WriteColumnSet) error {
	// Remember this encoder in the state so that we can detect recursion.
	if state.{{ .MultimapName }}Encoder != nil {
		panic("cannot initialize {{ .MultimapName }}Encoder: already initialized")
	}
	state.{{ .MultimapName }}Encoder = e
	defer func() { state.{{ .MultimapName }}Encoder = nil }()

	e.limiter = &state.limiter

	var err error
    {{- if .Key.Type.IsPrimitive}}
	e.keyEncoder = new({{.Key.Type.EncoderType}}Encoder)
	err = e.keyEncoder.Init({{if .Key.Type.DictName}}&state.{{.Key.Type.DictName}}, {{end}}e.limiter, columns.AddSubColumn())
    {{- else}}
	if state.{{.Key.Type.EncoderType}}Encoder != nil {
		// Recursion detected, use the existing encoder.
		e.keyEncoder = state.{{.Key.Type.EncoderType}}Encoder
		e.isKeyRecursive = true
	} else {
		e.keyEncoder = new({{.Key.Type.EncoderType}}Encoder)
		err = e.keyEncoder.Init(state, columns.AddSubColumn())
	}
    {{- end}}
	if err != nil {
		return nil
	}
    {{- if .Value.Type.IsPrimitive}}
	e.valueEncoder = new({{.Value.Type.EncoderType}}Encoder)
	err = e.valueEncoder.Init({{if .Value.Type.DictName}}&state.{{.Value.Type.DictName}}, {{end}}e.limiter, columns.AddSubColumn())
    {{- else}}
	if state.{{.Value.Type.EncoderType}}Encoder != nil {
		// Recursion detected, use the existing encoder.
		e.valueEncoder = state.{{.Value.Type.EncoderType}}Encoder
		e.isValueRecursive = true
	} else {
		e.valueEncoder = new({{.Value.Type.EncoderType}}Encoder)
		err = e.valueEncoder.Init(state, columns.AddSubColumn())
	}
    {{- end}}

	return err
}

func (e *{{ .MultimapName }}Encoder) Reset() {
	if !e.isKeyRecursive {
		e.keyEncoder.Reset()
	}
	if !e.isValueRecursive {
		e.valueEncoder.Reset()
	}
}

func (e *{{ .MultimapName }}Encoder) Encode(list *{{ .MultimapName }}) {
	oldLen := len(e.buf.Bytes())

	if len(list.elems) == 0 {
		// Zero-length attr list.
		e.buf.WriteUvarint(0b1)

		newLen := len(e.buf.Bytes())
		e.limiter.AddFrameBytes(uint(newLen - oldLen))

		return
	}

	if !list.areKeysModified() && len(list.elems) < 63 {
		e.encodeValuesOnly(list)
	} else {
		e.encodeFull(list)
	}

	newLen := len(e.buf.Bytes())
	e.limiter.AddFrameBytes(uint(newLen - oldLen))

	// Mark all elems non-modified so that next Encode() correctly
  	// encodes only elems that change after this.
	list.modifiedElems.setUnmodifiedAll()
}

func (e *{{ .MultimapName }}Encoder) encodeValuesOnly(list *{{ .MultimapName }}) {
	// The bits that describe the change value are exactly the bits
	// that are set in modifiedElems.
	changedValuesBits := list.modifiedElems.vals.mask

    // Record changedValuesBits (LSB is 0 to indicate values-only encoding).
	e.buf.WriteUvarint(changedValuesBits << 1)

	// Encode changed values only.
	bitToEncode := uint64(1)
	for i := range list.elems {
		if (bitToEncode & changedValuesBits) != 0 {
			e.valueEncoder.Encode({{if and (not .Value.Type.IsPrimitive) (not .Value.Type.DictName)}}&{{end}}list.elems[i].value)
		}
		bitToEncode <<= 1
	}
}

func (e *{{ .MultimapName }}Encoder) encodeFull(list *{{ .MultimapName }}) {
    // Record multimap len (LSB is 1 to indicate full encoding).
	e.buf.WriteUvarint(uint64(len(list.elems))<<1 | 0b1)

	// Encode keys and values.
	for i := range list.elems {
		e.keyEncoder.Encode({{if and (not .Key.Type.IsPrimitive) (not .Key.Type.DictName)}}&{{end}}list.elems[i].key)
		e.valueEncoder.Encode({{if and (not .Value.Type.IsPrimitive) (not .Value.Type.DictName)}}&{{end}}list.elems[i].value)
	}
}

func (e *{{ .MultimapName }}Encoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBytes(&e.buf)
	if !e.isKeyRecursive {
 		e.keyEncoder.CollectColumns(columnSet.At(0))
 	}
	if !e.isValueRecursive {
		e.valueEncoder.CollectColumns(columnSet.At(1))
	}
}

type {{.MultimapName}}Decoder struct {
    buf pkg.BytesReader
	column *pkg.ReadableColumn

	keyDecoder   *{{.Key.Type.EncoderType}}Decoder
	isKeyRecursive bool
	valueDecoder *{{.Value.Type.EncoderType}}Decoder
	isValueRecursive bool
}

// Init is called once in the lifetime of the stream.
func (d *{{ .MultimapName }}Decoder) Init(state* ReaderState, columns *pkg.ReadColumnSet) error {
	// Remember this decoder in the state so that we can detect recursion.
	if state.{{ .MultimapName }}Decoder != nil {
		panic("cannot initialize {{ .MultimapName }}Decoder: already initialized")
	}
	state.{{ .MultimapName }}Decoder = d
	defer func() { state.{{ .MultimapName }}Decoder = nil }()

	d.column = columns.Column()

	var err error
{{- if .Key.Type.IsPrimitive}}
	d.keyDecoder = new({{.Key.Type.EncoderType}}Decoder)
	err = d.keyDecoder.Init({{if .Key.Type.DictName}}&state.{{.Key.Type.DictName}}, {{end}}columns.AddSubColumn())
{{- else}}
	if state.{{.Key.Type.EncoderType}}Decoder != nil {
		// Recursion detected, use the existing decoder.
		d.keyDecoder = state.{{.Key.Type.EncoderType}}Decoder
		d.isValueRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.keyDecoder = new({{.Key.Type.EncoderType}}Decoder)
		err = d.keyDecoder.Init(state, columns.AddSubColumn())
	}
{{- end}}
	if err != nil {
		return nil
	}

{{- if .Value.Type.IsPrimitive}}
	d.valueDecoder = new({{.Value.Type.EncoderType}}Decoder)
	err = d.valueDecoder.Init({{if .Value.Type.DictName}}&state.{{.Value.Type.DictName}}, {{end}}columns.AddSubColumn())
{{- else}}
	if state.{{.Value.Type.EncoderType}}Decoder != nil {
		// Recursion detected, use the existing decoder.
		d.valueDecoder = state.{{.Value.Type.EncoderType}}Decoder
		d.isValueRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.valueDecoder = new({{.Value.Type.EncoderType}}Decoder)
		err = d.valueDecoder.Init(state, columns.AddSubColumn())
	}
{{- end}}

	return err
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *{{ .MultimapName }}Decoder) Continue() {
    d.buf.Reset(d.column.Data())
	if !d.isKeyRecursive {
		d.keyDecoder.Continue()
	}
	if !d.isValueRecursive {
    	d.valueDecoder.Continue()
	}
}

func (d *{{ .MultimapName }}Decoder) Reset() {
	if !d.isKeyRecursive {
		d.keyDecoder.Reset()
	}
	if !d.isValueRecursive {
		d.valueDecoder.Reset()
	}
}

func (d *{{ .MultimapName }}Decoder) Decode(dst *{{.MultimapName}}) error {
	countOrChangedValues, err := d.buf.ReadUvarint()
	if err != nil {
		return err
	}
	if countOrChangedValues == 0 {
		// Nothing changed.
		return nil
	}

	if countOrChangedValues&0b1 == 0 {
		return d.decodeValuesOnly(countOrChangedValues >> 1, dst)
	}

	if countOrChangedValues&0b1 == 0b1 {
		return d.decodeFull(int(countOrChangedValues >> 1), dst)
	}
	return pkg.ErrMultimap
}

func (d *{{.MultimapName}}Decoder) decodeValuesOnly(changedValuesBits uint64, dst *{{.MultimapName}}) error {
	// Decode changed values
	var err error
	bitToRead := uint64(1)
	for i := range dst.elems {
		if (bitToRead & changedValuesBits) != 0 {
			// Value is changed, decode it.
			err = d.valueDecoder.Decode(&dst.elems[i].value)
			if err != nil {
				return err
			}
		}
		bitToRead <<= 1
	}

	return nil
}

func (d *{{ .MultimapName }}Decoder) decodeFull(count int, dst *{{.MultimapName}}) error {
	if count < 0 || count >= pkg.MultimapElemCountLimit {
		return pkg.ErrMultimapCountLimit
	}

	dst.EnsureLen(count)

	var err error
	for i := 0; i < count; i++ {
		err = d.keyDecoder.Decode(&dst.elems[i].key)
		if err != nil {
			return err
		}
		err = d.valueDecoder.Decode(&dst.elems[i].value)
		if err != nil {
			return err
		}
	}

	return nil
}
