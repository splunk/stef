package {{ .PackageName }}

import (
	"math/rand/v2"
	{{if and (not .ElemType.MustClone) (not .ElemType.Enum)}}
	"slices"
	{{end}}
	"unsafe"
	"strings"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

var _ = (*encoders.StringEncoder)(nil)
var _ = (*strings.Builder)(nil)

// {{ .ArrayName }} is a variable size array.
type {{ .ArrayName }} struct {
	elems []{{if .IsStructType}}*{{end}}{{.ElemType.Storage}}

	parentModifiedFields *modifiedFields
	parentModifiedBit uint64
}

func (e *{{.ArrayName}}) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	e.parentModifiedFields = parentModifiedFields
	e.parentModifiedBit = parentModifiedBit
}

func (e *{{.ArrayName}}) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
	e.init(parentModifiedFields, parentModifiedBit)
}

// reset the array to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (e *{{.ArrayName}}) reset() {
    e.elems = e.elems[:0]
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (e *{{.ArrayName}}) fixParent(parentModifiedFields *modifiedFields) {
    e.parentModifiedFields = parentModifiedFields
}

func (e *{{.ArrayName}}) canBeShared() bool {
    // An array can never be shared.
    return false
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (e *{{.ArrayName}}) byteSize() uint {
    if len(e.elems)==0 {
        return 0
    }
    // TODO: add size of elements if they are clonable.
    size := uint(unsafe.Sizeof(e.elems[0]))*uint(len(e.elems))+uint(unsafe.Sizeof(e))
    {{if .ElemType.MustClone}}
    for i := range e.elems {
        size += e.elems[i].byteSize()
    }{{end}}
    return size
}

{{if not .ElemType.MustClone}}
// CopyFromSlice copies from a slice into this array. The length
// of the array will be equal to the length of slice and elements of
// the array will be assigned from elements of the slice.
func (e* {{.ArrayName}}) CopyFromSlice(src []{{.ElemType.Exported}}) {
{{if .ElemType.Enum}}
{{/*    Enums need special handling to convert from exported type to storage type.*/}}
    differ := false
    if len(e.elems) != len(src) {
        differ = true
    } else {
        for i:=0; i<len(src); i++ {
            if e.elems[i] != {{.ElemType.ToStorage "src[i]"}} {
                differ = true
                break
            }
        }
    }
    if differ {
        e.EnsureLen(len(src))
        for i:=0; i<len(src); i++ {
            e.elems[i] = {{.ElemType.ToStorage "src[i]" }}
        }
        e.markModified()
    }
{{else -}}
	if !slices.Equal(e.elems, src) {
		e.EnsureLen(len(src))
		copy(e.elems, src)
		e.markModified()
	}
{{- end}}
}

{{end}}

// Append a new element at the end of the array.
func (e* {{.ArrayName}}) Append(val {{if .IsStructType}}*{{end}}{{.ElemType.Exported}}) {
	e.elems = append(e.elems, {{.ElemType.ToStorage "val"}})
	e.markModified()
}

func (e* {{.ArrayName}}) markModified() {
	e.parentModifiedFields.markModified(e.parentModifiedBit)
}

func (e* {{.ArrayName}}) setModifiedRecursively() {
{{if not .ElemType.IsPrimitive -}}
	for i:=0; i < len(e.elems); i++ {
		e.elems[i].setModifiedRecursively()
	}
{{end}}
}

func (e* {{.ArrayName}}) setUnmodifiedRecursively() {
{{if not .ElemType.IsPrimitive -}}
	for i:=0; i < len(e.elems); i++ {
		e.elems[i].setUnmodifiedRecursively()
	}
{{end}}
}

// computeDiff compares e and val and returns true if they differ.
// All fields that are different in e will be marked as modified.
func (e *{{ .ArrayName }}) computeDiff(val *{{ .ArrayName }}) (ret bool) {
	if len(e.elems) != len(val.elems) {
		ret = true
	}
	minLen := min(len(e.elems), len(val.elems))
	i := 0
	for ; i < minLen; i++ {
		{{- if .ElemType.IsPrimitive }}
		if e.elems[i] != val.elems[i] {
		{{- else }}
		if e.elems[i].computeDiff({{if not .IsStructType}}&{{end}}val.elems[i]) {
		{{- end}}
			ret = true
		}
	}
    {{- if not .ElemType.IsPrimitive }}
	for ; i < len(e.elems); i++ {
        e.elems[i].setModifiedRecursively()
	}
    {{- end}}
	return ret
}

// Copy from src to dst, overwriting existing data in dst.
func copy{{.ArrayName}}(dst* {{.ArrayName}}, src *{{.ArrayName}}) {
	isModified := false

	minLen := min(len(dst.elems), len(src.elems))
	if len(dst.elems) != len(src.elems) {
	    dst.EnsureLen(len(src.elems))
		isModified = true
	}

	i := 0

	// Copy elements in the part of the array that already had the necessary room.
	for ; i < minLen; i++ {
		{{- if .ElemType.MustClone}}
		if src.elems[i].canBeShared() {
			if src.elems[i].computeDiff({{if not .IsStructType}}&{{end}}dst.elems[i]) {
				dst.elems[i] = src.elems[i]
				isModified = true
			}
		} else {
		    copy{{.ElemType.TypeName}}({{if not .IsStructType}}&{{end}}dst.elems[i], {{if not .IsStructType}}&{{end}}src.elems[i])
    		isModified = true
		}
		{{- else}}
		if dst.elems[i] != src.elems[i] {
			dst.elems[i] = src.elems[i]
			isModified = true
		}
		{{- end}}
	}

	{{- if .ElemType.MustClone}}
	if minLen < len(dst.elems) {
		isModified = true
		for ; i < len(dst.elems); i++ {
			if src.elems[i].canBeShared() {
				dst.elems[i] = src.elems[i]
				dst.elems[i].setModifiedRecursively()
			} else {
    			dst.elems[i] = {{if .IsStructType}}&{{end}}{{.ElemType.Storage}}{}
	    		dst.elems[i].init(dst.parentModifiedFields, dst.parentModifiedBit)
		    	copy{{.ElemType.TypeName}}({{if not .IsStructType}}&{{end}}dst.elems[i], {{if not .IsStructType}}&{{end}}src.elems[i])
		    }
		}
	}
	{{- else}}
	for ; i < len(dst.elems); i++ {
		if dst.elems[i] != src.elems[i] {
			dst.elems[i] = src.elems[i]
			isModified = true
		}
	}
	{{- end}}
	if isModified {
		dst.markModified()
	}
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNew{{.ArrayName}}(dst* {{.ArrayName}}, src *{{.ArrayName}}, allocators *Allocators) {
    if len(src.elems)==0 {
        return
    }

	dst.ensureLen(len(src.elems), allocators)

	{{- if .ElemType.MustClone}}
    // Need to allocate new elements for the part of the array that has grown.
    for j := 0; j<len(dst.elems); j++ {
        if src.elems[j].canBeShared() {
            dst.elems[j] = src.elems[j]
        } else {
            // Alloc and init the element.
            {{if .IsStructType}}dst.elems[j] = allocators.{{.ElemType.Storage}}.Alloc(){{end}}
            dst.elems[j].initAlloc(dst.parentModifiedFields, dst.parentModifiedBit, allocators)
            // Copy the element.
            copyToNew{{.ElemType.TypeName}}({{if not .IsStructType}}&{{end}}dst.elems[j], {{if not .IsStructType}}&{{end}}src.elems[j], allocators)
        }
    }
	{{- else}}
	for i:=0; i < len(dst.elems); i++ {
		dst.elems[i] = src.elems[i]
	}
	{{- end}}
}

// Len returns the number of elements in the array.
func (e *{{.ArrayName}}) Len() int {
	return len(e.elems)
}

// At returns element at index i.
func (m *{{.ArrayName}}) At(i int) {{if .IsStructType}}*{{end}}{{.ElemType.Exported}} {
	return {{.ElemType.ToExported "m.elems[i]"}}
}

// EnsureLen ensures the length of the array is equal to newLen.
// It will grow or shrink the array if needed.
func (e *{{.ArrayName}}) EnsureLen(newLen int) {
    {{- if not .ElemType.IsPrimitive}}
    oldLen := len(e.elems)
    {{- end}}
    e.ensureLen(newLen, &Allocators{})
    {{- if not .ElemType.IsPrimitive}}
    for i:=min(oldLen, newLen); i < newLen; i++ {
        // Reset newly created elements to initial state.
        e.elems[i].reset()
    }
    {{- end}}
}

// EnsureLen ensures the length of the array is equal to newLen.
// It will grow or shrink the array if needed.
func (e *{{.ArrayName}}) ensureLen(newLen int, allocators *Allocators) {
	oldLen := len(e.elems)
	if newLen > oldLen {
        // Check if the underlying array is reallocated.
        {{- if not .ElemType.IsPrimitive}}
        beforePtr := unsafe.SliceData(e.elems)
		{{- end}}

		// Grow the array
		e.elems = append(e.elems, make([]{{if .IsStructType}}*{{end}}{{.ElemType.Storage}}, newLen-oldLen)...)
		e.markModified()
		{{- if .IsStructType}}
		// Initialize newly added elements.
		for ; oldLen<newLen; oldLen++ {
			e.elems[oldLen] = allocators.{{.ElemType.Storage}}.Alloc()
			e.elems[oldLen].initAlloc(e.parentModifiedFields, e.parentModifiedBit, allocators)
		}
		{{- end}}

        {{- if not .ElemType.IsPrimitive}}
		if beforePtr != unsafe.SliceData(e.elems) {
		    // Underlying array was reallocated, we need to fix parent pointers
		    // in all elements.
		    for i:=0; i < newLen; i++ {
		        e.elems[i].fixParent(e.parentModifiedFields)
		    }
		}
        {{- end}}
	} else if oldLen > newLen {
		// Shrink it
		e.elems = e.elems[:newLen]
		e.markModified()
	}
}

// IsEqual performs deep comparison and returns true if array is equal to val.
func (e *{{ .ArrayName }}) IsEqual(val *{{ .ArrayName }}) bool {
	if len(e.elems) != len(val.elems) {
		return false
	}
	for i := range e.elems {
		{{- if .ElemType.IsPrimitive }}
		if !{{ .ElemType.EqualFunc }}(e.elems[i],val.elems[i]) {
			return false
		}
		{{- else }}
		if !e.elems[i].IsEqual({{if not .IsStructType}}&{{end}}val.elems[i]) {
			return false
		}
		{{- end}}
	}
	return true
}

func {{.ArrayName}}Equal(left, right *{{.ArrayName}}) bool {
	return left.IsEqual(right)
}

// Cmp{{.ArrayName}} performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func Cmp{{.ArrayName}}(left, right *{{ .ArrayName }}) int {
	c := len(left.elems) - len(right.elems)
	if c != 0 {
		return c
	}
	for i := range left.elems {
		fc := {{.ElemType.CompareFunc}}({{if and (not .ElemType.IsPrimitive) (not .IsStructType)}}&{{end}}left.elems[i], {{if and (not .ElemType.IsPrimitive) (not .IsStructType)}}&{{end}}right.elems[i])
		if fc != 0 {
			return fc
		}
	}
	return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. If array elements contain structs/oneofs
// only fields that exist in the schema are mutated, allowing to generate data for
// specified schema.
func (a *{{ .ArrayName }}) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	if random.IntN(20)==0 {
		a.EnsureLen(a.Len()+1)
	}
	if random.IntN(20)==0 && a.Len()>0 {
		a.EnsureLen(a.Len()-1)
	}

	for i := range a.elems {
		_ = i
		if random.IntN(2*len(a.elems))==0 {
		{{- if not .ElemType.IsPrimitive }}
			a.elems[i].mutateRandom(random, schem)
		{{- else}}
			v := {{ .ElemType.RandomFunc }}
			if a.elems[i] != {{.ElemType.ToStorage "v"}} {
				a.elems[i] = {{.ElemType.ToStorage "v"}}
				a.markModified()
			}
		{{- end}}
		}
	}
}

type {{ .ArrayName }}Encoder struct {
    buf pkg.BitsWriter
	limiter *pkg.SizeLimiter
	elemEncoder *{{.ElemType.EncoderType}}Encoder
    isRecursive bool
	state* WriterState
}

func (e *{{ .ArrayName }}Encoder) Init(state* WriterState, columns *pkg.WriteColumnSet) error {
	e.state = state
	e.limiter = &state.limiter

	{{ if .ElemType.IsPrimitive -}}
	e.elemEncoder = new({{.ElemType.EncoderType}}Encoder)
	if err := e.elemEncoder.Init({{- if .ElemType.DictName}}&e.state.{{.ElemType.DictName}}, {{end -}}e.limiter, columns.AddSubColumn()); err != nil {
		return err
	}
	{{- else -}}
	// Remember this encoder in the state so that we can detect recursion.
	if state.{{ .ArrayName }}Encoder != nil {
		panic("cannot initialize {{ .ArrayName }}Encoder: already initialized")
	}
	state.{{ .ArrayName }}Encoder = e
	defer func() { state.{{ .ArrayName }}Encoder = nil }()

	if state.{{.ElemType.EncoderType}}Encoder != nil {
		// Recursion detected, use the existing encoder.
		e.elemEncoder = state.{{.ElemType.EncoderType}}Encoder
		e.isRecursive = true
	} else {
		e.elemEncoder = new({{.ElemType.EncoderType}}Encoder)
		if err := e.elemEncoder.Init(state, columns.AddSubColumn()); err != nil {
			return err
		}
	}
	{{- end}}

	return nil
}

func (e *{{ .ArrayName }}Encoder) Reset() {
	if !e.isRecursive {
		e.elemEncoder.Reset()
	}
}

func (e *{{ .ArrayName }}Encoder) Encode(arr *{{ .ArrayName }}) {
	oldBitLen := e.buf.BitCount()

    // Write the length of the array.
	newLen := len(arr.elems)
    e.buf.WriteUvarintCompact(uint64(newLen))

    // Encode the elements of the array.
    for i := 0; i < newLen; i++ {
        e.elemEncoder.Encode({{if and (not .ElemType.IsPrimitive) (not .IsStructType)}}&{{end}}arr.elems[i])
    }

	// Account written bits in the limiter.
	newBitLen := e.buf.BitCount()
	e.limiter.AddFrameBits(newBitLen-oldBitLen)
}

func (e *{{ .ArrayName }}Encoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)
	if !e.isRecursive {
		e.elemEncoder.CollectColumns(columnSet.At(0))
	}
}

type {{ .ArrayName }}Decoder struct {
    buf pkg.BitsReader
	column *pkg.ReadableColumn
	elemDecoder *{{.ElemType.EncoderType}}Decoder
	isRecursive bool
	allocators *Allocators

    {{- if .DictName}}
	// Zero-inited elem. New array entries point into this temporarily during decoding.
	emptyElem {{.ElemType.Storage}}
	{{- end}}
}

// Init is called once in the lifetime of the stream.
func (d *{{ .ArrayName }}Decoder) Init(state* ReaderState, columns *pkg.ReadColumnSet) error {
	d.column = columns.Column()

{{- if .ElemType.IsPrimitive}}
	d.elemDecoder = new({{.ElemType.EncoderType}}Decoder)
{{- if .ElemType.DictName}}
	err := d.elemDecoder.Init(&state.{{.ElemType.DictName}}, columns.AddSubColumn())
{{- else}}
	err := d.elemDecoder.Init(columns.AddSubColumn())
{{- end}}
	if err != nil {
		return err
	}
{{- else}}
	// Remember this encoder in the state so that we can detect recursion.
	if state.{{ .ArrayName }}Decoder != nil {
		panic("cannot initialize {{ .ArrayName }}Decoder: already initialized")
	}
	state.{{ .ArrayName }}Decoder = d
	defer func() { state.{{ .ArrayName }}Decoder = nil }()

	if state.{{.ElemType.EncoderType}}Decoder != nil {
		d.elemDecoder = state.{{.ElemType.EncoderType}}Decoder
		d.isRecursive = true
	} else {
		d.elemDecoder = new({{.ElemType.EncoderType}}Decoder)
		if err := d.elemDecoder.Init(state, columns.AddSubColumn()); err != nil {
			return err
		}
	}
{{- end}}

    d.allocators = &state.Allocators

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *{{ .ArrayName }}Decoder) Continue() {
	d.buf.Reset(d.column.Data())
	if !d.isRecursive {
		d.elemDecoder.Continue()
	}
}

func (d *{{ .ArrayName }}Decoder) Reset() {
	if !d.isRecursive {
		d.elemDecoder.Reset()
	}
}

func (d *{{ .ArrayName }}Decoder) Decode(dst *{{.ArrayName}}) error {
	newLen := int(d.buf.ReadUvarintCompact())

    {{if not .ElemType.IsPrimitive}}oldLen := len(dst.elems){{end}}
	dst.ensureLen(newLen, d.allocators)

    {{- if not .ElemType.IsPrimitive}}
    for i:=min(oldLen, newLen); i < newLen; i++ {
        // Reset newly created elements to initial state.
        {{- if .DictName}}
        dst.elems[i] = &d.emptyElem
        {{- else}}
        dst.elems[i].reset()
        {{- end}}
    }
    {{- end}}

	for i := 0; i < newLen; i++ {
		{{- if .ElemType.IsPrimitive}}
		err := d.elemDecoder.Decode({{if .ElemType.Flags.DecodeByPtr}}&{{end}}dst.elems[i])
		if err != nil {
			return err
		}
		{{- else}}
		err := d.elemDecoder.Decode({{if or (.ElemType.DictName) (not .IsStructType)}}&{{end}}dst.elems[i])
		if err != nil {
			return err
		}
		{{- end}}
	}

	return d.buf.Error()
}