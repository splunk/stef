{{- /*gotype: github.com/splunk/stef/stefc/generator.StructTemplateModel*/ -}}
package {{ .PackageName }}

import (
    "fmt"
	"math/bits"
    "math/rand/v2"
    "strings"
	"unsafe"

    {{if .DictName}}
	"modernc.org/b/v2"{{end}}

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/codecs"
    "github.com/splunk/stef/go/pkg/schema"
)

var _ = strings.Compare
var _ = codecs.StringEncoder{}

// {{ .StructName }} is a oneof struct.
type {{ .StructName }} struct {
    // The current type of the oneof.
	typ {{$.StructName }}Type
    {{ range .Fields }}
    {{.name}} {{if .Type.Flags.StoreByPtr}}*{{end}}{{ .Type.Storage }}
    {{- end }}

    // Pointer to parent's modifiedFields
    parentModifiedFields *modifiedFields
    // Bit to set in parent's modifiedFields when this oneof is modified.
    parentModifiedBit uint64
}

// Init must be called once, before the {{.StructName }} is used.
func (s *{{.StructName }}) Init() {
    s.init(nil, 0)
}

func (s *{{ $.StructName }}) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
    s.parentModifiedFields = parentModifiedFields
    s.parentModifiedBit = parentModifiedBit

    {{ range .Fields }}
	{{- if and (not .Type.IsPrimitive) (not .Type.Flags.StoreByPtr) }}
    s.{{.name}}.init(parentModifiedFields, parentModifiedBit)
    {{- end -}}
    {{- end -}}
}

func (s *{{ $.StructName }}) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
    s.parentModifiedFields = parentModifiedFields
    s.parentModifiedBit = parentModifiedBit

    {{ range .Fields }}
	{{- if and (not .Type.IsPrimitive) (not .Type.Flags.StoreByPtr) }}
    s.{{.name}}.initAlloc(parentModifiedFields, parentModifiedBit, allocators)
    {{- end -}}
    {{- end -}}
}

// reset the struct to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (s *{{ $.StructName }}) reset() {
    s.typ = {{$.StructName }}TypeNone
    // We don't need to reset the state of the field since that will be done
    // when the type is changed, see SetType().
}

func (s *{{ $.StructName }}) freeze() {
    switch s.typ {
    {{- range .Fields }}
    {{- if not .Type.IsPrimitive}}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.Flags.StoreByPtr}}
        if s.{{.name}} != nil {
            s.{{.name}}.freeze()
        }
        {{- else}}
        s.{{.name}}.freeze()
        {{- end -}}
    {{- end -}}
    {{- end }}
    }
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (s *{{ $.StructName }}) fixParent(parentModifiedFields *modifiedFields) {
    s.parentModifiedFields = parentModifiedFields

    {{ range .Fields }}
	{{- if and (not .Type.IsPrimitive) (not .Type.Flags.StoreByPtr) }}
    s.{{.name}}.fixParent(parentModifiedFields)
    {{- end -}}
    {{- end -}}
}

type {{$.StructName }}Type byte
const (
    {{.StructName }}TypeNone = {{$.StructName }}Type(iota)
{{- range .Fields }}
    {{$.StructName }}Type{{.Name}}
{{- end }}
    {{.StructName}}TypeCount
)

// Type returns the type of the value currently contained in {{ $.StructName }}.
func (s *{{ $.StructName }}) Type() {{$.StructName }}Type {
    return s.typ
}

// resetContained resets the currently contained value, if any.
// Normally used after switching to a different type to make sure
// the value contained is in blank state.
func (s *{{ $.StructName }}) resetContained() {
    switch s.typ {
    {{- range .Fields }}
    {{- if not .Type.IsPrimitive}}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.Flags.StoreByPtr}}
        if s.{{.name}} != nil {
            s.{{.name}}.reset()
        }
        {{- else}}
        s.{{.name}}.reset()
        {{- end -}}
    {{- end -}}
    {{- end }}
    }
}

// SetType sets the type of the value currently contained in {{ $.StructName }}.
func (s *{{ $.StructName }}) SetType(typ {{$.StructName }}Type) {
	if s.typ != typ {
        s.typ = typ
        s.resetContained()
        switch typ {
        {{- range .Fields }}
        {{- if .Type.Flags.StoreByPtr}}
        case {{ $.StructName }}Type{{.Name}}:
            if s.{{.name}} == nil {
                s.{{.name}} = &{{ .Type.Storage }}{}
                s.{{.name}}.init(s.parentModifiedFields, s.parentModifiedBit)
            }
        {{- end -}}
        {{- end }}
        }
        s.markParentModified()
    }
}

{{ range .Fields }}
// {{.Name}} returns the value if the contained type is currently {{$.StructName }}Type{{.Name}}.
// The caller must check the type via Type() before attempting to call this function.
func (s *{{ $.StructName }}) {{.Name}}() {{if .Type.Flags.PassByPtr}}*{{end}}{{.Type.Exported}} {
{{- if .Type.IsPrimitive}}
    return {{.Type.ToExported (print "s." .name)}}
{{- else}}
	return {{if and .Type.Flags.PassByPtr (not .Type.Flags.StoreByPtr)}}&{{end}}s.{{.name}}
{{- end}}
}

{{if .Type.IsPrimitive}}
// Set{{.Name}} sets the value to the specified value and sets the type to {{$.StructName }}Type{{.Name}}.
func (s *{{ $.StructName }}) Set{{.Name}}(v {{if .PassByPointer}}*{{end}}{{.Type.Exported}}) {
    if s.typ!={{$.StructName }}Type{{.Name}} || s.{{.name}} != {{.Type.ToStorage "v"}} {
		s.{{.name}} = {{.Type.ToStorage "v"}}
		s.typ = {{$.StructName }}Type{{.Name}}
        s.parentModifiedFields.markModified(s.parentModifiedBit)
    }
}
{{end}}
{{ end }}

func (s *{{ .StructName }}) canBeShared() bool {
    // Oneof can never be shared.
    return false
}

func (s *{{ .StructName }}) cloneShared(allocators *Allocators) {{if .Type.Flags.StoreByPtr}}*{{end}}{{.StructName}} {
    // Oneof is not shareable, so cloneShared is just a Clone.
    return s.Clone(allocators)
}

func (s *{{ .StructName }}) Clone(allocators *Allocators) {{if .Type.Flags.StoreByPtr}}*{{end}}{{.StructName}} {
{{- if .Type.Flags.StoreByPtr}}
    allocators.allocSizeChecker.AddAllocSize(uint(unsafe.Sizeof({{.StructName}}{})))
    c := allocators.{{.StructName}}.Alloc()
{{- else}}
    c := {{.StructName}}{}
{{- end}}
    c.typ = s.typ
    switch s.typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.IsPrimitive}}
        c.{{.name}} = s.{{.name}}
        {{- else if .Type.Flags.StoreByPtr}}
        c.{{.name}} = s.{{.name}}.cloneShared(allocators)
        {{- else}}
        copyToNew{{.Type.Storage}}({{if .Type.Flags.TakePtr}}&{{end}}c.{{.name}}, {{if .Type.Flags.TakePtr}}&{{end}}s.{{.name}}, allocators)
        {{- end}}
    {{- end }}
	}
    return c
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (s *{{ .StructName }}) byteSize() uint {
    return uint(unsafe.Sizeof(*s))+
       {{range .Fields -}}
       {{- if .Type.MustClone}}s.{{.name}}.byteSize()+{{end}}
       {{- end }}0
}

// Copy from src to dst, overwriting existing data in dst.
func copy{{.StructName}}(dst *{{.StructName}}, src *{{.StructName}}) {
	switch src.typ {
    {{- range .Fields}}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.MustClone}}
        dst.SetType(src.typ)
        copy{{.Type.TypeName}}(
            {{- if .Type.Flags.TakePtr}}&{{end}}dst.{{.name }},
            {{- if .Type.Flags.TakePtr}}&{{end}}src.{{.name}})
        {{- else}}
        dst.Set{{.Name}}({{.Type.ToExported (print "src." .name)}})
        {{- end}}
    {{- end}}
    case {{ $.StructName }}TypeNone:
        if dst.typ != {{ $.StructName }}TypeNone {
            dst.typ = {{ $.StructName }}TypeNone
            dst.markParentModified()
        }
    default: panic("copy{{.StructName}}: unexpected type: " + fmt.Sprint(src.typ))
    }
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNew{{.StructName}}(dst *{{.StructName}}, src *{{.StructName}}, allocators *Allocators) {
    dst.typ = src.typ
	switch src.typ {
    {{- range .Fields}}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.MustClone}}
        {{- if .Type.Flags.StoreByPtr}}
        allocators.allocSizeChecker.AddAllocSize(uint(unsafe.Sizeof({{.Type.Storage}}{})))
        dst.{{.name}} = allocators.{{ .Type.Storage }}.Alloc()
        dst.{{.name}}.init(dst.parentModifiedFields, dst.parentModifiedBit)
        {{- end}}
        copyToNew{{.Type.TypeName}}(
            {{- if .Type.Flags.TakePtr}}&{{end}}dst.{{.name }},
            {{- if .Type.Flags.TakePtr}}&{{end}}src.{{.name}}, allocators)
        {{- else}}
        if dst.{{.name}} != src.{{.name}} {
            dst.{{.name}} = src.{{.name}}
            dst.parentModifiedFields.markModified(dst.parentModifiedBit)
        }
        {{- end}}
    {{- end}}
    case {{ $.StructName }}TypeNone:
    default: panic("copy{{.StructName}}: unexpected type: " + fmt.Sprint(src.typ))
    }
}

// CopyFrom() performs a deep copy from src.
func (s* {{.StructName}}) CopyFrom(src *{{.StructName}}) {
    copy{{.StructName}}(s, src)
}

func (s* {{.StructName}}) markParentModified() {
	s.parentModifiedFields.markModified(s.parentModifiedBit)
}

func (s *{{ $.StructName }}) setModifiedRecursively() {
    switch s.typ {
    {{- range .Fields}}
        {{- if not .Type.IsPrimitive}}
        case {{ $.StructName }}Type{{.Name}}:
            s.{{.name}}.setModifiedRecursively()
        {{- end}}
    {{- end}}
    }
}

func (s *{{ $.StructName }}) setUnmodifiedRecursively() {
    switch s.typ {
    {{- range .Fields}}
        {{- if not .Type.IsPrimitive}}
        case {{ $.StructName }}Type{{.Name}}:
            s.{{.name}}.setUnmodifiedRecursively()
        {{- end}}
    {{- end}}
    }
}

// computeDiff compares s and val and returns true if they differ.
// All fields that are different in s will be marked as modified.
func (s *{{ $.StructName }}) computeDiff(val *{{ $.StructName }}) (ret bool) {
    if s.typ == val.typ {
        switch s.typ {
        {{- range .Fields}}
        case {{ $.StructName }}Type{{.Name}}:
            {{- if .Type.IsPrimitive}}
            ret = s.{{.name}} != val.{{.name}}
            {{- else}}
            ret = s.{{.name}}.computeDiff({{- if .Type.Flags.TakePtr}}&{{end}}val.{{.name}})
            {{- end}}
        {{- end }}
        }
    } else {
        ret = true
        switch s.typ {
        {{- range .Fields}}
        {{- if not .Type.IsPrimitive}}
        case {{ $.StructName }}Type{{.Name}}:
            // val.{{.name}} doesn't exist at all so mark the whole s.{{.name}} subtree as modified.
            s.{{.name}}.setModifiedRecursively()
        {{- end}}
        {{- end }}
        }
    }
    return ret
}

// IsEqual performs deep comparison and returns true if struct is equal to val.
func (e *{{ .StructName }}) IsEqual(val *{{ .StructName }}) bool {
    if e.typ != val.typ {
        return false
    }
    switch e.typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        {{- if .Type.IsPrimitive }}
        return {{ .Type.EqualFunc }}(e.{{.name}}, val.{{.name}})
        {{- else }}
        return e.{{.name}}.IsEqual({{- if .Type.Flags.TakePtr}}&{{end}}val.{{.name}})
        {{- end }}
        {{- end }}
    }

    return true
}

// Cmp{{.StructName}} performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func Cmp{{.StructName}}(left, right *{{.StructName}}) int {
    c := pkg.Uint64Compare(uint64(left.typ), uint64(right.typ))
    if c != 0 {
        return c
    }
    switch left.typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        return {{ .Type.CompareFunc }}(
            {{- if .Type.Flags.TakePtr}}&{{end}}left.{{.name}},
            {{- if .Type.Flags.TakePtr}}&{{end}}right.{{.name}})
    {{- end }}
    }

    return 0
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. Only fields that exist
// in the schema are mutated, allowing to generate data for specified schema.
func (s *{{ .StructName }}) mutateRandom(random *rand.Rand, schem *schema.Schema, limiter *mutateRandomLimiter) {
    {{- if len .Fields }}
    // Get the field count for this oneof from the schema. If the schema specifies
    // fewer field count than the one we have in this code then we will not mutate
    // the type of the oneof to the choices that are not in the schema.
    fieldCount, err := schem.FieldCount({{printf "%q" .StructName}})
    if err != nil {
        panic(fmt.Sprintf("cannot get field count for %s: %v", {{printf "%q" .StructName}}, err))
    }

typeChanged := false
    if random.IntN(10)==0 {
        s.SetType({{$.StructName }}Type(random.IntN(fieldCount+1)))
        typeChanged = true
    }
    {{ end }}
    switch s.typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        if typeChanged || random.IntN(2)==0 {
        {{- if not .Type.IsPrimitive }}
            s.{{.name}}.mutateRandom(random, schem, limiter)
        {{- else }}
            s.Set{{.Name}}({{.Type.ToExported (print .Type.RandomFunc)}})
        {{- end}}
        }
    {{- end }}
    }
}

// {{ .StructName }}Encoder implements encoding of {{ .StructName }}
type {{ .StructName }}Encoder struct {
    buf pkg.BitsWriter
	limiter *pkg.SizeLimiter

    // fieldCount is the number of fields, i.e. the number of types in this oneof.
    fieldCount uint
    // Number of bits needed to encode the type (including None type).
    typeBitCount uint

    // Field encoders.
    {{- range .Fields }}
    {{.name}}Encoder {{if not .IsPrimitive}}*{{end}}{{ .Type.EncoderType }}Encoder
    {{if not .IsPrimitive}}is{{.Name}}Recursive bool // Indicates {{.Name}} field's type is recursive.
    {{end}}
    {{- end }}
    {{- if .DictName}}
	dict *{{ .StructName }}EncoderDict
	{{- end}}
}

{{if .DictName}}
type {{ .StructName }}Entry struct {
	refNum uint64
	val  *{{ .StructName }}
}

// {{ .StructName }}EncoderDict is the dictionary used by {{ .StructName }}Encoder
type {{ .StructName }}EncoderDict struct {
	dict b.Tree[*{{ .StructName }}, {{ .StructName }}Entry]
	limiter *pkg.SizeLimiter
}

func (d* {{ .StructName }}EncoderDict) Init(limiter *pkg.SizeLimiter) {
    d.dict = *b.TreeNew[*{{ .StructName }}, {{ .StructName }}Entry](Cmp{{.StructName}})
    d.dict.Set(nil, {{ .StructName }}Entry{}) // nil {{ .StructName }} is RefNum 0
    d.limiter = limiter
}

func (d* {{ .StructName }}EncoderDict) Reset() {
    d.dict.Clear()
    d.dict.Set(nil, {{ .StructName }}Entry{}) // nil {{ .StructName }} is RefNum 0
}
{{end}}

func (e *{{ .StructName }}Encoder) Init(state* WriterState, columns *pkg.WriteColumnSet) error {
    // Remember this encoder in the state so that we can detect recursion.
    if state.{{.StructName}}Encoder != nil {
        panic("cannot initialize {{ .StructName }}Encoder: already initialized")
    }
    state.{{.StructName}}Encoder = e
    defer func() { state.{{.StructName}}Encoder = nil }()

	e.limiter = &state.limiter
    {{- if .DictName}}
	e.dict = &state.{{.DictName}}
    {{end}}

    var err error
    e.fieldCount, err = state.StructFieldCounts.{{.StructName}}FieldCount()
    if err != nil {
        return fmt.Errorf("cannot find struct %s in override schema: %w", {{printf "%q" .StructName}}, err)
    }
    e.typeBitCount = uint(bits.Len64(uint64(e.fieldCount)+1))

    {{ range $i, $e := .Fields }}
    // Init encoder for {{.Name}} field.
    if e.fieldCount <= {{$i}} {
        // {{.Name}} and all subsequent fields are skipped.
        return nil
    }
    {{- if .IsPrimitive}}
        {{- if .Type.DictName}}
        err = e.{{.name}}Encoder.Init(&state.{{.Type.DictName}}, e.limiter, columns.AddSubColumn())
        {{- else}}
        err = e.{{.name}}Encoder.Init(e.limiter, columns.AddSubColumn())
        {{- end}}
    {{- else}}
    if state.{{.Type.EncoderType}}Encoder != nil {
        // Recursion detected, use the existing encoder.
        e.{{.name}}Encoder = state.{{.Type.EncoderType}}Encoder
        e.is{{.Name}}Recursive = true
    } else {
        e.{{.name}}Encoder = new({{.Type.EncoderType}}Encoder)
        err = e.{{.name}}Encoder.Init(state, columns.AddSubColumn())
    }
    {{- end}}
    if err != nil {
        return err
    }
    {{end}}
    return nil
}

func (e *{{ .StructName }}Encoder) Reset() {
    {{ range $i, $e := .Fields }}
    if e.fieldCount <= {{$i}} {
        return // {{.Name}} and all subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !e.is{{.Name}}Recursive {
        e.{{.name}}Encoder.Reset()
    }
    {{else}}e.{{.name}}Encoder.Reset(){{end}}
    {{- end}}
}

// Encode encodes val into buf
func (e *{{ .StructName }}Encoder) Encode(val *{{ .StructName }}) {
    typ := val.typ
    if uint(typ) > e.fieldCount {
        // The current field type is not supported in target schema. Encode the type as None.
        typ = {{ $.StructName }}TypeNone
    }

	e.buf.WriteBits(uint64(typ), e.typeBitCount)

    // Account written bits in the limiter.
    e.limiter.AddFrameBits(e.typeBitCount)

    // Encode currently selected field.
	switch typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        // Encode {{.Name}}
        e.{{.name}}Encoder.Encode({{- if .Type.Flags.TakePtr}}&{{end}}val.{{.name}})
    {{- end }}
    }
}

// CollectColumns collects all buffers from all encoders into buf.
func (e *{{ .StructName }}Encoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
    columnSet.SetBits(&e.buf)
    {{- if len .Fields }}
    colIdx := 0
    {{- end }}
    {{ range $i,$e := .Fields }}
    // Collect {{.Name}} field.
    if e.fieldCount <= {{$i}} {
        return // {{.Name}} and subsequent fields are skipped.
    }
    {{if not .IsPrimitive -}}
    if !e.is{{.Name}}Recursive {
        e.{{.name}}Encoder.CollectColumns(columnSet.At(colIdx))
        colIdx++
    }
    {{else}}
    e.{{.name}}Encoder.CollectColumns(columnSet.At(colIdx))
    colIdx++
    {{end -}}
    {{end -}}
}

// {{ .StructName }}Decoder implements decoding of {{ .StructName }}
type {{ .StructName }}Decoder struct {
    buf pkg.BitsReader
    column *pkg.ReadableColumn
    lastValPtr *{{.StructName}}
    lastVal {{.StructName}}

    // fieldCount is the number of fields, i.e. the number of types in this oneof.
    fieldCount uint
    // Number of bits needed to encode the type (including None type).
    typeBitCount uint

    // Field decoders.
    {{range .Fields}}
    {{.name}}Decoder {{if not .IsPrimitive}}*{{end}}{{ .Type.EncoderType }}Decoder
    {{if not .IsPrimitive}}is{{.Name}}Recursive bool
    {{end}}
    {{- end }}
    {{if .DictName}}
    dict *{{ .StructName }}DecoderDict
    {{end}}
    allocators *Allocators
}

// Init is called once in the lifetime of the stream.
func (d *{{ .StructName }}Decoder) Init(state* ReaderState, columns *pkg.ReadColumnSet) error {
    // Remember this decoder in the state so that we can detect recursion.
    if state.{{.StructName}}Decoder != nil {
        panic("cannot initialize {{ .StructName }}Decoder: already initialized")
    }
    state.{{.StructName}}Decoder = d
    defer func() { state.{{.StructName}}Decoder = nil }()

    d.allocators = &state.Allocators

    var err error
    d.fieldCount, err = state.StructFieldCounts.{{.StructName}}FieldCount()
    if err != nil {
        return fmt.Errorf("cannot find struct %s in override schema: %w", {{printf "%q" .StructName}}, err)
    }
    if d.fieldCount > {{len .Fields}} {
        return pkg.ErrTooManyFieldsToDecode
    }

    d.column = columns.Column()

    {{if .IsMainStruct}}
    d.lastVal.Init()
	{{else}}
    d.lastVal.init(nil,0)
    {{- end}}
    d.lastValPtr = &d.lastVal

    d.typeBitCount = uint(bits.Len64(uint64(d.fieldCount)+1))

    {{- range $i,$e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return nil // {{.Name}} and subsequent fields are skipped.
    }
    {{- if .Type.IsPrimitive}}
        {{- if .Type.DictName}}
        err = d.{{.name}}Decoder.Init(&state.{{.Type.DictName}}, columns.AddSubColumn())
        {{- else}}
        err = d.{{.name}}Decoder.Init(columns.AddSubColumn())
        {{- end}}
    {{- else}}
    if state.{{.Type.EncoderType}}Decoder != nil {
        // Recursion detected, use the existing decoder.
        d.{{.name}}Decoder = state.{{.Type.EncoderType}}Decoder
        d.is{{.Name}}Recursive = true // Mark that we are using a recursive decoder.
    } else {
        d.{{.name}}Decoder = new({{.Type.EncoderType}}Decoder)
        err = d.{{.name}}Decoder.Init(state, columns.AddSubColumn())
    }
    {{- end}}
    if err != nil {
        return err
    }
    {{- end }}

    {{- if .DictName}}
    d.dict = &state.{{.DictName}}
    {{- end}}

    return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *{{ .StructName }}Decoder) Continue() {
    d.buf.Reset(d.column.Data())

    {{ range $i,$e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return // {{.Name}} and subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !d.is{{.Name}}Recursive {
        d.{{.name}}Decoder.Continue()
    }
    {{else}}d.{{.name}}Decoder.Continue(){{end}}
    {{end }}
}

func (d *{{ .StructName }}Decoder) Reset() {
    {{ range $i, $e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return // {{.Name}} and all subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !d.is{{.Name}}Recursive {
        d.{{.name}}Decoder.Reset()
    }
    {{else}}d.{{.name}}Decoder.Reset(){{end}}
    {{- end}}
}

func (d *{{ .StructName }}Decoder) Decode(dstPtr {{if.DictName}}*{{end}}*{{.StructName}}) error {
	// Read the type and validate it
	typ := uint(d.buf.ReadBits(d.typeBitCount))
	if typ >= uint(d.fieldCount+1) {
		return pkg.ErrInvalidOneOfType
    }
    if err := d.buf.Error(); err != nil {
        return err
    }

	dst := dstPtr
	if dst.typ != {{.StructName}}Type(typ) {
	    dst.typ = {{.StructName}}Type(typ)
	    // The type changed, we need to reset the contained value so that
	    // it does not contain carry-over data from a previous record that
	    // was of this same type.
	    dst.resetContained()
	}

	// Decode selected field
	switch dst.typ {
    {{- range .Fields }}
    case {{ $.StructName }}Type{{.Name}}:
        // Decode {{.Name}}
        {{- if .Type.Flags.StoreByPtr}}
        if dst.{{.name}} == nil {
            if err := d.allocators.allocSizeChecker.PrepAllocSize(uint(unsafe.Sizeof(*dst.{{.name}}))); err != nil {
                return err
            }
            dst.{{.name}} = d.allocators.{{ .Type.Storage }}.Alloc()
            dst.{{.name}}.init(dst.parentModifiedFields, dst.parentModifiedBit)
        }
        {{end}}
        {{ $isDictPtr := and .Type.Flags.StoreByPtr .Type.DictName -}}
        {{if $isDictPtr}}err := {{else}}return {{end}}d.{{.name}}Decoder.Decode({{if .Type.Flags.DecodeByPtr}}&{{end}}dst.{{.name}})
        {{- if $isDictPtr}}
        if err != nil {
            return err
        }
        if dst.{{.name}} == nil {
            return pkg.ErrDecodeError // This may happen with dict-encoded fields, with invalid input data.
        }
        {{- end}}
    {{- end }}
    }
	return nil
}

{{if .DictName}}
// {{ .StructName }}DecoderDict is the dictionary used by {{ .StructName }}Decoder
type {{ .StructName }}DecoderDict struct {
    dict []*{{.StructName}}
}

func (d* {{ .StructName }}DecoderDict) Init() {
    d.dict = d.dict[:0]
    d.dict = append(d.dict, nil) // nil {{.StructName}} is RefNum 0
}
{{end}}

// {{.StructName}}Allocator implements a custom allocator for {{.StructName}}.
// It maintains a pool of pre-allocated {{.StructName}} and grows the pool
// dynamically as needed, up to a maximum size of 64 elements.
type {{.StructName}}Allocator struct {
    pool []{{.StructName}}
    ofs int
}

// Alloc returns the next available {{.StructName}} from the pool.
// If the pool is exhausted, it grows the pool by doubling its size
// up to a maximum of 64 elements.
func (a *{{.StructName}}Allocator) Alloc() *{{.StructName}} {
    if a.ofs < len(a.pool) {
        // Get the next available {{.StructName}} from the pool
        a.ofs++
        return &a.pool[a.ofs-1]
    }
    // We've exhausted the current pool, prealloc a new pool.
    return a.prealloc()
}

//go:noinline
func (a *{{.StructName}}Allocator) prealloc() *{{.StructName}} {
    // prealloc expands the pool by doubling its size, up to a maximum of 64 elements.
    // If the pool is empty, it starts with 1 element.
    newLen := min(max(len(a.pool)*2, 1), 64)
    a.pool = make([]{{.StructName}}, newLen)
    a.ofs = 1
    return &a.pool[0]
}
