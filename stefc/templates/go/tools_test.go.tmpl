package {{ .PackageName }}

// Additional tooling used for example by interop tests.

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"math/rand/v2"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strconv"
	"testing"
	"time"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/idl"
	"github.com/splunk/stef/go/pkg/schema"
)

var generateFlag = flag.Bool("generate", false, "stef -generate -root=structname -out=filename [-seed=seed] [-records=n] [-withschema]")

var rootFlag = flag.String("root", "", "root struct name")
var seedFlag = flag.Uint64("seed", 0, "non-zero seed for random number generation (optional, default is current time)")
var countFlag = flag.Uint64("records", 1000, "number of records to generate (default is 1000)")
var outFlag = flag.String("out", "", "output file name for the generated data")
var schemaFlag = flag.Bool("withschema", false, "to force specifying schema in the output file")

var diffFlag = flag.Bool("diff", false, "stef -diff -root=structname file1 file2")
var copyFlag = flag.Bool("copy", false, "stef -copy -root=structname input-file output-file")
var compatFlag = flag.Bool("compat", false, "stef -compat -root=structname [-seed=seed] [-records=n]")

func TestTool(t *testing.T) {
	// This test can be invoked via command line to generate data, compare files, or copy data.
	// To invoke it, use: go test -run TestTool <additional flags>
	// The <additional flags> are parsed as command line flags. See usage for each flags above.

	if *generateFlag {
		if *rootFlag == "" || *outFlag == "" {
			fmt.Println("Error: -root and -out flags are required for generation.")
			flag.Usage()
			t.Fail()
		}
		err := generateData(*rootFlag, *outFlag, *seedFlag, *countFlag, *schemaFlag)
		if err != nil {
			fmt.Println(err)
			t.Fail()
		}
		return
	}

	if *diffFlag {
		if len(flag.Args()) != 2 {
			fmt.Println("Error: -diff requires exactly two file arguments.")
			flag.Usage()
			t.Fail()
		}
		if *rootFlag == "" {
			fmt.Println("Error: -root flag is required for diff.")
			flag.Usage()
			t.Fail()
		}
		file1 := flag.Args()[0]
		file2 := flag.Args()[1]

		err := diffData(*rootFlag, file1, file2)
		if err != nil {
			fmt.Println(err)
			t.Fail()
		}
		return
	}

	if *copyFlag {
		if len(flag.Args()) != 2 {
			fmt.Println("Error: -copy requires exactly two file arguments.")
			flag.Usage()
			t.Fail()
		}
		if *rootFlag == "" {
			fmt.Println("Error: -root flag is required for copy.")
			flag.Usage()
			t.Fail()
		}
		file1 := flag.Args()[0]
		file2 := flag.Args()[1]

		err := copyData(*rootFlag, file1, file2, *schemaFlag)
		if err != nil {
			fmt.Println(err)
			t.Fail()
		}
		return
	}

	if *compatFlag {
		if *rootFlag == "" {
			fmt.Println("Error: -root flag is required for compat.")
			flag.Usage()
			t.Fail()
		}

		err := verifyCompat(*rootFlag, *seedFlag, *countFlag)
		if err != nil {
			fmt.Println(err)
			t.Fail()
		}
		return
	}

	fmt.Println("Use -generate, -diff, or -copy flags to run this tool.")
}

// diffData compares two STEF files containing records of the specified root struct.
func diffData(rootStruct, fname1, fname2 string) error {
	file1, err := os.Open(fname1)
	if err != nil {
		return fmt.Errorf("Cannot open %s: %v", fname1, err)
	}
	file2, err := os.Open(fname2)
	if err != nil {
		return fmt.Errorf("Cannot open %s: %v", fname2, err)
	}

	switch rootStruct {
{{ range $i, $StructName := .RootStructs }}
	case "{{$StructName}}":
		reader1, err := New{{$StructName}}Reader(file1)
		if err != nil {
			return fmt.Errorf("Cannot open %s: %v", fname1, err)
		}

		reader2, err := New{{$StructName}}Reader(file2)
		if err != nil {
			return fmt.Errorf("Cannot open %s: %v", fname1, err)
		}

		for {
			var err1 error
			if err1 = reader1.Read(pkg.ReadOptions{}); err1 != nil {
				if err1 != io.EOF {
					return err1
				}
			}

			var err2 error
			if err2 = reader2.Read(pkg.ReadOptions{}); err2 != nil {
				if err2 != io.EOF {
					return err2
				}
			}

			if errors.Is(err1, io.EOF) {
				if errors.Is(err2, io.EOF) {
					break
				}
				return fmt.Errorf("%s has more records than %s", fname2, fname1)
			}
			if errors.Is(err2, io.EOF) {
				return fmt.Errorf("%s has more records than %s", fname1, fname2)
			}

			if !reader1.Record.IsEqual(&reader2.Record) {
				return fmt.Errorf("Record #%d differs.", reader1.RecordCount())
			}
		}

		fmt.Printf("%d records compared. Content is identical.\n", reader1.RecordCount())
		return nil
{{end}}
	default:
		return fmt.Errorf("Unsupported root struct: %s", rootStruct)
	}
}

// copyData copies records from one STEF file to another for the specified root struct.
func copyData(rootStruct, sourceFname, destFname string, includeSchema bool) (retErr error) {
	fmt.Printf("Copying content from %s to %s...\n", sourceFname, destFname)

	// Open source file for reading
	sourceFile, err := os.Open(sourceFname)
	if err != nil {
		return fmt.Errorf("Cannot open source file %s: %v", sourceFname, err)
	}
	defer sourceFile.Close()

	// Create destination file for writing
	destFile, err := os.Create(destFname)
	if err != nil {
		return fmt.Errorf("Cannot create destination file %s: %v", destFname, err)
	}
	defer func(destFile *os.File) {
		err := destFile.Close()
		if err != nil {
			retErr = err
		}
	}(destFile)

	dst := pkg.NewWrapChunkWriter(destFile)

	switch rootStruct {
{{ range $i, $StructName := .RootStructs }}
	case "{{$StructName}}":
		reader, err := New{{$StructName}}Reader(sourceFile)
		if err != nil {
			return fmt.Errorf("Cannot create reader for %s: %v", sourceFname, err)
		}
		opts := pkg.WriterOptions{}
		if includeSchema {
		    // Include the schema from the source file in the copy.
			opts.Schema = reader.Schema()
			opts.IncludeDescriptor = true
		}

		writer, err := New{{$StructName}}Writer(dst, opts)
		if err != nil {
			return fmt.Errorf("Cannot create writer for %s: %v", destFname, err)
		}

		recordCount := uint64(0)
		for {
			err := reader.Read(pkg.ReadOptions{})
			if err != nil {
				if errors.Is(err, io.EOF) {
					break
				}
				return fmt.Errorf("Error reading record %d: %v", recordCount, err)
			}

			// Copy the record from reader to writer
			writer.Record.CopyFrom(&reader.Record)
			err = writer.Write()
			if err != nil {
				return fmt.Errorf("Error writing record %d: %v", recordCount, err)
			}
			recordCount++
		}

		err = writer.Flush()
		if err != nil {
			return fmt.Errorf("Error flushing writer: %v", err)
		}

		fmt.Printf("Successfully copied %d records.\n", recordCount)
		return nil
{{end}}
	default:
		return fmt.Errorf("Unsupported root struct: %s", rootStruct)
	}
}

// generateData generates random records of the specified root struct and writes them to the output file.
func generateData(rootStruct, outFileName string, randSeed uint64, recordCount uint64, specifySchema bool) (retErr error) {
	fmt.Printf("Generating %d random %s records...\n", recordCount, rootStruct)

	outFile, err := os.Create(outFileName)
	if err != nil {
		return err
	}
	defer func(outFile *os.File) {
		err := outFile.Close()
		if err != nil {
			retErr = err
		}
	}(outFile)
	dst := pkg.NewWrapChunkWriter(outFile)

	switch rootStruct {
{{ range $i, $StructName := .RootStructs }}
	case "{{$StructName}}":
		schem, err := idl.Parse([]byte(allSchemaContent), "")
		if err != nil {
			return fmt.Errorf("Error loading schema: %v", err)
		}

		if randSeed == 0 {
			randSeed = uint64(time.Now().UnixNano())
		}
		fmt.Printf("Using random seed: %d\n", randSeed)
		random := rand.New(rand.NewPCG(randSeed, 0))

		opts := pkg.WriterOptions{}
		if specifySchema || random.IntN(2) == 0 {
		    // Specify the schema in the writer.
			if random.IntN(2) == 0 { // Randomly shrink the schema.
				// This is to test that the writer/reader can handle schema changes.
				schema.ShrinkRandomly(random, schem)
			}

			wireSchema := schema.NewWireSchema(schem, "{{$StructName}}")
			opts.Schema = &wireSchema
		}

		if random.IntN(2) == 0 { // Approx half of the times use compression and frame restarts.
			opts.FrameRestartFlags = pkg.RestartDictionaries | pkg.RestartCodecs | pkg.RestartCompression
			opts.Compression = pkg.CompressionZstd
		}

		writer, err := New{{$StructName}}Writer(dst, opts)
		if err != nil {
			return err
		}

		for i := uint64(0); i < recordCount; i++ {
    		limiter := &mutateRandomLimiter{}
			writer.Record.mutateRandom(random, schem, limiter)
			err = writer.Write()
			if err != nil {
				return fmt.Errorf("Error writing record %d: %v", i, err)
			}
		}

		err = writer.Flush()
		if err != nil {
			return fmt.Errorf("Error writing file: %v", err)
		}
		return nil
{{end}}
	default:
		return fmt.Errorf("Unsupported root struct: %s", rootStruct)
	}
}

func runGoTestTool(inDir string, args []string) error {
	args = append([]string{"test", "-v", "-run=TestTool"}, args...)
	cmd := exec.Command("go", args...)
    var err error
    cmd.Dir, err = filepath.Abs(inDir)
    if err != nil {
        return err
    }

    stdoutStderr, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Printf("%s\n", stdoutStderr)
        return fmt.Errorf("go test command failed: %v", err)
    }
    return nil
}

func verifyCompat(rootStruct string, randSeed uint64, recordCount uint64) (retErr error) {
    fmt.Printf("Verifying backward compatibility for %s...\n", rootStruct)

    if randSeed == 0 {
        randSeed = uint64(time.Now().UnixNano())
    }
    fmt.Printf("Using random seed: %d\n", randSeed)

	switch rootStruct {
{{ range $i, $StructName := .RootStructs }}
	case "{{$StructName}}":
		dataDir, err := filepath.Abs("tempdata")
		if err != nil {
			return err
		}
		if err := os.MkdirAll(dataDir, 0755); err!=nil {
			return err
		}

		sourceFile := path.Join(dataDir, "gen_by_shrunk_MainRoot.stef")
		copiedFile := path.Join(dataDir, "copied_from_shrunk_MainRoot.stef")

        // Generate data using shrunk schema
        shrunkPkgDir := "../shrunk/{{ $.PackageName }}"
        err = runGoTestTool(shrunkPkgDir, []string{
            "-generate",
            "-root="+rootStruct,
            "-seed="+strconv.FormatUint(randSeed, 10),
            "-records="+strconv.FormatUint(recordCount, 10),
            "-out="+sourceFile,
            "-withschema", // Make sure schema is specified in generated file.
        })
        if err!=nil {
            return err
        }

        // Copy using current schema
        if err := copyData(rootStruct, sourceFile, copiedFile, true); err!=nil {
            return err
        }

        // Diff using shrunk schema
        err = runGoTestTool(shrunkPkgDir, []string{
            "-diff",
            "-root="+rootStruct,
            sourceFile, copiedFile,
        })
        if err!=nil {
            return err
        }

		return nil
{{end}}
	default:
		return fmt.Errorf("Unsupported root struct: %s", rootStruct)
	}
}

{{ range $i, $StructName := .RootStructs }}
func Test{{$StructName}}BackwardCompatiblity(t *testing.T) {
    if os.Getenv("STEF_ENABLE_SLOW_TESTS") != "1" {
        t.Skip("Skipping slow test. Set STEF_ENABLE_SLOW_TESTS=1 to enable.")
    }
    verifyCompat("{{$StructName}}", 0, 10000)
}
{{end}}
