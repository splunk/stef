package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/splunk/stef/go/pkg/schema"

	"github.com/splunk/stef/stefgen/templates"
)

// Lang is the target language for code generation.
type Lang string

const (
	LangGo   Lang = "go"
	LangJava Lang = "java"
)

type Generator struct {
	Lang Lang

	// OutputDir is the output directory for generated files.
	OutputDir string

	// TestOutputDir is the output directory for generated test files.
	// If unspecified, it defaults to OutputDir.
	TestOutputDir string

	// TODO: refactor Generator to avoid needing both SchemaContent and parsed schema as input.
	SchemaContent []byte

	// Buffer to accumulated generated file.
	outBuf  *bytes.Buffer
	lastErr error

	schema         *schema.Schema
	compiledSchema *genSchema

	fileName string

	// Set to true to generate additional testing tools contained in "tools*" templates.
	genTools bool
}

func (g *Generator) GenFile(schema *schema.Schema) error {
	var err error
	g.OutputDir, err = filepath.Abs(g.OutputDir)
	if err != nil {
		return err
	}

	g.compiledSchema, err = g.compileSchema(schema)
	if err != nil {
		return err
	}

	g.schema = schema

	if err := g.oTemplates(
		"modifiedfields", g.stefSymbol2FileName("ModifiedFields"), make(map[string]any),
	); err != nil {
		return err
	}

	if err := g.oStructs(); err != nil {
		return err
	}

	if err := g.oMultimaps(); err != nil {
		return err
	}

	if err := g.oArrays(); err != nil {
		return err
	}

	if err := g.oReaderWriterState(); err != nil {
		return err
	}

	if err := g.oEnums(); err != nil {
		return err
	}

	if err := g.oWriters(); err != nil {
		return err
	}

	if err := g.oReaders(); err != nil {
		return err
	}

	if err := g.oTools(); err != nil {
		return err
	}

	if err := g.oCommon(); err != nil {
		return err
	}

	return g.lastErr
}

func (g *Generator) formatAndWriteToFile() error {
	baseFileName := path.Base(strings.TrimSuffix(g.fileName, path.Ext(g.fileName)))
	isTest := strings.HasSuffix(baseFileName, "Test")

	destFileName := baseFileName + "." + string(g.Lang)

	destDir := g.OutputDir
	if isTest && g.TestOutputDir != "" {
		destDir = g.TestOutputDir
	}

	switch g.Lang {
	case LangGo:
		packageName := g.compiledSchema.PackageName[len(g.compiledSchema.PackageName)-1]
		destDir = path.Join(destDir, packageName)
	case LangJava:
		destDir = path.Join(destDir, path.Join(g.compiledSchema.PackageName...))
	}

	destFileName = path.Join(destDir, destFileName)
	//destDir := path.Dir(destFileName)

	if err := os.MkdirAll(destDir, 0700); err != nil {
		return err
	}

	var err error
	f, err := os.Create(destFileName)
	if err != nil {
		return err
	}

	// Nicely format the generated Go code.
	goCode, err := format.Source(g.outBuf.Bytes())
	if err != nil {
		// Write unformatted code to have something to look at.
		_, err := f.Write(g.outBuf.Bytes())
		if err != nil {
			return err
		}
		// But still return an error.
		return err
	}

	_, err = f.Write(goCode)
	return err
}

func (g *Generator) oStartFile(fileName string) error {
	g.fileName = fileName
	fmt.Printf("Generating %s\n", fileName)
	g.outBuf = bytes.NewBuffer(nil)
	return g.lastErr
}

// oTemplates generates multiple files from templates with a common prefix.
func (g *Generator) oTemplates(templateNamePrefix, outputNamePrefix string, data map[string]any) error {
	templateDir := string(g.Lang)
	files, err := templates.Templates.ReadDir(templateDir)
	if err != nil {
		return fmt.Errorf("failed to read template directory %s: %w", templateDir, err)
	}
	for _, file := range files {
		if file.IsDir() {
			continue
		}

		templateFileName := file.Name()
		if !strings.HasPrefix(templateFileName, templateNamePrefix) {
			continue
		}

		templateSuffix := strings.TrimPrefix(templateFileName, templateNamePrefix)
		templateSuffix = strings.TrimSuffix(templateSuffix, path.Ext(templateSuffix))
		outputFileName := outputNamePrefix + templateSuffix

		if err := g.oTemplate(templateFileName, outputFileName, data); err != nil {
			return err
		}
	}
	return nil
}

// oTemplate generates a single file from a template.
func (g *Generator) oTemplate(templateFileName, outputFileName string, data map[string]any) error {
	data["PackageName"] = g.compiledSchema.PackageNameStr

	if err := g.oStartFile(outputFileName); err != nil {
		return err
	}

	t, err := template.ParseFS(templates.Templates, path.Join(string(g.Lang), templateFileName))
	if err != nil {
		return err
	}

	contentBuf := bytes.NewBuffer(nil)

	err = t.Lookup(templateFileName).Execute(contentBuf, data)
	if err != nil {
		return err
	}

	content := contentBuf.String()
	if content == "" {
		// No content to write, skip this file.
		return nil
	}

	content = "// Code generated by stefgen. DO NOT EDIT.\n" + content
	_, err = io.WriteString(g.outBuf, content)
	if err != nil {
		g.lastErr = err
	}

	if err := g.formatAndWriteToFile(); err != nil {
		return err
	}

	return g.lastErr
}

// Convert a generated STEF symbol to a file name.
func (g *Generator) stefSymbol2FileName(name string) string {
	switch g.Lang {
	case LangGo:
		return strings.ToLower(name)
	case LangJava:
		return name
	default:
		panic("unsupported language")
	}
}
