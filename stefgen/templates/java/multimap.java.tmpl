package {{ .PackageName }};

import net.stef.StringValue;
import net.stef.Types;

import java.util.*;
import java.util.Objects;

import static java.lang.Math.min;

// {{ .MultimapName }} is a multimap, (aka an associative array or a list) of key value
// pairs from {{.Key.Type.TypeName}} to {{.Value.Type.TypeName}}.
public class {{ .MultimapName }} {
    // The key-value pair, element of the map.
    public static class Elem {
        {{.Key.Type.Storage}} key;
        {{.Value.Type.Storage}} value;
    }

    // The list of map elements.
    // elems may be allocated more capacity than the map currently needs,
    // i.e. ony the first elemsLen elements are considered present.
    Elem[] elems = new Elem[0];

    // elemsLen is the number of elements contains in the elems, elemsLen<=elems.length.
    int elemsLen = 0;

    // The number of elements in elems that are inited, initedCount>=elemsLen.
    // initedCount may be higher than elemensLen if the map has shrunk from
    // a previous larger size.
    private int initedCount = 0;

    ModifiedFieldsMultimap modifiedElems = new ModifiedFieldsMultimap();

    public {{ .MultimapName }}() {
        init(null, 0);
    }

    {{ .MultimapName }}(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        init(parentModifiedFields, parentModifiedBit);
    }

    private void init(ModifiedFields parentModifiedFields, long parentModifiedBit) {
        modifiedElems.init(parentModifiedFields, parentModifiedBit);
    }

    // reset the multimap to its initial state, as if init() was just called.
    // Will not reset internal fields such as parentModifiedFields.
    void reset() {
        elemsLen = 0;
    }

    // clone() creates a deep copy of {{.MultimapName}}
    public {{.MultimapName}} clone() {
        {{.MultimapName}} clone = new {{.MultimapName}}();
        copy{{.MultimapName}}(clone, this);
        return clone;
    }

    // len returns the number of elements in the multimap.
    public int len() {
        return elemsLen;
    }

    // at returns element at index i.
    public Elem at(int i) {
        return elems[i];
    }

    // ensureElems ensures that elems array has at least newLen elements allocated.
    // It will grow/reallocate the array if needed.
    // elemsLen will be set to newLen.
    // This method does not call init() on new elements in the array.
    void ensureElems(int newLen) {
        if (elems.length < newLen) {
            int allocLen = Math.max(newLen, elems.length * 2);
            Elem[] newElems = new Elem[allocLen];
            System.arraycopy(elems, 0, newElems, 0, elems.length);
            elems = newElems;
        }
        elemsLen = newLen;
    }

    // ensureLen ensures the length of the array is equal to newLen.
    // It will grow or shrink the array if needed, and initialize newly added elements
    // if the element type requires initialization.
    // If the arrays grows, the newly added elements will be initialized to the
    // initial values of key and value.
    public void ensureLen(int newLen) {
        int oldLen = elemsLen;
        if (newLen == oldLen) {
            return; // No change needed.
        }

        modifiedElems.changeLen(oldLen, newLen);

        ensureElems(newLen);
        for (int i=initedCount; i < newLen; i++) {
            elems[i] = new Elem();
            {{- if .Key.Type.IsPrimitive}}
            {{if .Key.Type.InitVal}}elems[i].key = {{.Key.Type.InitVal}};{{end}}
            {{- else}}
            elems[i].key = new {{.Key.Type.Storage}}(modifiedElems.keys, modifiedElems.maskForIndex(i));
            {{- end}}
            {{- if .Value.Type.IsPrimitive}}
            {{if .Value.Type.InitVal}}elems[i].value = {{.Value.Type.InitVal}};{{end}}
            {{- else}}
            elems[i].value = new {{.Value.Type.Storage}}(modifiedElems.vals, modifiedElems.maskForIndex(i));
            {{- end}}
        }
        if (initedCount < newLen) {
            initedCount = newLen;
        }

        for (int i=min(oldLen, newLen); i < newLen; i++) {
            {{- if not .Key.Type.IsPrimitive}}
            // Reset newly created keys to initial state.
            elems[i].key.reset();
            {{- end}}
            {{- if not .Value.Type.IsPrimitive}}
            // Reset newly added values keys to initial state.
            elems[i].value.reset();
            {{- end}}
        }
    }

    void markModifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            {{- if not .Key.Type.IsPrimitive}}
            elems[i].key.markModifiedRecursively();
            {{- end}}
            {{- if not .Value.Type.IsPrimitive}}
            elems[i].value.markModifiedRecursively();
            {{- end}}
        }
        modifiedElems.markUnmodifiedAll();
    }

    void markUnmodifiedRecursively() {
        for (int i=0; i<elemsLen; i++) {
            {{- if not .Key.Type.IsPrimitive}}
            elems[i].key.markUnmodifiedRecursively();
            {{- end}}
            {{- if not .Value.Type.IsPrimitive}}
            elems[i].value.markUnmodifiedRecursively();
            {{- end}}
        }
    }

    // Append adds a key-value pair to the multimap.
    public void append({{.Key.Type.Exported}} k, {{.Value.Type.Exported}} v) {
        modifiedElems.changeLen(elemsLen, elemsLen+1);
        ensureElems(elemsLen + 1);
        Elem elem = new Elem();
        elem.key = {{.Key.Type.ToStorage "k"}};
        elem.value = {{.Value.Type.ToStorage "v"}};
        elems[elemsLen-1] = elem;
    }

    // setKey sets the key of the element at index i.
    public void setKey(int i, {{.Key.Type.Exported}} k) {
        if (!{{.Key.Type.EqualFunc}}(elems[i].key, {{.Key.Type.ToStorage "k"}})) {
            elems[i].key = {{.Key.Type.ToStorage "k"}};
            modifiedElems.markKeyModified(i);
        }
    }

    // setValue sets the value of the element at index i.
    public void setValue(int i, {{.Value.Type.Exported}} v) {
        {{- if .Value.Type.IsPrimitive }}
        if (!{{.Value.Type.EqualFunc}}(elems[i].value, {{.Value.Type.ToStorage "v"}})) {
        {{- else }}
        if (!elems[i].value.equals({{.Value.Type.ToStorage "v"}})) {
        {{- end }}
            elems[i].value = {{.Value.Type.ToStorage "v"}};
            modifiedElems.markValModified(i);
        }
    }

    // byteSize returns approximate memory usage in bytes. Used to calculate
    // memory used by dictionaries.
    public int byteSize() {
        int size = 0;
        size += this.elemsLen * 16; // TODO: estimate size of Elem objects
        return size;
    }

    // Copy all elements from src to this multimap.
    public void copyFrom({{.MultimapName}} src) {
        if (elemsLen!=src.elemsLen) {
            ensureLen(src.elemsLen);
        }
        for (int i=0; i < src.elemsLen; i++) {
        {{- if .Key.Type.IsPrimitive}}
            if (!{{.Key.Type.EqualFunc}}(elems[i].key, src.elems[i].key)) {
                elems[i].key = src.elems[i].key;
                modifiedElems.markKeyModified(i);
            }
        {{else}}
            if (!elems[i].key.equals(src.elems[i].key)) {
                copy{{.Key.Type.TypeName}}(elems[i].key, src.elems[i].key);
                modifiedElems.markKeyModified(i);
            }
        {{end}}

        {{- if .Value.Type.IsPrimitive}}
            if (!{{.Value.Type.EqualFunc}}(elems[i].value, src.elems[i].value)) {
                elems[i].value = src.elems[i].value;
                modifiedElems.markValModified(i);
            }
        {{else}}
            if (!elems[i].value.equals(src.elems[i].value)) {
                elems[i].value.copyFrom(src.elems[i].value);
                modifiedElems.markValModified(i);
            }
        {{- end}}
        }
    }

    // areKeysModified returns true if any key in the multimap was modified
    // since the modified flags were last cleared.
    boolean areKeysModified() {
    	return modifiedElems.areKeysModified();
    }

    // equals performs deep comparison and returns true if this multimap is equal to val.
    public boolean equals({{.MultimapName}} val) {
        if (elemsLen != val.elemsLen) {
            return false;
        }
        for (int i = 0; i<elemsLen; i++) {
        {{- if .Key.Type.IsPrimitive }}
            if (!{{ .Key.Type.EqualFunc }}(elems[i].key,val.elems[i].key)) {
                return false;
            }
        {{- else }}
            if (!elems[i].equals(val.elems[i])) {
                return false;
            }
        {{- end}}
        {{- if .Value.Type.IsPrimitive }}
            if (!{{ .Value.Type.EqualFunc }}(elems[i].value,val.elems[i].value)) {
                return false;
            }
        {{- else }}
            if (!elems[i].value.equals(val.elems[i].value)) {
                return false;
            }
        {{- end}}
        }
        return true;
    }

    // compare compares two multimaps lexicographically.
    public static int compare({{.MultimapName}} left, {{.MultimapName}} right) {
        int l = Math.min(left.elemsLen, right.elemsLen);
        for (int i = 0; i < l; i++) {
            int c = {{.Key.Type.CompareFunc}}(left.elems[i].key, right.elems[i].key);
            if (c != 0) return c;
        }
    
        int lenDiff = left.elemsLen - right.elemsLen;
        if (lenDiff != 0) {
            return lenDiff;
        }
    
        for (int i = 0; i < l; i++) {
            int c = {{.Value.Type.CompareFunc}}(left.elems[i].value, right.elems[i].value);
            if (c != 0) return c;
        }
        return 0;
    }

    // mutateRandom mutates fields in a random, deterministic manner using random parameter as a deterministic generator.
    void mutateRandom(Random random) {
        if (random.nextInt(20) == 0) {
            ensureLen(elemsLen + 1);
        }
        if (random.nextInt(20) == 0 && elemsLen > 0) {
            ensureLen(elemsLen - 1);
        }
        for (int i = 0; i < elemsLen; i++) {
            if (random.nextInt(4 * elemsLen) == 0) {
                {{- if not .Key.Type.IsPrimitive }}
                elems[i].key.mutateRandom(random);
                {{- else }}
                setKey(i, {{ .Key.Type.RandomFunc }});
                {{- end}}
            }
            if (random.nextInt(4 * elemsLen) == 0) {
                {{- if not .Value.Type.IsPrimitive }}
                elems[i].value.mutateRandom(random);
                {{- else }}
                setValue(i, {{ .Value.Type.RandomFunc }});
                {{- end}}
            }
        }
    }

    // Helper for copying multimaps
    public static void copy{{.MultimapName}}({{.MultimapName}} dst, {{.MultimapName}} src) {
        dst.copyFrom(src);
    }
}
