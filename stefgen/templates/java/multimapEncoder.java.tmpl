package {{ .PackageName }};

import net.stef.BytesWriter;
import net.stef.SizeLimiter;
import net.stef.Types;
import net.stef.WriteColumnSet;
import net.stef.codecs.*;

import java.io.IOException;

// Encoder for {{ .MultimapName }}
class {{ .MultimapName }}Encoder {
    private final BytesWriter buf = new BytesWriter(0);
    private WriteColumnSet columns;
    private SizeLimiter limiter;

    private {{.Key.Type.EncoderType}}Encoder keyEncoder;
    private {{.Value.Type.EncoderType}}Encoder valueEncoder;
    private boolean isKeyRecursive = false;
    private boolean isValueRecursive = false;

    public void init(WriterState state, WriteColumnSet columns) throws IOException {
        // Remember this encoder in the state so that we can detect recursion.
        if (state.{{ .MultimapName }}Encoder != null) {
            throw new IllegalStateException("cannot initialize {{ .MultimapName }}Encoder: already initialized");
        }
        state.{{ .MultimapName }}Encoder = this;
        try {
            this.limiter = state.getLimiter();

            {{- if .Key.Type.IsPrimitive}}
            keyEncoder = new {{.Key.Type.EncoderType}}Encoder();
            keyEncoder.init({{if .Key.Type.DictName}}state.{{.Key.Type.DictName}}, {{end}}limiter, columns.addSubColumn());
            {{- else}}
            if (state.{{.Key.Type.EncoderType}}Encoder != null) {
                // Recursion detected, use the existing encoder.
                keyEncoder = state.{{.Key.Type.EncoderType}}Encoder;
                isKeyRecursive = true;
            } else {
                keyEncoder = new({{.Key.Type.EncoderType}}Encoder);
                keyEncoder.init(state, columns.addSubColumn());
            }
            {{- end}}
            {{- if .Value.Type.IsPrimitive}}
            valueEncoder = new {{.Value.Type.EncoderType}}Encoder();
            valueEncoder.init({{if .Value.Type.DictName}}state.{{.Value.Type.DictName}}, {{end}}limiter, columns.addSubColumn());
            {{- else}}
            if (state.{{.Value.Type.EncoderType}}Encoder != null) {
                // Recursion detected, use the existing encoder.
                valueEncoder = state.{{.Value.Type.EncoderType}}Encoder;
                isValueRecursive = true;
            } else {
                valueEncoder = new {{.Value.Type.EncoderType}}Encoder();
                valueEncoder.init(state, columns.addSubColumn());
            }
            {{- end}}
        } finally {
            state.{{ .MultimapName }}Encoder = null;
        }
    }

    public void reset() {
        if (!isKeyRecursive) {
            keyEncoder.reset();
        }
        if (!isValueRecursive) {
            valueEncoder.reset();
        }
    }

    public void encode({{ .MultimapName }} list) throws IOException {
        int oldLen = buf.size();

        if (list.elemsLen == 0) {
            // Zero-length attr list.
            buf.writeUvarint(0b1);

            limiter.addFrameBytes(buf.size() - oldLen);

            return;
        }

        if (!list.areKeysModified() && list.elemsLen < 63) {
            encodeValuesOnly(list);
        } else {
            encodeFull(list);
        }

        limiter.addFrameBytes(buf.size() - oldLen);

        // Mark all elems non-modified so that next Encode() correctly
        // encodes only elems that change after this.
        list.modifiedElems.markUnmodifiedAll();
    }

    private void encodeValuesOnly({{ .MultimapName }} list) throws IOException {
        if (list.elemsLen > 62) {
            throw new UnsupportedOperationException("Not implemented for >62 elements");
        }

        // The bits that describe the change value are exactly the bits
       	// that are set in modifiedElems.
        long changedValuesBits = list.modifiedElems.vals.mask;

        // Record changedValuesBits (LSB is 0 to indicate values-only encoding).
        buf.writeUvarint(changedValuesBits << 1);

        // Encode changed values only.
        long bitToEncode = 1L;
        for (int i = 0; i < list.elemsLen; i++) {
            if ((bitToEncode & changedValuesBits) != 0) {
                valueEncoder.encode(list.elems[i].value);
            }
            bitToEncode <<= 1;
        }
    }

    private void encodeFull({{ .MultimapName }} list) throws IOException {
        // Record multimap len (LSB is 1 to indicate full encoding).
        buf.writeUvarint(((long)list.elemsLen << 1) | 0b1);

    	// Encode keys and values.
        for (int i = 0; i < list.elemsLen; i++) {
            keyEncoder.encode(list.elems[i].key);
            valueEncoder.encode(list.elems[i].value);
        }
    }

    public void collectColumns(WriteColumnSet columnSet) {
        columnSet.setBytes(buf);
        if (!isKeyRecursive) {
            keyEncoder.collectColumns(columnSet.at(0));
        }
        if (!isValueRecursive) {
            valueEncoder.collectColumns(columnSet.at(1));
        }
    }
}

