package {{ .PackageName }}

import (
    "bytes"
    "fmt"
    "math/rand/v2"
    "strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
    "github.com/splunk/stef/go/pkg/schema"
)

var _ = strings.Compare
var _ = encoders.StringEncoder{}
var _ = schema.WireSchema{}
var _ = bytes.NewBuffer

type {{ .StructName }} struct {
    {{ range .Fields }}
    {{.name}} {{if .Type.Flags.StoreByPtr}}*{{end}}{{ .Type.Storage }}
    {{- end }}

    // modifiedFields keeps track of which fields are modified.
    modifiedFields modifiedFields
	{{- if .OptionalFieldCount}}

    // Field presence bits.
    // Fields which are present have the corresponding bit set, see fieldPresent{{ $.StructName }}* consts below.
	optionalFieldsPresent uint64
	{{- end}}
}

const {{ .StructName }}StructName = "{{ .StructName }}"

// Bitmasks for "modified" flags for each field.
const (
    {{ range .Fields }}
	fieldModified{{ $.StructName }}{{.Name}}{{ .ConstModifier }}
    {{- end }}
)

{{if .OptionalFieldCount}}
// Bitmasks for "present" flags for optional fields.
const (
    {{ range .Fields }}
	{{- if .Optional}}
    fieldPresent{{ $.StructName }}{{.Name}}{{if not .OptionalIndex}} = uint64(1 << iota){{end}}
    {{- end }}
    {{- end }}
)
{{end}}

// Init must be called once, before the {{.StructName }} is used.
func (s *{{.StructName }}) Init() {
    s.init(nil, 0)
}

func New{{.StructName }}() *{{.StructName }} {
	var s {{.StructName}}
    s.init(nil, 0)
	return &s
}

func (s *{{ $.StructName }}) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
    s.modifiedFields.parent = parentModifiedFields
    s.modifiedFields.parentBit = parentModifiedBit

    {{ range .Fields }}
    {{- if not .Type.IsPrimitive }}
    {{- if .Type.Flags.StoreByPtr}}
    {{- if not .Optional}}
    s.{{.name}} = &{{ .Type.Storage }}{}
    s.{{.name}}.init(&s.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
    {{- end}}
    {{- else }}
    s.{{.name}}.init(&s.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
    {{- end }}
    {{- end -}}
    {{- end -}}
}

func (s *{{ $.StructName }}) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
    s.modifiedFields.parent = parentModifiedFields
    s.modifiedFields.parentBit = parentModifiedBit

    {{ range .Fields }}
    {{- if not .Type.IsPrimitive }}
    {{- if .Type.Flags.StoreByPtr}}
    {{- if not .Optional}}
    s.{{.name}} = allocators.{{ .Type.Storage }}.Alloc()
    s.{{.name}}.initAlloc(&s.modifiedFields, fieldModified{{ $.StructName }}{{.Name}}, allocators)
    {{- end}}
    {{- else }}
    s.{{.name}}.initAlloc(&s.modifiedFields, fieldModified{{ $.StructName }}{{.Name}}, allocators)
    {{- end }}
    {{- end -}}
    {{- end -}}
}

// reset the struct to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (s *{{ $.StructName }}) reset() {
    {{ range .Fields }}
	{{- if .Type.IsPrimitive }}
	{{if .Type.InitVal}}s.{{.name}} = {{.Type.InitVal}};{{end}}
	{{- else}}
	{{- if .Type.Flags.StoreByPtr}}
    if s.{{.name}} != nil {
        s.{{.name}}.reset()
    }
    {{- else}}
    s.{{.name}}.reset()
    {{- end -}}
    {{- end -}}
    {{- end -}}
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (s *{{ $.StructName }}) fixParent(parentModifiedFields *modifiedFields) {
    s.modifiedFields.parent = parentModifiedFields

    {{ range .Fields }}
    {{- if not .Type.IsPrimitive }}
    {{- if .Type.Flags.StoreByPtr}}
    {{- if not .Optional}}
    s.{{.name}}.fixParent(&s.modifiedFields)
    {{- end}}
    {{- else }}
    s.{{.name}}.fixParent(&s.modifiedFields)
    {{- end }}
    {{- end -}}
    {{- end -}}
}

{{ range .Fields }}
func (s *{{ $.StructName }}) {{.Name}}() {{if .Type.Flags.PassByPtr}}*{{end}}{{.Type.Exported}} {
{{- if .Type.IsPrimitive}}
	return {{.Type.ToExported (print "s." .name)}}
{{- else}}
    return {{if and .Type.Flags.PassByPtr (not .Type.Flags.StoreByPtr)}}&{{end}}s.{{.name}}
{{- end}}
}

{{if .Type.IsPrimitive}}
// Set{{.Name}} sets the value of {{.Name}} field.
func (s *{{ $.StructName }}) Set{{.Name}}(v {{.Type.Exported}}) {
    if !{{ .Type.EqualFunc }}(s.{{.name}}, {{.Type.ToStorage "v"}})
        {{- if .Optional}}|| s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}}==0{{end}} {
		s.{{.name}} = {{.Type.ToStorage "v"}}
        s.mark{{.Name}}Modified()
        {{- if .Optional}}
		s.optionalFieldsPresent |= fieldPresent{{ $.StructName }}{{.Name}}
		{{- end}}
    }
}
{{end}}

func (s *{{ $.StructName }}) mark{{.Name}}Modified() {
    s.modifiedFields.markModified(fieldModified{{ $.StructName }}{{.Name}})
}

{{ if .Optional}}
// Unset{{.Name}} unsets the precense flag of {{.Name}} field. A subsequent Has{{.Name}}() will return false.
func (s *{{ $.StructName }}) Unset{{.Name}}() {
    if s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0 {
        s.optionalFieldsPresent &= ^fieldPresent{{ $.StructName }}{{.Name}}
        s.mark{{.Name}}Modified()
    }
}

// Has{{.Name}} returns true if the presence flag {{.Name}} field is set and false if it is unset.
func (s *{{ $.StructName }}) Has{{.Name}}() bool {
    return s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
}
{{- end}}

// Is{{.Name}}Modified returns true the value of {{.Name}} field was modified since
// {{ $.StructName }} was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *{{ $.StructName }}) Is{{.Name}}Modified() bool {
    return s.modifiedFields.mask & fieldModified{{ $.StructName }}{{.Name}} != 0
}
{{ end }}

func (s *{{ $.StructName }}) markModifiedRecursively() {
    {{ range .Fields }}
    {{- if not .Type.IsPrimitive}}
    s.{{.name}}.markModifiedRecursively()
    {{- end}}
    {{ end }}
    s.modifiedFields.mask =
    {{- range .Fields }}
        fieldModified{{ $.StructName }}{{.Name}} | {{end}}0
}

func (s *{{ $.StructName }}) markUnmodifiedRecursively() {
{{ range .Fields }}
    if s.Is{{.Name}}Modified() {
        {{- if not .Type.IsPrimitive}}
        s.{{.name}}.markUnmodifiedRecursively()
        {{- end}}
    }
{{ end }}
    s.modifiedFields.mask = 0
}

func (s *{{ .StructName }}) Clone(allocators *Allocators) {{if .Type.Flags.StoreByPtr}}*{{end}}{{.StructName}} {
{{if .Type.Flags.StoreByPtr}}
    c := allocators.{{.StructName}}.Alloc()
    *c = {{.StructName}}{
{{else}}
    c := {{.StructName}}{
{{end}}
        {{ range .Fields }}{{.name}}: {{if .Type.MustClone}}s.{{.name}}.Clone(allocators){{else}}s.{{.name}}{{end}},
        {{ end }}
	}
	c.modifiedFields.hash = s.modifiedFields.hash
    return c
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (s *{{ .StructName }}) byteSize() uint {
    return uint(unsafe.Sizeof(*s))+
       {{range .Fields -}}
       {{- if .Type.MustClone}}s.{{.name}}.byteSize()+{{end}}
       {{- end }}0
}

// Copy from src to dst, overwriting existing data in dst.
func copy{{.StructName}}(dst *{{.StructName}}, src *{{.StructName}}) {
    {{- range .Fields -}}
    {{- if .Type.MustClone}}
    {{- if .Optional}}
    if src.Has{{.Name}}() != dst.Has{{.Name}}() {
        dst.mark{{.Name}}Modified()
    }
    {{- end}}
    {{- if .Type.Flags.StoreByPtr}}
    if src.{{.name}} != nil {
        if dst.{{.name}} == nil {
            dst.{{.name}} = &{{ .Type.Storage }}{}
            dst.{{.name}}.init(&dst.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
        }
    {{- end}}
        copy{{.Type.TypeName}}(
            {{- if .Type.Flags.TakePtr}}&{{end}}dst.{{.name }},
            {{- if .Type.Flags.TakePtr}}&{{end}}src.{{.name}})
    {{- if .Type.Flags.StoreByPtr}}
    }
    {{- end}}
    {{- else}}
	{{- if .Optional}}
	if src.Has{{.Name}}() {
		dst.Set{{.Name}}({{.Type.ToExported (print "src." .name)}})
	} else {
		dst.Unset{{.Name}}()
	}
	{{else}}
    dst.Set{{.Name}}({{.Type.ToExported (print "src." .name)}})
    {{- end}}
    {{- end}}
    {{- end}}
    {{- if .OptionalFieldCount}}
    dst.optionalFieldsPresent = src.optionalFieldsPresent
    {{- end}}
    if src.modifiedFields.hash != 0 {
        dst.modifiedFields.hash = src.modifiedFields.hash
    }
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNew{{.StructName}}(dst *{{.StructName}}, src *{{.StructName}}, allocators *Allocators) {
    {{- range .Fields -}}
    {{- if .Type.MustClone}}
    {{- if .Optional}}
    if src.Has{{.Name}}() {
        dst.mark{{.Name}}Modified()
    }
    {{- end}}
    {{- if .Type.Flags.StoreByPtr}}
    if src.{{.name}} != nil {
        dst.{{.name}} = allocators.{{ .Type.Storage }}.Alloc()
        dst.{{.name}}.init(&dst.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
    {{- end}}
        copyToNew{{.Type.TypeName}}(
            {{- if .Type.Flags.TakePtr}}&{{end}}dst.{{.name }},
            {{- if .Type.Flags.TakePtr}}&{{end}}src.{{.name}}, allocators)
    {{- if .Type.Flags.StoreByPtr}}
    }
    {{- end}}
    {{- else}}
	{{- if .Optional}}
	if src.Has{{.Name}}() {
		dst.Set{{.Name}}({{.Type.ToExported (print "src." .name)}})
	}
	{{else}}
    dst.{{.name}} = src.{{.name}}
    {{- end}}
    {{- end}}
    {{- end}}
    {{- if .OptionalFieldCount}}
    dst.optionalFieldsPresent = src.optionalFieldsPresent
    {{- end}}
    dst.modifiedFields.hash = src.modifiedFields.hash
}

// CopyFrom() performs a deep copy from src.
func (s* {{.StructName}}) CopyFrom(src *{{.StructName}}) {
    copy{{.StructName}}(s, src)
}

func (s* {{.StructName}}) markParentModified() {
	s.modifiedFields.parent.markModified(s.modifiedFields.parentBit)
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. Only fields that exist
// in the schem are mutated, allowing to generate data for specified schema.
func (s *{{ .StructName }}) mutateRandom(random *rand.Rand, schem *schema.Schema) {
    // Get the field count for this struct from the schema. If the schema specifies
    // fewer field count than the one we have in this code then we will not mutate
    // fields that are not in the schema.
    fieldCount, err := schem.FieldCount({{printf "%q" .StructName}})
    if err != nil {
        panic(fmt.Sprintf("cannot get field count for %s: %v", {{printf "%q" .StructName}}, err))
    }

    const randRange = max({{len .Fields}},2) // At least 2 to ensure we don't recurse infinitely if there is only 1 field.

{{ range $i, $e := .Fields }}
    if fieldCount <= {{$i}} {
        return // {{.Name}} and all subsequent fields are skipped.
    }
    // Maybe mutate {{.Name}}
    if random.IntN(randRange)==0 {
    {{- if not .Type.IsPrimitive }}
        {{- if .Optional}}
        // Flip the optional field presence bit.
        s.optionalFieldsPresent ^= fieldPresent{{ $.StructName }}{{.Name}}
        s.mark{{.Name}}Modified()
        if s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} !=0 {
            if s.{{.name}} == nil {
                s.{{.name}} = &{{ .Type.Storage }}{}
                s.{{.name}}.init(&s.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
            }
            s.{{.name}}.mutateRandom(random, schem)
        }
        {{- else}}
        s.{{.name}}.mutateRandom(random, schem)
        {{- end}}
    {{- else }}
        s.Set{{.Name}}({{.Type.RandomFunc}})
    {{- end}}
    }
{{- end }}
}

// IsEqual performs deep comparison and returns true if struct is equal to right.
func (s *{{ .StructName }}) IsEqual(right *{{ .StructName }}) bool {
    if s == nil {
        return right == nil
    }
    if s.modifiedFields.hash != 0 && right.modifiedFields.hash != 0 {
        if s.modifiedFields.hash != right.modifiedFields.hash {
            return false
        }
    }

    {{- range .Fields }}
    // Compare {{.Name}} field.
    {{- if .Optional}}
    s{{.Name}}Present := s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
    right{{.Name}}Present := right.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
    if s{{.Name}}Present != right{{.Name}}Present{
        return false
    }
    if s{{.Name}}Present { // Compare only if {{.Name}} field is present
    {{- end}}
    {{- if .Type.IsPrimitive }}
    if !{{ .Type.EqualFunc }}(s.{{.name}}, right.{{.name}}) {
        return false
    }
    {{- else }}
    if !s.{{.name}}.IsEqual({{- if .Type.Flags.TakePtr}}&{{end}}right.{{.name}}) {
        return false
    }
    {{- end }}
    {{- if .Optional}}
    }
    {{end}}
    {{- end }}

    return true
}

func {{.StructName}}Equal(left, right *{{.StructName}}) bool {
    return left.IsEqual(right)
}

func (s* {{.StructName}}) Hash() uint64 {
    if s == nil {
        return 0
    }
    if s.modifiedFields.hash != 0 {
        return s.modifiedFields.hash
    }

    hash := uint64({{.RandSeed}})
    {{- range .Fields }}
    {{- if .Optional}}
    if s.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0 {
    {{- end}}
    {{- if .Type.IsPrimitive }}
    hash ^= {{ .Type.HashFunc }}(s.{{.name}})
    {{- else }}
    hash ^= s.{{.name}}.Hash()
    {{- end }}
    {{- if .Optional}}
    }
    {{end}}
    {{- end }}
    {{- if .OptionalFieldCount}}
    hash ^= s.optionalFieldsPresent
    {{- end}}
    hash |= 1 // Make sure it is never 0
    s.modifiedFields.hash = hash
    return hash
}

// Cmp{{.StructName}} performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func Cmp{{.StructName}}(left, right *{{.StructName}}) int {
    if left == nil {
        if right == nil {
            return 0
        }
        return -1
    }
    if right == nil {
        return 1
    }
    {{ range .Fields }}
    // Compare {{.Name}} field.
    {{- if .Optional}}
    left{{.Name}}Present := left.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
    right{{.Name}}Present := right.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
    if left{{.Name}}Present != right{{.Name}}Present{
        if left{{.Name}}Present {
            return 1
        }
        return -1
    }
    {{- end}}
    if c := {{ .Type.CompareFunc }}(
            {{- if .Type.Flags.TakePtr}}&{{end}}left.{{.name}},
            {{- if .Type.Flags.TakePtr}}&{{end}}right.{{.name}}); c != 0 {
        return c
    }
    {{ end }}
    return 0
}

// {{ .StructName }}Encoder implements encoding of {{ .StructName }}
type {{ .StructName }}Encoder struct {
    buf pkg.BitsWriter
	limiter *pkg.SizeLimiter

    // forceModifiedFields is set to true if the next encoding operation
	// must write all fields, whether they are modified or no.
	// This is used after frame restarts so that the data can be decoded
	// from the frame start.
    forceModifiedFields bool

    {{ range .Fields }}
    {{.name}}Encoder {{if not .IsPrimitive}}*{{end}}{{ .Type.EncoderType }}Encoder
    {{if not .IsPrimitive}}is{{.Name}}Recursive bool // Indicates {{.Name}} field's type is recursive.
    {{end}}
    {{- end }}
    {{if .DictName}}
	dict *{{ .StructName }}EncoderDict{{end}}
    allocators *Allocators

    keepFieldMask uint64
    fieldCount uint
}

{{if .DictName}}
{{/*type {{ .StructName }}Entry struct {*/}}
{{/*	refNum uint64*/}}
{{/*}*/}}

// {{ .StructName }}EncoderDict is the dictionary used by {{ .StructName }}Encoder
type {{ .StructName }}EncoderDict struct {
	dict *pkg.HashMap[*{{ .StructName }}, uint64]
	limiter *pkg.SizeLimiter
}

func (d* {{ .StructName }}EncoderDict) Init(limiter *pkg.SizeLimiter) {
    d.dict = pkg.NewHashMap[*{{ .StructName }}, uint64]((*{{.StructName}}).Hash, {{.StructName}}Equal)
    d.dict.Set(nil, 0) // nil {{ .StructName }} is RefNum 0
    d.limiter = limiter
}

func (d* {{ .StructName }}EncoderDict) Reset() {
    d.dict.Clear()
    d.dict.Set(nil, 0) // nil {{ .StructName }} is RefNum 0
}
{{end}}

func (e *{{ .StructName }}Encoder) Init(state* WriterState, columns *pkg.WriteColumnSet) error {
    // Remember this encoder in the state so that we can detect recursion.
    if state.{{.StructName}}Encoder != nil {
        panic("cannot initialize {{ .StructName }}Encoder: already initialized")
    }
    state.{{.StructName}}Encoder = e
    defer func() { state.{{.StructName}}Encoder = nil }()

    e.limiter = &state.limiter
    {{- if .DictName}}
	e.dict = &state.{{.DictName}}
    {{- end}}
    e.allocators = &state.Allocators

    // Number of fields in the output data schema.
    var err error
    e.fieldCount, err = state.StructFieldCounts.{{.StructName}}FieldCount()
    if err != nil {
        return fmt.Errorf("cannot find struct %s in override schema: %v", {{printf "%q" .StructName}}, err)
    }
    // Set that many 1 bits in the keepFieldMask. All fields with higher number
    // will be skipped when encoding.
    e.keepFieldMask = ^(^uint64(0) << e.fieldCount)

    {{ range $i, $e := .Fields }}
    // Init encoder for {{.Name}} field.
    if e.fieldCount <= {{$i}} {
        return nil // {{.Name}} and all subsequent fields are skipped.
    }
    {{- if .IsPrimitive}}
        {{- if .Type.DictName}}
        err = e.{{.name}}Encoder.Init(&state.{{.Type.DictName}}, e.limiter, columns.AddSubColumn())
        {{- else}}
        err = e.{{.name}}Encoder.Init(e.limiter, columns.AddSubColumn())
        {{- end}}
    {{- else}}
    if state.{{.Type.EncoderType}}Encoder != nil {
        // Recursion detected, use the existing encoder.
        e.{{.name}}Encoder = state.{{.Type.EncoderType}}Encoder
        e.is{{.Name}}Recursive = true
    } else {
        e.{{.name}}Encoder = new({{.Type.EncoderType}}Encoder)
        err = e.{{.name}}Encoder.Init(state, columns.AddSubColumn())
    }
    {{- end}}
    if err != nil {
        return err
    }
    {{end}}
    return nil
}

func (e *{{ .StructName }}Encoder) Reset() {
	// Since we are resetting the state of encoder make sure the next Encode()
	// call forcedly writes all fields and does not attempt to skip.
    e.forceModifiedFields = true

    {{ range $i, $e := .Fields }}
    if e.fieldCount <= {{$i}} {
        return // {{.Name}} and all subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !e.is{{.Name}}Recursive {
        e.{{.name}}Encoder.Reset()
    }
    {{else}}e.{{.name}}Encoder.Reset(){{end}}
    {{- end}}
}

// Encode encodes val into buf
func (e *{{ .StructName }}Encoder) Encode(val *{{ .StructName }}) {
    var bitCount uint

    {{if .DictName}}// Check if the {{ .StructName }} exists in the dictionary.
	refNum, exists := e.dict.dict.Get(val)
	if exists {
        // The {{ .StructName }} exists, we will reference it.
		// Indicate a RefNum follows.
		e.buf.WriteBit(0)
		// Encode refNum.
		bitCount = e.buf.WriteUvarintCompact(refNum)

		// Account written bits in the limiter.
		e.limiter.AddFrameBits(1+bitCount)

		// Mark all fields non-modified recursively so that next Encode() correctly
		// encodes only fields that change after this.
        val.markUnmodifiedRecursively()
		return
	}

	// The {{ .StructName }} does not exist in the dictionary. Add it to the dictionary.
	valInDict := val.Clone(e.allocators)
	refNum = uint64(e.dict.dict.Len())
	e.dict.dict.Set(valInDict, refNum)
    e.dict.limiter.AddDictElemSize(valInDict.byteSize())

	// Indicate that an encoded {{ .StructName }} follows.
	e.buf.WriteBit(1)
    bitCount += 1
	// TODO: optimize and merge WriteBit with the following WriteBits.
	{{end -}}

    // Mask that describes what fields are encoded. Start with all modified fields.
    fieldMask := val.modifiedFields.mask

    // If forceModifiedFields we need to set to 1 all bits so that we
	// force writing of all fields.
	if e.forceModifiedFields {
        fieldMask =
			{{- range .Fields }}
                fieldModified{{ $.StructName }}{{.Name}} | {{end}}0
    }

    // Only write fields that we want to write. See Init() for keepFieldMask.
    fieldMask &= e.keepFieldMask

	// Write bits to indicate which fields follow.
	e.buf.WriteBits(fieldMask, e.fieldCount)
    bitCount += e.fieldCount

	{{ if .OptionalFieldCount}}
    // Write bits to indicate which optional fields are set.
    e.buf.WriteBits(val.optionalFieldsPresent, {{ .OptionalFieldCount}})
    bitCount += {{ .OptionalFieldCount}}
	{{- end}}

    // Encode modified, present fields.
    {{ range .Fields }}
	if fieldMask & fieldModified{{ $.StructName }}{{.Name}} != 0
		{{- if .Optional -}}
        &&
		val.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
		{{- end}} {
		// Encode {{.Name}}
		e.{{.name}}Encoder.Encode({{- if .Type.Flags.TakePtr}}&{{end}}val.{{.name}})
	}
	{{ end }}

    // Account written bits in the limiter.
    e.limiter.AddFrameBits(bitCount)

    // Mark all fields non-modified so that next Encode() correctly
    // encodes only fields that change after this.
    val.modifiedFields.mask = 0
}

// CollectColumns collects all buffers from all encoders into buf.
func (e *{{ .StructName }}Encoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
    columnSet.SetBits(&e.buf)
    colIdx := 0
    {{ range $i,$e := .Fields }}
    // Collect {{.Name}} field.
    if e.fieldCount <= {{$i}} {
        return // {{.Name}} and subsequent fields are skipped.
    }
    {{if not .IsPrimitive -}}
    if !e.is{{.Name}}Recursive {
        e.{{.name}}Encoder.CollectColumns(columnSet.At(colIdx))
        colIdx++
    }
    {{else}}
    e.{{.name}}Encoder.CollectColumns(columnSet.At(colIdx))
    colIdx++
    {{end -}}
    {{end -}}
}

// {{ .StructName }}Decoder implements decoding of {{ .StructName }}
type {{ .StructName }}Decoder struct {
    buf pkg.BitsReader
    column *pkg.ReadableColumn
    fieldCount uint

    {{ range .Fields }}
    {{.name}}Decoder {{if not .IsPrimitive}}*{{end}}{{ .Type.EncoderType }}Decoder
    {{if not .IsPrimitive}}is{{.Name}}Recursive bool
    {{end}}
    {{- end }}
    {{if .DictName}}
    dict *{{ .StructName }}DecoderDict
    {{end}}
    allocators *Allocators
}

// Init is called once in the lifetime of the stream.
func (d *{{ .StructName }}Decoder) Init(state* ReaderState, columns *pkg.ReadColumnSet) error {
    // Remember this decoder in the state so that we can detect recursion.
    if state.{{.StructName}}Decoder != nil {
        panic("cannot initialize {{ .StructName }}Decoder: already initialized")
    }
    state.{{.StructName}}Decoder = d
    defer func() { state.{{.StructName}}Decoder = nil }()

    d.allocators = &state.Allocators

    // Number of fields in the input data schema.
    var err error
    d.fieldCount, err = state.StructFieldCounts.{{.StructName}}FieldCount()
    if err != nil {
        return fmt.Errorf("cannot find struct %s in override schema: %v", {{printf "%q" .StructName}}, err)
    }

    d.column = columns.Column()

    {{- if .DictName}}
    d.dict = &state.{{.DictName}}
    {{- end}}

    {{ range $i,$e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return nil // {{.Name}} and subsequent fields are skipped.
    }
    {{- if .Type.IsPrimitive}}
        {{- if .Type.DictName}}
            err = d.{{.name}}Decoder.Init(&state.{{.Type.DictName}}, columns.AddSubColumn())
        {{- else}}
            err = d.{{.name}}Decoder.Init(columns.AddSubColumn())
        {{- end}}
    {{- else}}
    if state.{{.Type.EncoderType}}Decoder != nil {
        // Recursion detected, use the existing decoder.
        d.{{.name}}Decoder = state.{{.Type.EncoderType}}Decoder
        d.is{{.Name}}Recursive = true // Mark that we are using a recursive decoder.
    } else {
        d.{{.name}}Decoder = new({{.Type.EncoderType}}Decoder)
        err = d.{{.name}}Decoder.Init(state, columns.AddSubColumn())
    }
    {{- end}}
    if err != nil {
        return err
    }
    {{- end }}

    return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *{{ .StructName }}Decoder) Continue() {
    d.buf.Reset(d.column.Data())

    {{ range $i,$e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return // {{.Name}} and subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !d.is{{.Name}}Recursive {
        d.{{.name}}Decoder.Continue()
    }
    {{else}}d.{{.name}}Decoder.Continue(){{end}}
    {{- end }}
}

func (d *{{ .StructName }}Decoder) Reset() {
    {{ range $i, $e := .Fields }}
    if d.fieldCount <= {{$i}} {
        return // {{.Name}} and all subsequent fields are skipped.
    }
    {{if not .IsPrimitive}}
    if !d.is{{.Name}}Recursive {
        d.{{.name}}Decoder.Reset()
    }
    {{else}}d.{{.name}}Decoder.Reset(){{end}}
    {{- end}}
}

func (d *{{ .StructName }}Decoder) Decode(dstPtr {{if.DictName}}*{{end}}*{{.StructName}}) error {
    {{- if .DictName}}
	// Check if this is a dictionary-based decoding.
    dictFlag := d.buf.ReadBit()
    if dictFlag == 0 {
        refNum := d.buf.ReadUvarintCompact()
        if refNum >= uint64(len(d.dict.dict)) {
            return pkg.ErrInvalidRefNum
        }
        *dstPtr = d.dict.dict[refNum]
        return nil
    }

	// *dstPtr is pointing to a element in the dictionary. We are not allowed
	// to modify it. Make a clone of it and decode into the clone.
	val := (*dstPtr).Clone(d.allocators)
    *dstPtr = val
	{{- else}}
    val := dstPtr
    {{- end}}

    var err error

    // Read bits that indicate which fields follow.
    val.modifiedFields.mask = d.buf.ReadBits(d.fieldCount)

    {{ if .OptionalFieldCount}}
    // Write bits to indicate which optional fields are set.
    val.optionalFieldsPresent = d.buf.ReadBits({{ .OptionalFieldCount}})
    {{- end}}

    {{ range .Fields }}
    if val.modifiedFields.mask & fieldModified{{ $.StructName }}{{.Name}} != 0
    {{- if .Optional -}}
    &&
    val.optionalFieldsPresent & fieldPresent{{ $.StructName }}{{.Name}} != 0
    {{- end}} {
		// Field is changed and is present, decode it.
        {{- if .Type.Flags.StoreByPtr}}
        if val.{{.name}} == nil {
            val.{{.name}} = d.allocators.{{ .Type.Storage }}.Alloc()
            val.{{.name}}.init(&val.modifiedFields, fieldModified{{ $.StructName }}{{.Name}})
        }
        {{end}}
 		err = d.{{.name}}Decoder.Decode({{if .Type.Flags.DecodeByPtr}}&{{end}}val.{{.name}})
        if err != nil {
            return err
        }
    }
    {{ end }}

    {{if .DictName}}
    d.dict.dict = append(d.dict.dict, val)
    {{end}}

    return nil
}

{{if .DictName}}
// {{ .StructName }}DecoderDict is the dictionary used by {{ .StructName }}Decoder
type {{ .StructName }}DecoderDict struct {
    dict []*{{.StructName}}
}

func (d* {{ .StructName }}DecoderDict) Init() {
    d.dict = d.dict[:0]
    d.dict = append(d.dict, nil) // nil {{.StructName}} is RefNum 0
}

// Reset the dictionary to initial state. Used when a frame is
// started with RestartDictionaries flag.
func (d* {{ .StructName }}DecoderDict) Reset() {
    d.Init()
}
{{end}}

// {{.StructName}}Allocator implements a custom allocator for {{.StructName}}.
// It maintains a pool of pre-allocated {{.StructName}} and grows the pool
// dynamically as needed, up to a maximum size of 64 elements.
type {{.StructName}}Allocator struct {
    pool []{{.StructName}}
    ofs int
}

// Alloc returns the next available {{.StructName}} from the pool.
// If the pool is exhausted, it grows the pool by doubling its size
// up to a maximum of 64 elements.
func (a *{{.StructName}}Allocator) Alloc() *{{.StructName}} {
    if a.ofs < len(a.pool) {
        // Get the next available {{.StructName}} from the pool
        a.ofs++
        return &a.pool[a.ofs-1]
    }
    // We've exhausted the current pool, prealloc a new pool.
    return a.prealloc()
}

//go:noinline
func (a *{{.StructName}}Allocator) prealloc() *{{.StructName}} {
    // prealloc expands the pool by doubling its size, up to a maximum of 64 elements.
    // If the pool is empty, it starts with 1 element.
    newLen := min(max(len(a.pool)*2, 1), 64)
    a.pool = make([]{{.StructName}}, newLen)
    a.ofs = 1
    return &a.pool[0]
}

{{if .IsMainStruct}}
var wireSchema{{.StructName}} = []byte{ {{printf .Schema}} }

func {{.StructName}}WireSchema() (schema.WireSchema, error) {
    var w schema.WireSchema
    if err := w.Deserialize(bytes.NewReader(wireSchema{{.StructName}})); err != nil {
        return w, err
    }
    return w,nil
}
{{end}}